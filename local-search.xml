<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Reading And Thinking</title>
    <link href="/2021/03/17/9_Reading-And-Thinking/"/>
    <url>/2021/03/17/9_Reading-And-Thinking/</url>
    
    <content type="html"><![CDATA[<h3 id="0｜计算机网络-自顶向下方法"><a href="#0｜计算机网络-自顶向下方法" class="headerlink" title="0｜计算机网络-自顶向下方法"></a>0｜计算机网络-自顶向下方法</h3><h4 id="2021-3-17"><a href="#2021-3-17" class="headerlink" title="2021-3-17"></a>2021-3-17</h4><h5 id="计算机网络概论-P54"><a href="#计算机网络概论-P54" class="headerlink" title="计算机网络概论 P54"></a>计算机网络概论 <code>P54</code></h5><blockquote><p>未来网络的发展方向：</p><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-17-005635.png" alt="image-20210317085634458"></p><p>未来的网络部署的智能软件代理功能就是数据挖掘，所以数据挖掘的范围并不是局限于互联网的内容产生的数据，更广阔的应用在于对于端（主机）产生的数据挖掘。</p><p>对于主机，我们一定要使用一种安全的语言，所以这可能是Rust具有未来的原因吧。</p><ul><li>未来网络发展要解决的问题</li><li>未来网络发展的方向</li><li>Rust应用在嵌入式中有哪些弊端？相比其他的语言有什么优势？</li></ul></blockquote><blockquote><p>计算机网络存在的理由：</p><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-17-010231.png" alt="image-20210317090231061"></p><p>未来的技术发展是要开拓更加实用的网络应用，而不是局限于现在的网络应用。<code>本书的读者能够创建下一代招人喜爱的因特网应用。</code>这才是学习计算机网络的目的。</p><p>创建下一代因特网应用的前提是要明白计算机网络的原理。</p><p>未来的网络应用：</p><ul><li>全息投影的游戏</li><li>全息投影的导航系统</li><li>根据数据挖掘出来的生活习惯—嵌入式助手（规划个人的生活）</li><li>5G的发展对于人们生活的影响<ul><li><input disabled="" type="checkbox"> 下一代5G的因特网应用</li><li><input disabled="" type="checkbox"> 了解5G的优点和缺点</li><li><input disabled="" type="checkbox"> 5G开发已经在路上</li></ul></li></ul></blockquote><h4 id="2021-3-18"><a href="#2021-3-18" class="headerlink" title="2021-3-18"></a>2021-3-18</h4><blockquote><p>1、如何将想法转化为真实世界的网络应用：</p><p>研发网络应用程序的核心是写出能够运行在<code>不同的端系统</code>和<code>通过网络彼此通信的程序</code>。</p><p>应用程序体系结构：</p><p>规定如何在各种端系统上组织该应用程序，在现在网络应用程序中使用的两种主流体系结构：客户-服务器体系结构或对等（P2P）体系结构。</p><p>客户服务器体系：比如Web应用程序，当Web服务器收到来自某用户的请求时，它向客户发送<code>所请求的对象(request)</code>作为<code>响应(response)</code>。</p><p>P2P体系结构：</p><p>应用程序在<code>间接连接</code>的主机对之间使用<code>直接通信</code>。</p><ul><li><input disabled="" type="checkbox"> 加密的百度云盘（企业级应用，安全、高效）</li><li><input disabled="" type="checkbox"> 如何对等（上传和下载一样多）</li></ul></blockquote><blockquote><p>2、进程通信</p><p>运行在多个端系统上的程序是如何相互通信的情况有一个基本的了解，在操作系统的层次上，相互通信的实际是进程而不是程序。进程间通信的规则由端系统上的操作系统确定。</p><p>在不同端系统上的进程，通过跨国计算机网络交换报文的相互通信。发送进程生成并向网络中发送报文，接收进程接收这些报文，并通过报文发送回去进行响应。</p><ul><li><input disabled="" type="checkbox"> 可能不好理解的就是为什么是进程到进程之间的通信？</li></ul></blockquote><blockquote><p>3、进程与计算机网络之间的接口：</p><p>进程通过一个称为套接字<code>socket</code>的软件结构向网络发送报文和从网络接收报文。进程好比是房子，套接字好比是他的门。</p><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-18-003403.png" alt="image-20210318083357996"></p></blockquote><blockquote><p>4、进程寻址</p><p>为了保证进程通信之间的准确性（比如QQ发送的消息微信并不能收到，你发送的消息别人并不能收到），发送目的地必须要一个地址，所以这就涉及到网络协议中各层的地址标识。</p><ul><li><input disabled="" type="checkbox"> 在网络应用编程中这些参数应该如何使用？</li></ul><p>应用层：端口号</p><p>网络层：ip地址</p><p>链路层：MAC地址</p></blockquote><blockquote><p>5、可供应用程序使用的运输服务</p><p><code>套接字是应用程序进程和运输层协议之间的接口</code></p><p>很多网络提供了不知一种运输层协议，在开发一个应用时，必须根据实际情况选用一种运输层协议，为你的应用需求提供恰当服务的协议。比如银行的数据传输必须是安全的不能丢失的，微信视频的时候允许有卡顿、丢失（你刚说了啥我没听见）</p><p>在运输层既可以提供可靠的数据传输、也可以提供不可靠的数据传输</p></blockquote><h3 id="1｜数据结构-邓俊辉"><a href="#1｜数据结构-邓俊辉" class="headerlink" title="1｜数据结构                                    邓俊辉"></a>1｜数据结构                                    <code>邓俊辉</code></h3><h4 id="2021-3-17-1"><a href="#2021-3-17-1" class="headerlink" title="2021-3-17"></a>2021-3-17</h4><h5 id="1｜算法的基本要求：P5-P16"><a href="#1｜算法的基本要求：P5-P16" class="headerlink" title="1｜算法的基本要求：P5-P16"></a>1｜算法的基本要求：<code>P5-P16</code></h5><blockquote><p>1、输入与输出</p></blockquote><blockquote><p>2、基本操作、确定性、可行性</p></blockquote><blockquote><p>3、正确定、有穷性</p><p>如何保证算法的正确性与有穷性？</p><p>通过不变性与单调性进行保证（此处的单调性与数学中的单调性有略微差别）</p><p>单调性是指问题的有效规模会随着算法的推进不断递减</p><p>不变形是指程序的每一轮循环或者是迭代都满足题目的要求，所以掌握迭代和循环很重要。</p></blockquote><blockquote><p>4、退化与鲁棒性</p><p>退化就是要考虑输入的各种极端的实例，也就是边界条件的考虑</p><p>鲁棒性：将可能的将边界条件考虑全面</p></blockquote><blockquote><p>5、重用性</p><p>算法模式推广：比如说用于不同的数据类型</p></blockquote><h5 id="2｜算法效率"><a href="#2｜算法效率" class="headerlink" title="2｜算法效率"></a>2｜算法效率</h5><blockquote><p>1、计算效率</p></blockquote><blockquote><p>2、数据结构</p><p>不论输入、输出、中间结果都是在计算机中以数据的形式表示的，对数据的存储、组织、转移以及变换等操作，对不同的计算模型和平台环境所支持的具体形式不尽相同，执行效率直接影响整体的效率。</p><p>数据结构就是以数据作为研究对象，建立支持高效算法的数据处理策略、技巧以及方法。也就是研究数据如何进行增、删、改、查更加高效而且满足实际的要求。</p><p>要做到根据实际应用需求自如的设计、实现和选用适当的数据结构，必须要首先对算法设计的技巧以及相应的数据结构的特征了然于心。</p><p>归根结底在于：算法设计的技巧、数据结构的特征。</p><p>所以学习这本书的关键在于掌握书中算法设计的技巧，以及掌握数据结构的特征。</p></blockquote><h5 id="3｜复杂度分析"><a href="#3｜复杂度分析" class="headerlink" title="3｜复杂度分析"></a>3｜复杂度分析</h5><blockquote><p>时间复杂度</p></blockquote><blockquote><p>空间复杂度</p></blockquote><blockquote><p>渐进复杂度</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Reading</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Reading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++_Acwing</title>
    <link href="/2021/03/16/0_C++_Acwing/"/>
    <url>/2021/03/16/0_C++_Acwing/</url>
    
    <content type="html"><![CDATA[<h3 id="2｜数据结构"><a href="#2｜数据结构" class="headerlink" title="2｜数据结构"></a>2｜数据结构</h3><h4 id="2021-3-17"><a href="#2021-3-17" class="headerlink" title="2021 - 3 -17"></a>2021 - 3 -17</h4><h5 id="1｜题目"><a href="#1｜题目" class="headerlink" title="1｜题目"></a>1｜题目</h5><blockquote><p><a href="https://www.acwing.com/problem/content/828/">https://www.acwing.com/problem/content/828/</a></p></blockquote><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-17-062437.png" alt="image-20210317142437242" style="zoom:33%;" /><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-17-062455.png" alt="image-20210317142455159"></p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-17-062525.png" alt="image-20210317142524989" style="zoom:33%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> elem[M],List[M];<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> head,avil;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head = <span class="hljs-number">-1</span>;<br>    avil = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Head</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    elem[avil] = x;<br>    List[avil] = head;<br>    head = avil;<br>    avil ++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    elem[avil] = x;<br>    List[avil] = List[k];<br>    List[k] = avil;<br>    avil ++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    List[k] = List[List[k]];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Init();<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;m);<br>    <span class="hljs-keyword">char</span> op;<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> x,k;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; op;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;H&#x27;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>            Head(x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;I&#x27;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt;k &gt;&gt; x;<br>            Insert(k,x);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; k;<br> <span class="hljs-comment">//这里不是很清楚，头结点的作用是什么？为了遍历？</span><br>            <span class="hljs-keyword">if</span>(!k)  head = List[head];  <br>            Delete(k);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i= head;i!=<span class="hljs-number">-1</span>;i=List[i])     <span class="hljs-built_in">cout</span> &lt;&lt; elem[i]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>环境搭建常见问题</title>
    <link href="/2021/03/12/2_%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2021/03/12/2_%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="环境搭建常见问题及处理"><a href="#环境搭建常见问题及处理" class="headerlink" title="环境搭建常见问题及处理"></a>环境搭建常见问题及处理</h3><h4 id="1｜VS-Code配置C-的debug"><a href="#1｜VS-Code配置C-的debug" class="headerlink" title="1｜VS Code配置C++的debug"></a>1｜VS Code配置C++的debug</h4><p><code>mac OS</code></p><h5 id="问题1-无法在vs-code的内置终端中进行输入，也就是会出现终端将被任务重用，按任意键关闭，而且不启动外部终端，即使启动外部终端也无法读入输入。"><a href="#问题1-无法在vs-code的内置终端中进行输入，也就是会出现终端将被任务重用，按任意键关闭，而且不启动外部终端，即使启动外部终端也无法读入输入。" class="headerlink" title="问题1:无法在vs code的内置终端中进行输入，也就是会出现终端将被任务重用，按任意键关闭，而且不启动外部终端，即使启动外部终端也无法读入输入。"></a>问题1:无法在vs code的内置终端中进行输入，也就是会出现终端将被任务重用，按任意键关闭，而且不启动外部终端，即使启动外部终端也无法读入输入。</h5><blockquote><p>问题原因：The issue is when VSCode launches the debug adapter, then the debug adapter launches <code>lldb-mi</code>, then <code>lldb-mi</code> launches <code>Terminal</code>. There is a prompt that should appear, but somehow the DebugAdapter is not forwarding this permissions request.</p><p>解决方法：因为vscode的macos版本目前还不支持C++的debug的内置终端输入，所以要启动自带的终端进行调试的输入。按照官方文档配置launch.json和tasks.json文件，然后在tasks.json文件中加入启动外部终端的代码块。</p><p><code>launch.json配置</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>    <span class="hljs-comment">// 使用 IntelliSense 了解相关属性。 </span><br>    <span class="hljs-comment">// 悬停以查看现有属性的描述。</span><br>    <span class="hljs-comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span><br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.2.0&quot;</span>,<br>    <span class="hljs-string">&quot;configurations&quot;</span>: [<br>        &#123;<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;g++-10 - 生成和调试活动文件&quot;</span>,<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;cppdbg&quot;</span>,<br>            <span class="hljs-string">&quot;request&quot;</span>: <span class="hljs-string">&quot;launch&quot;</span>,<br>            <span class="hljs-string">&quot;program&quot;</span>: <span class="hljs-string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span>,<br>            <span class="hljs-string">&quot;args&quot;</span>: [],<br>            <span class="hljs-string">&quot;stopAtEntry&quot;</span>: <span class="hljs-literal">false</span>,<br>            <span class="hljs-string">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,<br>            <span class="hljs-string">&quot;environment&quot;</span>: [],<br>            <span class="hljs-string">&quot;externalConsole&quot;</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-string">&quot;MIMode&quot;</span>: <span class="hljs-string">&quot;lldb&quot;</span>,<br>            <span class="hljs-string">&quot;preLaunchTask&quot;</span>: <span class="hljs-string">&quot;C/C++: g++-10 生成活动文件&quot;</span><br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p><code>tasks.json配置</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>    <span class="hljs-string">&quot;tasks&quot;</span>: [<br>        &#123;<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;cppbuild&quot;</span>,<br>            <span class="hljs-string">&quot;label&quot;</span>: <span class="hljs-string">&quot;C/C++: g++-10 生成活动文件&quot;</span>,<br>            <span class="hljs-string">&quot;command&quot;</span>: <span class="hljs-string">&quot;/usr/local/bin/g++-10&quot;</span>,<br>            <span class="hljs-string">&quot;args&quot;</span>: [<br>                <span class="hljs-string">&quot;-g&quot;</span>,<br>                <span class="hljs-string">&quot;$&#123;file&#125;&quot;</span>,<br>                <span class="hljs-string">&quot;-o&quot;</span>,<br>                <span class="hljs-string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span><br>            ],<br>            <span class="hljs-string">&quot;options&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><br>            &#125;,<br>            <span class="hljs-string">&quot;problemMatcher&quot;</span>: [<br>                <span class="hljs-string">&quot;$gcc&quot;</span><br>            ],<br>            <span class="hljs-string">&quot;group&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;kind&quot;</span>: <span class="hljs-string">&quot;build&quot;</span>,<br>                <span class="hljs-string">&quot;isDefault&quot;</span>: <span class="hljs-literal">true</span><br>            &#125;,<br>            <span class="hljs-string">&quot;detail&quot;</span>: <span class="hljs-string">&quot;调试器生成的任务。&quot;</span><br>        &#125;,<br><span class="hljs-comment">//需要在tasks的内容中增加以下的代码块以启动终端</span><br>        &#123;<br>            <span class="hljs-string">&quot;label&quot;</span>: <span class="hljs-string">&quot;Open Terminal&quot;</span>,<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>,<br>            <span class="hljs-string">&quot;command&quot;</span>: <span class="hljs-string">&quot;osascript -e &#x27;tell application \&quot;Terminal\&quot;\ndo script \&quot;echo hello\&quot;\nend tell&#x27;&quot;</span>,<br>            <span class="hljs-string">&quot;problemMatcher&quot;</span>: []<br>          &#125;<br>    ],<br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;2.0.0&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>配置完tasks.json文件后</p><p>1、You can run this specific task using <code>Command + Shift + p</code>. </p><p>2、Type <code>Tasks</code> and look for <code>Tasks: Run Tasks</code> then select <code>Open Terminal</code>.</p><p>Once you allow this permission, then the external console should appear when you debug.</p><p>成功配置后进行debug显示：</p><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-12-003807.png" alt="image-20210312083804302"></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>VSCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python语法</title>
    <link href="/2021/03/10/1_Python_Codewar/"/>
    <url>/2021/03/10/1_Python_Codewar/</url>
    
    <content type="html"><![CDATA[<h4 id="0｜目标"><a href="#0｜目标" class="headerlink" title="0｜目标"></a>0｜目标</h4><ul><li><input disabled="" type="checkbox"> 实验楼中的python百题冲关学习完成</li><li><input disabled="" type="checkbox"> 实验楼中的pandas百题冲关学习完成</li><li><input disabled="" type="checkbox"> 实验楼中的NumPy百题冲关学习完成</li></ul><h4 id="1｜字符串string"><a href="#1｜字符串string" class="headerlink" title="1｜字符串string"></a>1｜字符串string</h4><h5 id="1｜基本操作"><a href="#1｜基本操作" class="headerlink" title="1｜基本操作"></a>1｜基本操作</h5><blockquote><p>1、<code>split()|join()</code></p><p><code>str.split(&#39;char&#39;)</code> : 其中str为待操作的字符串，参数char为以什么字符分割</p><p><code>str.join(iterable)</code> : str为在迭代对象<code>iterable</code>的各个成员之间添加的字符。</p><p>2、生成器：在Python中，这种一边循环一边计算的机制，称为<strong>生成器</strong>：generator。</p><p>3、迭代器：</p><p>我们已经知道，可以直接作用于<code>for</code>循环的数据类型有以下几种：一类是集合数据类型，如<code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code>、<code>str</code>等；一类是<code>generator</code>，包括生成器和带<code>yield</code>的generator function。这些可以直接作用于<code>for</code>循环的对象统称为可迭代对象：<code>Iterable</code>。可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterable</code>对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#return 返回时一个string类型变量</span><br><span class="hljs-comment"># 字符串切片</span><br><span class="hljs-comment"># 字符串逆序输出</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse_words</span>(<span class="hljs-params"><span class="hljs-built_in">str</span></span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>.join(s[::-<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>.split(<span class="hljs-string">&#x27; &#x27;</span>))<br>  <br>  <br>s = <span class="hljs-string">&quot;This is an example!&quot;</span><br><span class="hljs-comment"># 实现字符串的分割</span><br>s1 = s.split(<span class="hljs-string">&#x27; &#x27;</span>)<br>print(<span class="hljs-built_in">type</span>(s1))<br><span class="hljs-comment"># &lt;class &#x27;list&#x27;&gt;</span><br><br><span class="hljs-comment"># 生成器</span><br><span class="hljs-comment"># 生成器中的item是str类型的，并且实现将item逆序</span><br>s2 = (item[::-<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> s1)<br>print(<span class="hljs-built_in">type</span>(s2))<br><span class="hljs-comment"># &lt;class &#x27;generator&#x27;&gt;</span><br>print(<span class="hljs-built_in">type</span>(item))<br><span class="hljs-comment"># &lt;class &#x27;str&#x27;&gt;</span><br><br><br><span class="hljs-comment"># string的join方法</span><br><span class="hljs-comment"># str.join()函数操作的成员要求是可迭代对象，生成器也是可迭代对象。</span><br>s3 = <span class="hljs-string">&#x27; &#x27;</span>.join(item[::-<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> s.split(<span class="hljs-string">&#x27; &#x27;</span>))<br>print(s3)<br><span class="hljs-comment"># sihT si na !elpmaxe</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="2｜list操作"><a href="#2｜list操作" class="headerlink" title="2｜list操作"></a>2｜list操作</h4><h5 id="1｜count-操作"><a href="#1｜count-操作" class="headerlink" title="1｜count 操作"></a>1｜count 操作</h5><blockquote><p>1、筛选list中满足条件的值，并返回值的数量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count_sheeps</span>(<span class="hljs-params">arrayOfSheeps</span>):</span><br>  <span class="hljs-keyword">return</span> arrayOfSheeps.count(<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 返回 list中值为True的数量</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="2021-3-18"><a href="#2021-3-18" class="headerlink" title="2021-3-18"></a>2021-3-18</h4><h5 id="1｜Given-two-arrays-a-and-b-write-a-function-comp-a-b-orcompSame-a-b-that-checks-whether-the-two-arrays-have-the-“same”-elements-with-the-same-multiplicities-“Same”-means-here-that-the-elements-in-b-are-the-elements-in-a-squared-regardless-of-the-order"><a href="#1｜Given-two-arrays-a-and-b-write-a-function-comp-a-b-orcompSame-a-b-that-checks-whether-the-two-arrays-have-the-“same”-elements-with-the-same-multiplicities-“Same”-means-here-that-the-elements-in-b-are-the-elements-in-a-squared-regardless-of-the-order" class="headerlink" title="1｜Given two arrays a and b write a function comp(a, b) (orcompSame(a, b)) that checks whether the two arrays have the “same” elements, with the same multiplicities. “Same” means, here, that the elements in b are the elements in a squared, regardless of the order."></a>1｜Given two arrays <code>a</code> and <code>b</code> write a function <code>comp(a, b)</code> (or<code>compSame(a, b)</code>) that checks whether the two arrays have the “same” elements, with the same <em>multiplicities</em>. “Same” means, here, that the elements in <code>b</code> are the elements in <code>a</code> squared, regardless of the order.</h5><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-18-024925.png" alt="image-20210318104921162"></p><blockquote><p>解决方法：排序后对比</p><p>因为数组或者是列表无序，如果使用for循环挨个对比，则时间复杂度为$O(n^2)$；</p><p>所以使用排序后对比可以降低时间复杂度，而且可以保证正确性。</p></blockquote><blockquote><p>语法：try、except、sorted()函数</p><p>if……else和try、except的区别？</p><p>try和except是python的异常处理</p><ul><li><input disabled="" type="checkbox"> python异常处理</li></ul><p>sorted函数</p><p><code>sorted(iterable, ***, key=None, reverse=False)</code></p><p>Return a new sorted list from the items in <em>iterable</em>.</p><p><em>key</em> specifies a function of one argument that is used to extract a comparison key from each element in <em>iterable</em> (for example, <code>key=str.lower</code>). The default value is <code>None</code> (compare the elements directly).</p><p>key就是一个函数的功能</p><p><em>reverse</em> is a boolean value. If set to <code>True</code>, then the list elements are sorted as if each comparison were reversed.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>]<br>b = <span class="hljs-built_in">sorted</span>(a,key=<span class="hljs-built_in">str</span>.lower,reverse=<span class="hljs-literal">True</span>)<br>print(b)<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">comp</span>(<span class="hljs-params">array1, array2</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sorted</span>([i ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> array1]) == <span class="hljs-built_in">sorted</span>(array2)<br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">comp</span>(<span class="hljs-params">array1, array2</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">sorted</span>([i*i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> array1]) == <span class="hljs-built_in">sorted</span>(array2):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h5 id="2｜print-Error"><a href="#2｜print-Error" class="headerlink" title="2｜print Error"></a>2｜print Error</h5><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-19-003310.png" alt="image-20210319083309725"></p><blockquote><p>解题思路：</p><p>就是在目标串中找出不符合要求的串，python中提供的机制有两种；第一种是使用re库进行查找，第二种是普通的查找，不满足要求的count++；</p><p>1、利用正则表达式</p><p>2、利用string的运算</p></blockquote><blockquote><p>语法：</p><p>正则表达式：<a href="https://docs.python.org/zh-cn/3/library/re.html?highlight=re#module-re">https://docs.python.org/zh-cn/3/library/re.html?highlight=re#module-re</a></p></blockquote><blockquote><p>语法：</p><p>string的查找与判断（子串的查找）</p><ul><li><pre><code class="python">[x for x in s if x not in &quot;abcdefghijklm&quot;]<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- ```python<br>  if i &gt; <span class="hljs-string">&quot;m&quot;</span>:<br></code></pre></td></tr></table></figure></code></pre></li></ul><p>len()函数的使用</p><ul><li><p>Return the length (the number of items) of an object. The argument may be a sequence (<code>such as a string, bytes, tuple, list, or range</code>) or a collection (such as a dictionary, set, or frozen set).</p></li><li><p>len()函数中参数可以是字符串、字节？、元素、列表或者是范围，字典、集合、冻结集</p></li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 利用正则表达式</span><br><span class="hljs-keyword">from</span> re <span class="hljs-keyword">import</span> sub<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printer_error</span>(<span class="hljs-params">s</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#125;/&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(sub(<span class="hljs-string">&quot;[a-m]&quot;</span>,<span class="hljs-string">&#x27;&#x27;</span>,s)),<span class="hljs-built_in">len</span>(s))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printer_error</span>(<span class="hljs-params">s</span>):</span><br>    <span class="hljs-keyword">import</span> re<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(re.findall(<span class="hljs-string">&#x27;[n-z]&#x27;</span>, s))) + <span class="hljs-string">&quot;/&quot;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(s))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printer_error</span>(<span class="hljs-params">s</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#125;/&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>([x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> s <span class="hljs-keyword">if</span> x <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;abcdefghijklm&quot;</span>]), <span class="hljs-built_in">len</span>(s))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printer_error</span>(<span class="hljs-params">s</span>):</span><br>    errors = <span class="hljs-number">0</span><br>    count = <span class="hljs-built_in">len</span>(s)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:<br>        <span class="hljs-keyword">if</span> i &gt; <span class="hljs-string">&quot;m&quot;</span>:<br>            errors += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(errors) + <span class="hljs-string">&quot;/&quot;</span> + <span class="hljs-built_in">str</span>(count)<br></code></pre></td></tr></table></figure><h4 id="2021-3-20"><a href="#2021-3-20" class="headerlink" title="2021-3-20"></a>2021-3-20</h4><h5 id="1｜Find-the-unique-number"><a href="#1｜Find-the-unique-number" class="headerlink" title="1｜Find the unique number"></a>1｜Find the unique number</h5><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-20-092501.png" alt="image-20210320172458124"></p><blockquote><p>算法：</p><p>扫描数组，找到数组中count = 1的元素并输出</p></blockquote><blockquote><p>语法：</p><p>1、使用set（集合）的性质：set中会有去重的功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 对set内元素的赋值</span><br>s = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;<br>a ,b = s<br><span class="hljs-comment"># a = 1</span><br><span class="hljs-comment"># b = 3</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>2、count()方法的使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.count(x) <span class="hljs-comment"># x在s中出现的次数</span><br></code></pre></td></tr></table></figure><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-20-093528.png" alt="image-20210320173528204"></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_uniq</span>(<span class="hljs-params">arr</span>):</span><br>    a, b = <span class="hljs-built_in">set</span>(arr)<br>    <span class="hljs-keyword">return</span> a <span class="hljs-keyword">if</span> arr.count(a) == <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> b<br></code></pre></td></tr></table></figure><h5 id="2｜Take-a-Ten-Minute-Walk"><a href="#2｜Take-a-Ten-Minute-Walk" class="headerlink" title="2｜Take a Ten Minute Walk"></a>2｜Take a Ten Minute Walk</h5><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-20-094310.png" alt="image-20210320174310503"></p><blockquote><p>语法：</p><p>count()方法的使用</p></blockquote><blockquote><p>算法：</p><p>如果返回原点则n、s、w、e的计数相同</p><p>经过多次变化的后仍为0，n与s为相反，所以遇到n则加1，遇到s则减1；w与e同理;</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isValidWalk</span>(<span class="hljs-params">walk</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(walk) == <span class="hljs-number">10</span> <span class="hljs-keyword">and</span> walk.count(<span class="hljs-string">&#x27;n&#x27;</span>) == walk.count(<span class="hljs-string">&#x27;s&#x27;</span>) <span class="hljs-keyword">and</span> walk.count(<span class="hljs-string">&#x27;e&#x27;</span>) == walk.count(<span class="hljs-string">&#x27;w&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isValidWalk</span>(<span class="hljs-params">walk</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(walk) != <span class="hljs-number">10</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    x, y = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> direction <span class="hljs-keyword">in</span> walk:<br>        <span class="hljs-keyword">if</span> direction == <span class="hljs-string">&#x27;n&#x27;</span>:<br>            y += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> direction == <span class="hljs-string">&#x27;s&#x27;</span>:<br>            y -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> direction == <span class="hljs-string">&#x27;e&#x27;</span>:<br>            x += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> direction == <span class="hljs-string">&#x27;w&#x27;</span>:<br>            x -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">return</span> x == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> y == <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h5 id="3｜The-Supermarket-Queue"><a href="#3｜The-Supermarket-Queue" class="headerlink" title="3｜The Supermarket Queue"></a>3｜The Supermarket Queue</h5><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-20-145114.png" alt="image-20210320225114354"></p><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-20-145125.png" alt="image-20210320225125006"></p><blockquote><p>算法：</p></blockquote><blockquote><p>语法：</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
      <category>Base</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>grammar</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0_C++_小型项目</title>
    <link href="/2021/03/10/0_C++%E5%B0%8F%E5%9E%8B%E9%A1%B9%E7%9B%AE/"/>
    <url>/2021/03/10/0_C++%E5%B0%8F%E5%9E%8B%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="C-实现监控和运动检测"><a href="#C-实现监控和运动检测" class="headerlink" title="C++ 实现监控和运动检测"></a>C++ 实现监控和运动检测</h3><p><code>Makefile|OOP|OpenGL GLUT</code></p><h4 id="1｜环境配置"><a href="#1｜环境配置" class="headerlink" title="1｜环境配置"></a>1｜环境配置</h4><h5 id="1｜安装opencv"><a href="#1｜安装opencv" class="headerlink" title="1｜安装opencv"></a>1｜安装opencv</h5><blockquote><p>1、使用brew 安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install opencv<br></code></pre></td></tr></table></figure><p>2、安装完成后需要添加部分内容到<code>.zshrc</code>中，按照要求进行添加</p><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-10-073515.png" alt="image-20210310153515559"></p><p>3、测试安装是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install opencv-python<br></code></pre></td></tr></table></figure><p>4、安装完成后，使用python测试，测试显示安装成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3 <br>import cv2<br><span class="hljs-built_in">print</span>(cv2.__version__)<br></code></pre></td></tr></table></figure><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-10-073748.png" alt="image-20210310153748185"></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>小型项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>小型项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python爬虫</title>
    <link href="/2021/03/09/1_Python%E7%88%AC%E8%99%AB/"/>
    <url>/2021/03/09/1_Python%E7%88%AC%E8%99%AB/</url>
    
    <content type="html"><![CDATA[<hr><p>[TOC]</p><h3 id="0｜目标"><a href="#0｜目标" class="headerlink" title="0｜目标"></a>0｜目标</h3><ul><li><input disabled="" type="checkbox"> 完成蓝桥的11节课程</li><li><input disabled="" type="checkbox"> 爬取2020年经济学人的文章标题</li><li><input disabled="" type="checkbox"> 爬取链家的房价数据</li><li><input disabled="" type="checkbox"> 爬取小木虫的调剂信息，并保存在excel中</li><li><input disabled="" type="checkbox"> 爬取一个感兴趣的微信公众号</li><li><input disabled="" type="checkbox"> 爬取习大大重要讲话的文章，并按照关键字进行提取内容</li><li><input disabled="" type="checkbox"> 爬取B站的弹幕实现词云图片</li></ul><h3 id="1｜爬虫实现的原理以及简单步骤"><a href="#1｜爬虫实现的原理以及简单步骤" class="headerlink" title="1｜爬虫实现的原理以及简单步骤"></a>1｜爬虫实现的原理以及简单步骤</h3><blockquote><p>写爬虫就是通过python程序模拟HTTP协议，通过python中的编程技巧，让网站的服务器通过HTTP协议返回给写好的解析程序，然后将部分有用的数据通过筛选，然后存储到本地。</p></blockquote><h4 id="1｜http协议与https协议"><a href="#1｜http协议与https协议" class="headerlink" title="1｜http协议与https协议"></a>1｜http协议与https协议</h4><blockquote><p>HTTP协议的消息结构：客户端请求消息，服务器响应消息</p><p>客户端的请求消息就是请求报文，服务器的响应消息就是响应报文。</p><p>请求报文（request)：状态行、消息报头、空行、响应正文</p><p>响应报文（response)：请求头、请求数据、响应正文</p></blockquote><h5 id="1｜requsest"><a href="#1｜requsest" class="headerlink" title="1｜requsest"></a>1｜requsest</h5><blockquote><p>request url：请求地址</p><p>request method:请求方法</p><p>status code:状态码</p><p>remote address：当前HTTP请求的远程地址</p><p>reference policy：用于设置referrer策略<code>不知道怎么用</code></p></blockquote><h5 id="2｜request-header"><a href="#2｜request-header" class="headerlink" title="2｜request header"></a>2｜request header</h5><blockquote></blockquote><h4 id="2｜浏览器与服务器"><a href="#2｜浏览器与服务器" class="headerlink" title="2｜浏览器与服务器"></a>2｜浏览器与服务器</h4><h5 id="1｜浏览器的工作原理"><a href="#1｜浏览器的工作原理" class="headerlink" title="1｜浏览器的工作原理"></a>1｜浏览器的工作原理</h5><blockquote><ul><li>请说说从你在浏览器地址栏输入网站到你看到网页中间都发生了什么？</li></ul><p><a href="https://www.youtube.com/watch?v=jaPpP3cdgDQ">https://www.youtube.com/watch?v=jaPpP3cdgDQ</a></p></blockquote><h5 id="2｜URL"><a href="#2｜URL" class="headerlink" title="2｜URL"></a>2｜URL</h5><blockquote><p>一般的URL为：<a href="//%E8%AE%BF%E9%97%AE%E8%B5%84%E6%BA%90%E9%9C%80%E8%A6%81%E7%9A%84%E5%87%AD%E8%AF%81%E4%BF%A1%E6%81%AF@%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%B0%E5%9D%80:%E7%AB%AF%E5%8F%A3%E5%8F%B7/%E8%B5%84%E6%BA%90%E5%B1%82%E7%BA%A7UNIX%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E6%96%87%E4%BB%B6%E5%90%8D?%E6%9F%A5%E8%A9%A2#%E7%89%87%E6%AE%B5ID">  协议类型  </a> : //服务器地址:端口号/资源层级UNIX文件路径文件名?查詢#片段ID</p><p>其中[访问凭证信息]、[端口号]、[查询]、[片段ID]都属于选填项。</p></blockquote><blockquote><p>通常服务器为域名，有时也为ip地址</p></blockquote><blockquote><p><a href="https://www.youtube.com/watch?v=ZMjhBB17KVY">https://www.youtube.com/watch?v=ZMjhBB17KVY</a></p><p>https 为协议</p><p><a href="http://www.youtube.com/">www.youtube.com</a> 为域名</p><p>watch 为资源层级</p><p>v=ZMjhBB17KVY 为查询</p></blockquote><h5 id="3｜服务器"><a href="#3｜服务器" class="headerlink" title="3｜服务器"></a>3｜服务器</h5><blockquote><p><strong>服务器</strong>（英語：server）指：</p><ul><li>一个管理资源并为用户提供服务的计算机软件，通常分为<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8">文件服务器</a>（能使用户在其它计算机存取<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6">文件</a>），<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8">数据库服务器</a>和<a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9C%8D%E5%8A%A1%E5%99%A8">应用程序服务器</a>。</li><li>运行以上软件的<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA">计算机</a>，或稱為**<a href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E6%9C%BA_(%E7%BD%91%E7%BB%9C)">網路主機</a>**（host）。</li></ul><p>服务器与主機不同，主机是通过<a href="https://zh.wikipedia.org/wiki/%E7%B5%82%E7%AB%AF">终端</a>给用户使用的，服务器是通过网络给<a href="https://zh.wikipedia.org/wiki/%E5%AE%A2%E6%88%B7%E7%AB%AF">客户端</a>用户使用的，所以除了要擁有終端裝置，還要利用網路才能使用伺服器電腦，但用戶連上線後就能使用伺服器上的特定服務了。</p><p><a href="https://www.youtube.com/watch?v=L1O2zo3fGys">https://www.youtube.com/watch?v=L1O2zo3fGys</a></p></blockquote><h5 id="4｜DNS缓存"><a href="#4｜DNS缓存" class="headerlink" title="4｜DNS缓存"></a>4｜DNS缓存</h5><blockquote><p>为了提升域名查询效率，设计了域名缓存机制，当访问过某个网站并得到其IP后，会将其域名和IP缓存下来，下一次访问的时候，就不需要再请求域名服务器获取IP，直接使用缓存中的IP，提高了响应的速度。当然缓存是有有效时间（即TTL值）的，当过了有效时间后，再次请求网站，还是需要先请求域名解析。</p><p>baidu和google就需要使用DNS的缓存机制了</p></blockquote><h5 id="5｜Request-Headers-计算机网络应用层"><a href="#5｜Request-Headers-计算机网络应用层" class="headerlink" title="5｜Request Headers                                                                                               计算机网络应用层"></a>5｜Request Headers                                                                                               <code>计算机网络应用层</code></h5><blockquote><p>我们不断地请求一个网页数据，肯定会被检测到异常，所以我们需要考虑使用代理和Useragent。</p><p>有一些网站不喜欢被爬虫程序访问，所以会检测连接对象，如果是爬虫程序，也就是非人点击访问，它就会不让你继续访问，所以为了要让程序可以正常运行，需要隐藏自己的爬虫程序的身份。此时，我们就可以通过设置User Agent的来达到隐藏身份的目的，User Agent的中文名为用户代理，简称UA。</p><p>在HTTP的请求中使用，其实就是HTTP的请求报文</p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-10-085113.png" alt="image-20210310165113253" style="zoom:50%;" /><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-10-085235.png" alt="image-20210310165235350" style="zoom:50%;" /></blockquote><h5 id="6｜IP代理"><a href="#6｜IP代理" class="headerlink" title="6｜IP代理"></a>6｜IP代理</h5><blockquote><p>User Agent已经设置好了，但是还应该考虑一个问题，程序的运行速度是很快的，如果我们利用一个爬虫程序在网站爬取东西，一个固定IP的访问频率就会很高，这不符合人为操作的标准，因为人操作不可能在几ms内，进行如此频繁的访问。所以一些网站会设置一个IP访问频率的阈值，如果一个IP访问频率超过这个阈值，说明这个不是人在访问，而是一个爬虫程序。</p><ul><li><input disabled="" type="checkbox"> 设置IP代理</li></ul></blockquote><h5 id="7｜设置Cookie"><a href="#7｜设置Cookie" class="headerlink" title="7｜设置Cookie"></a>7｜设置Cookie</h5><blockquote><p>Http协议是无状态的，也就是说同一个人对服务器发送了两次请求，服务器没有能力知道这是否来自同一个人，因此就需要cookie来帮助服务器进行标识，因此当我们想要爬取需要登陆的网站时，我们就需要设置相应的Cookie。</p></blockquote><h5 id="8｜HTML代码"><a href="#8｜HTML代码" class="headerlink" title="8｜HTML代码"></a>8｜HTML代码</h5><blockquote><p>分别有什么用？</p><p>我们想要爬取的信息就藏在html代码中，我们可以通过解析方法提取其中我们想要的内容。如果html代码里面没有我们想要的数据，但是在网页里面却看到了，那就是浏览器通过ajax请求异步加载（偷偷下载）了那部分数据。</p><blockquote><p>CSS文件：css文件是把css代码放入一个单独盛放css的文件，css是以.css为扩展命名的，我们看到以.css为后缀的文件就是css文件。它是一种与html语言配合使用制作网页的文件，它的作用主要是控制html文章的布局，简单的说就是控制网页的显示外观。</p><p>JS文件：JavaScript 是一种解释型语言。因此，它不需要编译。JavaScript 以交互式和动态的方式呈现网页。这允许页面对事件做出反应，展示特殊效果，接受可变文本，验证数据，创建 cookie，检测用户的浏览器等。</p></blockquote></blockquote><h4 id="3｜编码与解码"><a href="#3｜编码与解码" class="headerlink" title="3｜编码与解码"></a>3｜编码与解码</h4><h3 id="2｜项目1-爬取蓝桥的全部课程标题"><a href="#2｜项目1-爬取蓝桥的全部课程标题" class="headerlink" title="2｜项目1:爬取蓝桥的全部课程标题"></a>2｜项目1:爬取蓝桥的全部课程标题</h3><h4 id="1｜使用环境"><a href="#1｜使用环境" class="headerlink" title="1｜使用环境"></a>1｜使用环境</h4><blockquote><p>使用vs code进行实现，因为是属于小项目，所以选用vs code进行编译</p></blockquote><h4 id="2｜实现Request对象"><a href="#2｜实现Request对象" class="headerlink" title="2｜实现Request对象"></a>2｜实现Request对象</h4><blockquote><p>URL：<a href="https://lanqiao-horuikidi.vercel.app/">https://lanqiao-horuikidi.vercel.app/</a></p></blockquote><h5 id="1｜requests库中get方法"><a href="#1｜requests库中get方法" class="headerlink" title="1｜requests库中get方法"></a>1｜requests库中get方法</h5><blockquote><p><code>requests库的文档</code><a href="https://requests.readthedocs.io/en/master/">https://requests.readthedocs.io/en/master/</a></p><p>get方法是发起网络请求的方法，可以在get方法中添加相关的参数，如url、headers、proxies等参数</p></blockquote><h5 id="2｜re库"><a href="#2｜re库" class="headerlink" title="2｜re库"></a>2｜re库</h5><blockquote><p>re库为python中自带的正则表达式的库，正则表达式是要好好学习一下的，因为在c++和python中都可以用到，同时以后的数据分析也可以用到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">result = re.match(<span class="hljs-string">&quot;str1&quot;</span>,<span class="hljs-string">&quot;str2&quot;</span>)<br></code></pre></td></tr></table></figure></blockquote><h4 id="3｜代码实现"><a href="#3｜代码实现" class="headerlink" title="3｜代码实现"></a>3｜代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br><span class="hljs-comment"># 定义函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_course</span>(<span class="hljs-params">url</span>):</span><br><span class="hljs-comment"># 设置请求头</span><br>    headers = &#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span> : <span class="hljs-string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 11_1_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36&#x27;</span>&#125;<br><span class="hljs-comment"># 使用get方法来发送请求</span><br>    res = requests.get(url,headers = headers)<br><span class="hljs-comment">#保存返回内容</span><br>    html_data = res.text<br><span class="hljs-comment">#   print(html_data)</span><br><span class="hljs-comment">#利用re库中的正则表达式的findall方法，查找html_data中满足正则表达式要求的内容，并返回到</span><br><span class="hljs-comment">#  results中</span><br>    results = re.findall(<span class="hljs-string">&#x27;&lt;h6 title=&quot;(.*)&quot; class=&quot;course-name&quot;&#x27;</span>,html_data)<br><span class="hljs-comment">#   print(results)</span><br><span class="hljs-comment">#利用循环将results中的结果格式化保存到文件data.txt中</span><br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> results:<br>        new_str = <span class="hljs-string">&quot;课程名:&#123;&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(item)<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./data.txt&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:<br>            f.write(new_str)<br><span class="hljs-comment">#使用python中列表数据结构保存所有的页面，通过循环结果一次爬取各个页面中的内容</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    start_urls = [<span class="hljs-string">&#x27;https://www.lanqiao.cn/courses/?page=1&#x27;</span>,]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">32</span>):<br>        start_urls.append(<span class="hljs-string">f&#x27;https://www.lanqiao.cn/courses/?page=<span class="hljs-subst">&#123;i&#125;</span>&#x27;</span>)<br>    <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> start_urls:<br>        save_course(url)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><blockquote><ul><li><p><input disabled="" type="checkbox">  python的文件操作</p></li><li><p><input disabled="" type="checkbox">  python的函数定义及使用</p></li><li><p><input disabled="" type="checkbox">  python中元组、列表、字典等数据结构的使用</p></li><li><p><input disabled="" type="checkbox">  python中的正则表达式</p></li></ul></blockquote><h3 id="3｜小米应用商店APP排行榜爬取"><a href="#3｜小米应用商店APP排行榜爬取" class="headerlink" title="3｜小米应用商店APP排行榜爬取"></a>3｜小米应用商店APP排行榜爬取</h3><p><code>HTTP协议介绍｜requests库响应体｜re库的使用｜批量的图片存储</code></p><h4 id="1｜requests库响应体"><a href="#1｜requests库响应体" class="headerlink" title="1｜requests库响应体"></a>1｜requests库响应体</h4><blockquote><ul><li>文本形式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br>res = requests.get(<span class="hljs-string">&quot;https://app.mi.com/&quot;</span>)<br><span class="hljs-comment"># python中枚举的使用</span><br><span class="hljs-keyword">if</span> res.status_code == requests.codes.ok:<br>    print(<span class="hljs-string">&quot;请求成功&quot;</span>)<br><span class="hljs-comment"># 设置响应体内容格式</span><br>res.encoding = <span class="hljs-string">&quot;utf-8&quot;</span><br><span class="hljs-comment"># 以文本的形式访问响应体</span><br>html_data = res.text<br>print(html_data)<br></code></pre></td></tr></table></figure><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-12-032505.png" alt="image-20210312112505040"></p><ul><li>字节形式：获取响应体的主要场景应用在图片获取、文件获取、视频音频获取</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br>img_url = <span class="hljs-string">&quot;https://image.baidu.com/search/detail?ct=503316480&amp;z=0&amp;ipn=d&amp;word=tupian&amp;step_word=&amp;hs=0&amp;pn=0&amp;spn=0&amp;di=8360&amp;pi=0&amp;rn=1&amp;tn=baiduimagedetail&amp;is=0%2C0&amp;istype=0&amp;ie=utf-8&amp;oe=utf-8&amp;in=&amp;cl=2&amp;lm=-1&amp;st=undefined&amp;cs=3363295869%2C2467511306&amp;os=892371676%2C71334739&amp;simid=4203536407%2C592943110&amp;adpicid=0&amp;lpn=0&amp;ln=1584&amp;fr=&amp;fmq=1615519984102_R&amp;fm=&amp;ic=undefined&amp;s=undefined&amp;hd=undefined&amp;latest=undefined&amp;copyright=undefined&amp;se=&amp;sme=&amp;tab=0&amp;width=undefined&amp;height=undefined&amp;face=undefined&amp;ist=&amp;jit=&amp;cg=&amp;bdtype=0&amp;oriquery=&amp;objurl=https%3A%2F%2Fgimg2.baidu.com%2Fimage_search%2Fsrc%3Dhttp%3A%2F%2Fa0.att.hudong.com%2F30%2F29%2F01300000201438121627296084016.jpg%26refer%3Dhttp%3A%2F%2Fa0.att.hudong.com%26app%3D2002%26size%3Df9999%2C10000%26q%3Da80%26n%3D0%26g%3D0n%26fmt%3Djpeg%3Fsec%3D1618111986%26t%3D9ce41e27eeee1e538b7f6dd2f32a3687&amp;fromurl=ippr_z2C%24qAzdH3FAzdH3Fooo_z%26e3Bfhyvg8_z%26e3Bv54AzdH3F4AzdH3Fetjo_z%26e3Brir%3Fwt1%3Dmb9l9&amp;gsm=1&amp;rpstart=0&amp;rpnum=0&amp;islist=&amp;querylist=&amp;force=undefined&quot;</span><br>res2 = requests.get(img_url)<br><span class="hljs-keyword">if</span> res2.status_code == requests.codes.ok:<br>    print(<span class="hljs-string">&quot;OK&quot;</span>)<br>html_context = res2.content<br>print(html_context)<br></code></pre></td></tr></table></figure><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-12-032603.png" alt="image-20210312112603085"></p><ul><li>json序列化</li></ul><p>报错</p><ul><li>套接字</li></ul><p>&lt;urllib3.response.HTTPResponse object at 0x7f828c02ef10&gt;</p></blockquote><h4 id="2｜代码实现"><a href="#2｜代码实现" class="headerlink" title="2｜代码实现"></a>2｜代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> time<br><span class="hljs-comment"># 请求的网址</span><br>url = <span class="hljs-string">&#x27;https://app.mi.com/topList?page=1&#x27;</span><br><span class="hljs-comment"># 设置请求头</span><br>headers = &#123;<br>    <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 11_1_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82 Safari/537.36&#x27;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_img</span>(<span class="hljs-params">img_url,name</span>):</span><br>    img_res = requests.get(url = img_url,headers = headers)<br>    <span class="hljs-keyword">if</span> img_res.status_code == requests.codes.ok:<br>        data = img_res.content<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span> (<span class="hljs-string">&quot;./icons/&#123;name&#125;.png&quot;</span>.<span class="hljs-built_in">format</span>(name = name),<span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>            f.write(data)<br>        print(<span class="hljs-string">&quot;&#123;name&#125; - 图片存储完毕&quot;</span>.<span class="hljs-built_in">format</span>(name = name))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_item</span>(<span class="hljs-params">page</span>):</span><br>    url = <span class="hljs-string">&quot;https://app.mi.com/topList?page=&#123;page&#125;&quot;</span>.<span class="hljs-built_in">format</span>(page = page)<br>    res = requests.get(url=url,headers = headers)<br>    <span class="hljs-keyword">if</span> res.status_code == requests.codes.ok:<br>        html = res.text<br>        pattern = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;&lt;li&gt;&lt;a href=&quot;/details(.*?)&quot;&gt;&lt;img data-src=&quot;(.*?)&quot; src=&quot;(.*?)&quot; alt=&quot;(.*?)&quot; width=&quot;72&quot; height=&quot;72&quot;&gt;&lt;/a&gt;&lt;h5&gt;&lt;a href=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&lt;/h5&gt;&lt;p class=&quot;(.*?)&quot;&gt;&lt;a href=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#x27;</span>)<br>        iterms = pattern.findall(html)<br>        <span class="hljs-keyword">for</span> iterm <span class="hljs-keyword">in</span> iterms:<br>            save_img(iterm[<span class="hljs-number">1</span>],iterm[<span class="hljs-number">3</span>])<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>):<br>        print(<span class="hljs-string">&quot;正在爬取第&#123;page&#125;页&quot;</span>.<span class="hljs-built_in">format</span>(page = page))<br>        get_item(page)<br>        time.sleep(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><blockquote><p>这个就属于一个小型的python爬虫了，一步一步分析</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>爬虫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>408_高数</title>
    <link href="/2021/03/09/9_408-%E9%AB%98%E6%95%B0/"/>
    <url>/2021/03/09/9_408-%E9%AB%98%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="一、极限"><a href="#一、极限" class="headerlink" title="一、极限"></a>一、极限</h3><h4 id="1｜极限基础理解"><a href="#1｜极限基础理解" class="headerlink" title="1｜极限基础理解"></a>1｜极限基础理解</h4><h4 id="2｜极限的概念"><a href="#2｜极限的概念" class="headerlink" title="2｜极限的概念"></a>2｜极限的概念</h4><h5 id="1｜泰勒公式"><a href="#1｜泰勒公式" class="headerlink" title="1｜泰勒公式"></a>1｜泰勒公式</h5><blockquote><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-15-003430.png" alt="image-20210315083425612"></p></blockquote><h4 id="3｜极限计算技巧"><a href="#3｜极限计算技巧" class="headerlink" title="3｜极限计算技巧"></a>3｜极限计算技巧</h4><h4 id="4｜错题"><a href="#4｜错题" class="headerlink" title="4｜错题"></a>4｜错题</h4><h5 id="1｜1800"><a href="#1｜1800" class="headerlink" title="1｜1800"></a>1｜1800</h5><blockquote><p>P3</p></blockquote><ul><li><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-09-133427.png" alt="image-20210309213426821" style="zoom:50%;" /></li><li><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-09-133451.png" alt="image-20210309213450849" style="zoom:50%;" /></li><li><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-09-133505.png" alt="image-20210309213504928" style="zoom:50%;" /></li></ul>]]></content>
    
    
    <categories>
      
      <category>408</category>
      
      <category>高数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Introduction to Algorithms：Sorting And Finding</title>
    <link href="/2021/03/03/0_Introduction_to_Algorithms_Sorting/"/>
    <url>/2021/03/03/0_Introduction_to_Algorithms_Sorting/</url>
    
    <content type="html"><![CDATA[<h2 id="第一部分：基础知识"><a href="#第一部分：基础知识" class="headerlink" title="第一部分：基础知识"></a>第一部分：基础知识</h2><h2 id="第二部分-：排序与顺序统计量"><a href="#第二部分-：排序与顺序统计量" class="headerlink" title="第二部分 ：排序与顺序统计量"></a>第二部分 ：排序与顺序统计量</h2><h3 id="一、排序"><a href="#一、排序" class="headerlink" title="一、排序"></a>一、排序</h3><blockquote><p>四分之一的CPU时间都在执行同一类的计算：按照某种约定的次序，将给定的一组元素进行排序。</p></blockquote><h4 id="0｜two-pointers"><a href="#0｜two-pointers" class="headerlink" title="0｜two pointers"></a>0｜two pointers</h4><h4 id="1｜选择排序"><a href="#1｜选择排序" class="headerlink" title="1｜选择排序"></a>1｜选择排序</h4><p><code>直接选择｜胜者树｜堆</code></p><h5 id="1｜直接选择排序模版"><a href="#1｜直接选择排序模版" class="headerlink" title="1｜直接选择排序模版"></a>1｜直接选择排序模版</h5><blockquote><p>从V[i] ~V[n-1]中每轮次选取出最小的元素（或者是最小排序码<code>即数组的下标</code>）</p><p><code>Notice:</code>使用排序码也是一种编程技巧</p><p><code>KCN比较次数</code>：KCN = ${n(n-1)\over 2}$</p><p><code>RMN移动次数</code>：$RMN<del>max</del>= 3(n-1)$​</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SelectSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left;i&lt;right;i++)<br>  &#123;<br>   <span class="hljs-comment">//设置单指针，为了后续的交换使用</span><br>    <span class="hljs-keyword">int</span> k = i;<br>   <span class="hljs-comment">//从q[i]~q[right-1]中选取最小的元素，找出当前元素的最小排序码。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>;j&lt;right;j++)<span class="hljs-keyword">if</span>(q[j] &lt; q[k])k=j;<br>   <span class="hljs-comment">//边界条件，如果说存在排序码则进行交换</span><br>  <span class="hljs-keyword">if</span>(k!=i)swap(q[k],q[i]);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2｜锦标赛排序模版（使用胜者树实现）"><a href="#2｜锦标赛排序模版（使用胜者树实现）" class="headerlink" title="2｜锦标赛排序模版（使用胜者树实现）"></a>2｜锦标赛排序模版（使用胜者树实现）</h5><h5 id="3｜堆排序（使用堆结构和形成堆的算法实现）"><a href="#3｜堆排序（使用堆结构和形成堆的算法实现）" class="headerlink" title="3｜堆排序（使用堆结构和形成堆的算法实现）"></a>3｜堆排序（使用堆结构和形成堆的算法实现）</h5><h4 id="2｜插入排序"><a href="#2｜插入排序" class="headerlink" title="2｜插入排序"></a>2｜插入排序</h4><h4 id="3｜快速排序"><a href="#3｜快速排序" class="headerlink" title="3｜快速排序"></a>3｜快速排序</h4><h5 id="1｜快速排序模版"><a href="#1｜快速排序模版" class="headerlink" title="1｜快速排序模版"></a>1｜快速排序模版</h5><p><code>双指针｜边界条件判断｜时间复杂度｜TLE（超时）错误</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//此模版存在问题，做题可能会出现Time Limit Exceeded问题</span><br><span class="hljs-comment">//因为此模版式中定义起始位置为A[left],如果为递增或者是递减序列，则时间复杂度为O(n^2),而不是O（nlogn）</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Partition</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> A[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> temp = A[left];<br>  <span class="hljs-keyword">while</span>(left &lt; right)<br>  &#123;<br>    <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; A[right]&gt;temp)right--;<br>    A[left] = A[right];<br>    <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; A[left] &lt;= temp)left++;<br>    A[right] = A[left];<br>  &#125;<br>  A[left] = temp;<br>  <span class="hljs-keyword">return</span> left;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(left &lt; right)<br>  &#123;<br>    <span class="hljs-keyword">int</span> pos = Partition(A,left,right);<br>    quickSort(A,left,pos<span class="hljs-number">-1</span>);<br>    quickSort(A,pos+<span class="hljs-number">1</span>,right);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//测试通过的快速排序模版</span><br><span class="hljs-comment">//边界条件的判断比较多，所以建议在理解的基础上练熟悉模版</span><br><span class="hljs-comment">//很多算法的模版都是使用了双指针的方法进行操作的，所以双指针的使用是比较重要的，需要多加练习</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//边界条件判断</span><br>  <span class="hljs-keyword">if</span>(left &gt;= right)<span class="hljs-keyword">return</span>;<br><span class="hljs-comment">//随机取值</span><br>  <span class="hljs-keyword">int</span> tmp = q[(left+right)/<span class="hljs-number">2</span>];<br>  <span class="hljs-comment">//设置双指针，因为left和right是全局变量，所以要设置i和j为局部变量，通过i和j的变化和关系，实现程序。</span><br>  <span class="hljs-comment">//为什么要设置双指针：全局变量和局部变量的使用</span><br>  <span class="hljs-keyword">int</span> i = left<span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">int</span> j = right+<span class="hljs-number">1</span>;<br>  <span class="hljs-comment">//循环操作，直到i与j相遇，因为i与j相遇为一轮操作，</span><br>  <span class="hljs-keyword">while</span>(i &lt; j)<br>  &#123;<br>    <span class="hljs-comment">//与第9行的tmp取值有关</span><br>    <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(q[i] &lt; tmp);<br>    <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(q[j] &gt; tmp);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    此处双指针已经就位，需要补入进行的操作；进行交换、对比、取出等操作。</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span>(i &lt; j)swap(q[i],q[j]);<br>  &#125;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  1、循环结束，此时i == j的；</span><br><span class="hljs-comment">  2、后续递归处理的范围是[left,j]</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-comment">//递归处理前半段和后半段</span><br>  quickSort(q,left,j);<br>  quickSort(q,j+<span class="hljs-number">1</span>,right);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 需要进行测试，调试输出</li></ul><blockquote><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-09-021013.png" alt="image-20210309100704169" style="zoom:50%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">quickSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right,<span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(left == right)   <span class="hljs-keyword">return</span> q[left];<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">int</span> i=left<span class="hljs-number">-1</span>,j=right+<span class="hljs-number">1</span>,mid = q[left+right &gt;&gt; <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span>(i &lt; j)<br>        &#123;<br>            <span class="hljs-keyword">do</span>(i++);<span class="hljs-keyword">while</span>(q[i] &lt; mid);<br>            <span class="hljs-keyword">do</span>(j--);<span class="hljs-keyword">while</span>(q[j] &gt; mid);<br>            <span class="hljs-keyword">if</span>(i &lt; j)   swap(q[i],q[j]);<br>        &#125;<br>        quickSearch(q,left,j,k);<br>        quickSearch(q,j+<span class="hljs-number">1</span>,right,k);<br>        <br>        <span class="hljs-keyword">return</span> q[k<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n,k;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br>    <br>    <span class="hljs-built_in">cout</span> &lt;&lt; quickSearch(q,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>,k);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="4｜归并排序"><a href="#4｜归并排序" class="headerlink" title="4｜归并排序"></a>4｜归并排序</h4><h5 id="0｜算法思想"><a href="#0｜算法思想" class="headerlink" title="0｜算法思想"></a>0｜算法思想</h5><blockquote><p>基于分治的思想，将整体序列分为<code>logn</code>组数据，组内数据进行排序，排序后合并；</p><p>快排：n/2｜n/4｜n/8……</p><p>归并：……｜n/8｜n/4｜n/2｜=&gt;归并为n</p><p>所以递归调用的位置不同</p><p>归并排序需要开辟新的数组，空间换时间</p></blockquote><h5 id="1｜递归实现归并排序"><a href="#1｜递归实现归并排序" class="headerlink" title="1｜递归实现归并排序"></a>1｜递归实现归并排序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(left &gt;= right)<span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">//边界条件判断，如果只有一个元素则返回</span><br>  <span class="hljs-keyword">int</span> mid = left+right &gt;&gt; <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">//设置数组下标</span><br>  mergeSort(q,left,mid);<br>  <span class="hljs-comment">//递归调用划分左区间</span><br>  mergeSort(q,mid+<span class="hljs-number">1</span>,right);<br>  <span class="hljs-comment">//递归调用划分右区间</span><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  1、递归执行完成后，相当于是序列中的q[i]和q[j]两两对比，所以在执行16-17时已经有序了</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">//设置新开辟数组的下标</span><br>  <span class="hljs-keyword">int</span> i = left;<br>  <span class="hljs-comment">//设置双指针</span><br>  <span class="hljs-keyword">int</span> j = mid+<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right)<br>  <span class="hljs-comment">//执行循环，双指针移动</span><br>    <span class="hljs-keyword">if</span>(q[i] &lt;= q[j])tmp[k++] = q[i++];<br>  <span class="hljs-comment">//给新开辟数组赋值</span><br>  <span class="hljs-keyword">else</span> tmp[k++] = q[j++];<br>  <span class="hljs-comment">//给新开辟数组赋值</span><br>  <span class="hljs-keyword">while</span>(i&lt;= mid)tmp[k++] = q[i++];<br>  <span class="hljs-comment">//将未排序的数组导入到新开辟数组中</span><br>  <span class="hljs-keyword">while</span>(j&lt;=right)tmp[k++] = q[j++];<br>  <span class="hljs-comment">//同上</span><br>  <br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left,j=<span class="hljs-number">0</span>;i&lt;=right;i++,j++)q[i] = tmp[j];<br>  <span class="hljs-comment">//将tmp拷贝到q中，也可以直接使用c++的copy函数</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-09-094303.png" alt="image-20210309174303153" style="zoom:50%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> q[N],tmp[N];<br><span class="hljs-keyword">int</span> n;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">if</span>( left &gt;= right)  <span class="hljs-keyword">return</span>;<br> <span class="hljs-keyword">int</span> mid = (left+right) &gt;&gt; <span class="hljs-number">1</span>;<br> mergeSort(q,left,mid);<br> mergeSort(q,mid+<span class="hljs-number">1</span>,right);<br><br> <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>,i=left,j=mid+<span class="hljs-number">1</span>;<br> <span class="hljs-keyword">while</span>(i&lt;=mid &amp;&amp; j &lt;= right)<br> &#123;<br>     <span class="hljs-keyword">if</span>(q[i] &lt;= q[j]) tmp[k++] = q[i++];<br>     <span class="hljs-keyword">else</span>             tmp[k++] = q[j++];<br> &#125;<br> <span class="hljs-keyword">while</span>(i&lt;=mid)   tmp[k++] = q[i++];<br> <span class="hljs-keyword">while</span>(j&lt;=right) tmp[k++] = q[j++];<br><br> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left,j=<span class="hljs-number">0</span>;i&lt;=right;i++,j++)   q[i] = tmp[j];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br> mergeSort(q,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,q[i]);<br><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-12-090059.png" alt="image-20210312170059531" style="zoom:50%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> q[N],tmp[N];<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<br><span class="hljs-comment">//注意返回值res的类型</span><br><span class="hljs-function">LL <span class="hljs-title">Inversion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(left &gt;= right)   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> mid = (left+right) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-comment">//调用递归，递归叠加</span><br>    LL res = Inversion(q,left,mid) + Inversion(q,mid+<span class="hljs-number">1</span>,right);<br>    <span class="hljs-keyword">int</span> i=left,j=mid+<span class="hljs-number">1</span>,k=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;= mid &amp;&amp; j&lt;=right)<br>        <span class="hljs-keyword">if</span>(q[i] &lt;= q[j])    tmp[k++] = q[i++];<br>        <span class="hljs-keyword">else</span>                  <br>        &#123;<br>            res += mid-i+<span class="hljs-number">1</span>;<br>            tmp[k++] = q[j++];<br>        &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid)   tmp[k++] = q[i++];<br>    <span class="hljs-keyword">while</span>(j&lt;=right) tmp[k++] = q[j++];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left,j=<span class="hljs-number">0</span>;i&lt;=right;i++,j++)    q[i] = tmp[j];<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> n;<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br>  <span class="hljs-built_in">cout</span> &lt;&lt; Inversion(q,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="2｜非递归实现归并排序"><a href="#2｜非递归实现归并排序" class="headerlink" title="2｜非递归实现归并排序"></a>2｜非递归实现归并排序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br></code></pre></td></tr></table></figure><h4 id="5｜冒泡排序"><a href="#5｜冒泡排序" class="headerlink" title="5｜冒泡排序"></a>5｜冒泡排序</h4><h5 id="1｜冒泡排序的思想"><a href="#1｜冒泡排序的思想" class="headerlink" title="1｜冒泡排序的思想"></a>1｜冒泡排序的思想</h5><blockquote><p>冒泡排序时比较简单的排序方法</p><p>冒泡排序基于的关系:满足$A[i - 1] &lt;= A[i]$,保证相邻的元素间有序，但是不能保证整体有序，所以时间复杂度为$O(n^2)$。</p><p><code>1 3 5 8 2 6 7 9 </code></p><p>第一轮循环：<code>1 3 5 2 6 7 8 9</code>：因为i是一直前进的，没有回溯，所以就不能判断出<code>5 2 </code>的大小，所以要进行后续的循环。</p></blockquote><h5 id="2｜冒泡排序模版"><a href="#2｜冒泡排序模版" class="headerlink" title="2｜冒泡排序模版"></a>2｜冒泡排序模版</h5><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-comment">//冒泡排序模版：</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//整体的排序标志，首先假定整体尚未排序 </span><br>  <span class="hljs-keyword">bool</span> sorted = <span class="hljs-literal">false</span>;<br>  <span class="hljs-comment">//sort = false时，!sort = true，进入循环，经常使用的方法</span><br>  <span class="hljs-comment">//循环直到sorted == true时，退出循环;sorted == true的条件就是没有过交换，</span><br>    <span class="hljs-keyword">while</span>(!sorted)<br>    &#123;<br>  <span class="hljs-comment">//假设已经排好序，这样做可以减少循环次数，不需要蛮力遍历n-1趟；</span><br>      sorted = <span class="hljs-literal">true</span>;<br>  <span class="hljs-comment">//每一次循环都会保证至少有一个元素（每次排序中最大的元素）落位。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>;i&lt;n;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(a[i - <span class="hljs-number">1</span>] &gt; a[i])     <br>            &#123;<br>                swap(a[i<span class="hljs-number">-1</span>],a[i]);<br>                sorted = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>  <span class="hljs-comment">//通过n--，保证算法的有穷性</span><br>        n -- ;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 当n=5时，排序完成；但是需要多进行一趟循环，即n=4这趟循环完成后（多一趟判断是否有序）退出函数。这样就不需要进行7趟循环了。</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>&#125;;<br>    bubbleSort(<span class="hljs-built_in">array</span>,<span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">array</span>[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>有穷性和正确性分析：</p><p>正确性：经过K趟扫描交换之后，最大的前K个元素必然就位，对应14行注释</p><p>有穷性：经过K趟扫描交换之后，待求解问题的有效规模将缩减至n-k。每一次都有一个元素就位，所以经过n趟必然有序。</p></blockquote><h3 id="二、查找"><a href="#二、查找" class="headerlink" title="二、查找"></a>二、查找</h3><h4 id="1｜二分"><a href="#1｜二分" class="headerlink" title="1｜二分"></a>1｜二分</h4><blockquote><p><code>（基于数组的下标进行操作）</code></p><p>严格单调的话：不存在边界问题</p><p>有重复元素存在大量边界问题会造成死循环和查找不完全</p></blockquote><h5 id="1｜基于严格单调的有序数列"><a href="#1｜基于严格单调的有序数列" class="headerlink" title="1｜基于严格单调的有序数列"></a>1｜基于严格单调的有序数列</h5><h5 id="2｜基于不严格单调的有序序列（仍为有序序列）"><a href="#2｜基于不严格单调的有序序列（仍为有序序列）" class="headerlink" title="2｜基于不严格单调的有序序列（仍为有序序列）"></a>2｜基于不严格单调的有序序列（仍为有序序列）</h5><blockquote><p>思想：</p><p>1、找到序列中第一个大于等于x的元素的位置L，以及找到第一个大于x元素位置的R，找这两个位置都要基于二分进行查找，查找出来的区间就是[L,R），返回值为lower_bound和upper_bound</p><p>2、这样的边界主要是在代码中的判断条件进行控制。</p><p>3、基于序列<code>1 2 2 3 3 3 4 5 6</code></p><ul><li>left = 0 | right = 8 | mid = 4.    ====&gt; mid的左右两侧都有3</li><li>对left和right重新赋值if(a[mid] &lt; x)   left = mid+1;else right = mid;</li><li>left = 0｜right =4 ｜mid = 2     ====&gt;mid只有右侧有3</li><li>此时a[mid] &lt; x left = mid+1=3;</li><li>left = 3 ｜right =4｜mid = 3</li><li>此时a[mid] ==x ，则right = mid = 3,不满足循环条件while（left&lt;right)</li><li>此时如果循环条件为while（left &lt;= right)，则 mid = 3｜right = 3｜left = 3那么会发生死循环，为了</li></ul><p><code>例题：</code><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-08-144339.png" alt="image-20210308224339528"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lower_bound</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right,<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> mid;<br>    <span class="hljs-keyword">while</span>(left &lt; right)<br>    &#123;<br>        mid = left+right &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(a[mid] &gt;= x) right = mid;<br>        <span class="hljs-keyword">else</span> left = mid+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">upper_bound</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right,<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> mid;<br>    <span class="hljs-keyword">while</span>(left &lt; right)<br>    &#123;<br>        mid = left + right &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(a[mid] &gt; x)  right = mid;<br>        <span class="hljs-keyword">else</span> left = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n,x,que,LB,RB;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;x);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br><br>    <span class="hljs-keyword">while</span>(x--)<br>    &#123;   <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;que);<br>        LB = lower_bound(q,<span class="hljs-number">0</span>,n,que);<br>        RB = upper_bound(q,<span class="hljs-number">0</span>,n,que);<br>        <span class="hljs-keyword">if</span>(q[LB] != que)  LB = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(q[RB] != que )  RB = <span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; LB &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>&lt;&lt; RB &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="二、高精度计算"><a href="#二、高精度计算" class="headerlink" title="二、高精度计算"></a>二、高精度计算</h3><blockquote><p>利用结构体实现</p><p>利用vector实现</p><p>比较大小</p></blockquote><h4 id="1｜高精度加法"><a href="#1｜高精度加法" class="headerlink" title="1｜高精度加法"></a>1｜高精度加法</h4><h5 id="1｜存储方式"><a href="#1｜存储方式" class="headerlink" title="1｜存储方式"></a>1｜存储方式</h5><blockquote><p>进行运算的过程中从整数的低位到高位进行枚举，因为存在进位情况</p></blockquote><h5 id="2｜算法实现"><a href="#2｜算法实现" class="headerlink" title="2｜算法实现"></a>2｜算法实现</h5><blockquote><p>实现从低到高位存储，封装在函数内部</p><p>进位处理</p><p>位数多进行存储</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;a,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; c;<br><br>    <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;a.size() || i &lt; b.size();i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i &lt; a.size())    carry += a[i];<br>        <span class="hljs-keyword">if</span>(i &lt; b.size())    carry += b[i];<br>        c.push_back(carry % <span class="hljs-number">10</span>);<br>        carry /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>( carry ) c.push_back(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; a,b,c;<br>    <span class="hljs-built_in">string</span> add1,add2;<br>    getline(<span class="hljs-built_in">cin</span>,add1);<br>    getline(<span class="hljs-built_in">cin</span>,add2);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=add1.size()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) a.push_back(add1[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=add2.size()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) b.push_back(add2[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    c = add(a,b);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=c.size()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,c[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="2｜高精度减法"><a href="#2｜高精度减法" class="headerlink" title="2｜高精度减法"></a>2｜高精度减法</h4><h4 id="3｜高精度乘法"><a href="#3｜高精度乘法" class="headerlink" title="3｜高精度乘法"></a>3｜高精度乘法</h4><h4 id="4｜高精度除法"><a href="#4｜高精度除法" class="headerlink" title="4｜高精度除法"></a>4｜高精度除法</h4><h3 id="三｜前缀与差分"><a href="#三｜前缀与差分" class="headerlink" title="三｜前缀与差分"></a>三｜前缀与差分</h3><h4 id="1｜前缀和"><a href="#1｜前缀和" class="headerlink" title="1｜前缀和"></a>1｜前缀和</h4><blockquote><p>1、前缀和简单的理解就是数列中的前n项和，实现通过<code>递推关系实现</code>，主要把握递推关系</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//前缀和数组第i项 = 原数组的[0,i-1]+第i项的和</span><br>B[<span class="hljs-number">0</span>] = A [<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)B[i] = B[i - <span class="hljs-number">1</span>] + A[i];<br><span class="hljs-comment">//如果用原数组求的话，要定义一个sum的辅助变量。</span><br><span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>&#123;<br>  sum += A[i];<br>  B[i] = sum;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>2、C++中实现前缀和</p><ul><li><input disabled="" type="checkbox"> 需要一定的模版和类的基础，所以模版和类的语法还需要练习。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;numeric&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iterator&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>&#125;; <span class="hljs-comment">// 或 std::vector&lt;int&gt;v(10, 2);</span><br> <br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;The first 10 even numbers are: &quot;</span>;<br>    <span class="hljs-built_in">std</span>::partial_sum(v.begin(), v.end(), <br>                     <span class="hljs-built_in">std</span>::ostream_iterator&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>, <span class="hljs-string">&quot; &quot;</span>));<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br> <br>    <span class="hljs-built_in">std</span>::partial_sum(v.begin(), v.end(), v.begin(), <span class="hljs-built_in">std</span>::multiplies&lt;<span class="hljs-keyword">int</span>&gt;());<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;The first 10 powers of 2 are: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : v) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="2｜二维或者是多维的前缀和"><a href="#2｜二维或者是多维的前缀和" class="headerlink" title="2｜二维或者是多维的前缀和"></a>2｜二维或者是多维的前缀和</h4><blockquote><p>1、多维前缀和的普通求解方法几乎都是基于容斥原理，就是类似概率中去重的方法。</p><p><code>Notice：注意sum[1,0] 并不是等于sum[0,j]+sum[1,0]</code></p><p>2、求子矩阵的公式很重要的。</p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-14-030535.png" alt="image-20210314110535114" style="zoom:50%;" /><p>利用公式的时候要搞清楚边界条件</p><p>例题：</p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-14-065458.png" alt="image" style="zoom:40%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">103</span>][<span class="hljs-number">103</span>];<br><span class="hljs-keyword">int</span> b[<span class="hljs-number">103</span>][<span class="hljs-number">103</span>];  <span class="hljs-comment">// 前缀和数组，相当于上文的 sum[]</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> n, m;<br>  <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br><span class="hljs-comment">//求二维的前缀和，一般前缀和边界从1开始，到n与m结束</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>      <span class="hljs-built_in">cin</span> &gt;&gt; a[i][j];<br> <span class="hljs-comment">//二维前缀和公式</span><br>      b[i][j] =<br>          b[i][j - <span class="hljs-number">1</span>] + b[i - <span class="hljs-number">1</span>][j] - b[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + a[i][j];  <br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">int</span> l = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">while</span> (l &lt;= min(n, m)) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = l; i &lt;= n; i++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = l; j &lt;= m; j++) &#123;<br><span class="hljs-comment">//利用前缀和求子矩阵的和，因为正方形为1，所以子矩阵的和 == l*l</span><br>        <span class="hljs-keyword">if</span> (b[i][j] - b[i - l][j] - b[i][j - l] + b[i - l][j - l] == l * l) &#123;<br>          ans = max(ans, l);<br>        &#125;<br>      &#125;<br>    &#125;<br>    l++;<br>  &#125;<br><br>  <span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-built_in">endl</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="3｜基于DP求高维的前缀和"><a href="#3｜基于DP求高维的前缀和" class="headerlink" title="3｜基于DP求高维的前缀和"></a>3｜基于DP求高维的前缀和</h4><h4 id="4｜树上前缀和"><a href="#4｜树上前缀和" class="headerlink" title="4｜树上前缀和"></a>4｜树上前缀和</h4><h4 id="5｜差分"><a href="#5｜差分" class="headerlink" title="5｜差分"></a>5｜差分</h4><blockquote><p>灵活使用差分数组转前缀和，以及已知一个数组求差分数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//已知差分求前缀和</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)b[i] += b[i<span class="hljs-number">-1</span>];<br><span class="hljs-comment">// 已知前缀和求差分</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adjacent</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>  b[l] += c;<br>  b[r+<span class="hljs-number">1</span>] -= c;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)adjcent(i,i,a[i]);<span class="hljs-comment">//即得到a[N]的差分数组b[N]</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>它可以维护多次对序列的一个区间加上一个数，并在最后询问某一位的数或是多次询问某一位的数。注意修改操作一定要在查询操作之前。</p><ul><li><input disabled="" type="checkbox"> 但是为什么说减少了时间复杂度？（从$O(n) ===&gt; O(1)$)，不是还得先构造差分数组？</li></ul><p>$$a_i = b_1+b_2+……+b_i$$</p><p>$$b_1 = a_1$$</p><p>$b_2 = a_2 - a_1$</p><p>$b_3 = a_3 - a_2$</p><p>$a_1 = b_1$</p><p>$a_2 = b_1+b_2$</p><p>$a_3=b_1+b_2+b_3$</p><p>$a_4 = b_1+b_2+b_3+b_4$</p><p>实现了从1开始所有的 $a_i + c$ 的操作</p><p>$b_1=b_1+c$ </p><p>$ a_1 = a_1+c $</p><p>$a_2 = a_2+c$ </p><p>$a_3 = a_3 + c$</p><p>$a_4 = a_4 +c$</p><p>实现从5开始所有的$a_i-c$的操作，既从$a_5$开始所有的和原有数组$a_{i(&gt;=5)}$保持相同，即实现了[1,4]的区间内的书全部加c的操作</p><p>$b_5 = b_5 - c$</p><p>$a_5 = b_1+c+b_2+b_3+b_4+b_5-c$</p><p>$a_5 = a_5$</p></blockquote><blockquote><p>例题：</p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-14-084913.png" alt="image-20210314164913512" style="zoom:33%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> a[N],b[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adjacent</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    b[l] += c;<br>    b[r+<span class="hljs-number">1</span>] -=c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n,m;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br><span class="hljs-comment">//  初始化b[N],即初始化差分数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)   adjacent(i,i,a[i]);<br><span class="hljs-comment">//    printf(&quot;%d &quot;,b[0]); //b[0] == 0</span><br><span class="hljs-comment">//    for(int i=1;i&lt;=n;i++)   printf(&quot;%d &quot;,b[i]);   </span><br><span class="hljs-comment">//    cout &lt;&lt; endl;</span><br><span class="hljs-comment">//利用差分的关系来实现，在区间[l,r]内添加c的操作</span><br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> l,r,c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;c);<br>        adjacent(l,r,c);<br>    &#125;<br><span class="hljs-comment">//  操作完成之后的差分数组</span><br><span class="hljs-comment">//  for(int i=1;i&lt;=n;i++)   printf(&quot;%d &quot;,b[i]);</span><br><span class="hljs-comment">//  cout &lt;&lt; endl;</span><br><span class="hljs-comment">// 将差分数组转化为前缀和数组即所得a[N]</span><br><span class="hljs-comment">// 差分和前缀和可以相互转化，前缀和数组可以转化为差分，差分可以转化为前缀和</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)   b[i] += b[i<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,b[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="6｜树上差分"><a href="#6｜树上差分" class="headerlink" title="6｜树上差分"></a>6｜树上差分</h4><h5 id="1｜点差分"><a href="#1｜点差分" class="headerlink" title="1｜点差分"></a>1｜点差分</h5><h5 id="2｜边差分"><a href="#2｜边差分" class="headerlink" title="2｜边差分"></a>2｜边差分</h5><h3 id="四｜位运算"><a href="#四｜位运算" class="headerlink" title="四｜位运算"></a>四｜位运算</h3><h3 id="五｜离散化与区间合并"><a href="#五｜离散化与区间合并" class="headerlink" title="五｜离散化与区间合并"></a>五｜离散化与区间合并</h3><h2 id="第三部分：数据结构"><a href="#第三部分：数据结构" class="headerlink" title="第三部分：数据结构"></a>第三部分：数据结构</h2><blockquote><p>算法中较多使用的是数组模拟存储，在算法中或者是笔试（算法考试中）较少去考虑边界条件，但是要保证语法正确和输出正确。</p><p>实际工程中大多使用的是结构体形式模拟存储，在实际工程中要仔细考虑边界条件。</p><p>所以两种方法都要掌握，数组模拟主要就是解决关系问题，解决了关系问题其他操作都大致相同。</p></blockquote><h4 id="1｜单链表"><a href="#1｜单链表" class="headerlink" title="1｜单链表"></a>1｜单链表</h4><p><code>主要实现的功能：增｜删｜改｜查</code></p><blockquote><p>在算法中要保证运算的效率，所以链表使用静态链表来实现。</p></blockquote><blockquote><p>做题的时候要分清楚题目的要求与已知条件，已知条件就是区分是数组下标为k还是第k个插入的点，最好是画图理解。</p></blockquote><h5 id="1｜静态链表"><a href="#1｜静态链表" class="headerlink" title="1｜静态链表"></a>1｜静态链表</h5><blockquote><p>理解好链表中各个数据成员的</p></blockquote><blockquote><p>1、数据结构的组成元素以及关系</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> value[N],pointer[N];<br><span class="hljs-keyword">int</span> head;<br><span class="hljs-keyword">int</span> avil;<br></code></pre></td></tr></table></figure><p>静态链表主要采用双数组的形式，一个数组存储value，一个数组存储指针pointer，通过对应的关系来实现。</p><p>关系：</p><p>1｜$value[N]$和$pointer[N]$数组下标是相同的。</p><p>2｜链表之间的关系主要通过$pointer[N]$实现.</p><p>3｜在$pointer[N]$数组中，$pointer[index]$表示的是第$index$元素对应的下一个元素的下标index1，$index1 = pointer[index]$，$index2=pointer[index1]$，表示的是下标为index1的元素的下一个元素的下标；（有点绕，然是这个实现链表的关键，迭代实现）</p><ul><li><input disabled="" type="checkbox"> 需要完善</li></ul><p>4｜因为静态链表中如果要输出，必须要按照链表的顺序输出，那么就要有一个头指针，指向链表的头部。</p></blockquote><blockquote><p>2、静态链表初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  head = <span class="hljs-number">-1</span>;<br>  avil = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>3、头插法</p><p>表示向链表头插入一个数 x,链表的表头通过头指针标识。</p><p>z-&gt;y-&gt;x-&gt;NULL</p><p>head-&gt;z:标识z是链表的表头</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//在链表头部插入元素x</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Head</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>  value[avil] = x;<br>  pointer[avid] = avil;<br>  head = avil;<br>  avil++;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>4、尾插法</p></blockquote><blockquote><p>5、删除元素：也就是遍历链表的时候不输出</p><p>表示删除第 k个插入的数后面的数（当 k 为 0 时，表示删除头结点），当k=2的时候，删除x</p><p>链表为:z-&gt;y-&gt;x，所以删除第2个插入的数后面的数就是删除x；本质就是删除链表中的第三个元素；</p><ul><li><input disabled="" type="checkbox"> 这个是不是静态链表的弊端，不好实现按照直接删除第k个元素，或者是删除value = x的元素？</li></ul><table><thead><tr><th>数组下标</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>value[N]</td><td>x</td><td>y</td><td>z</td></tr><tr><td>pointer[N]</td><td>-1</td><td>1</td><td>2</td></tr><tr><td>将k-1的指针赋值给k</td><td>-1</td><td>-1</td><td>2</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//删除第k个插入的元素</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>  pointer[k] = pointer[pointer[k]];<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>6、插入元素</p><p>链表的插入主要要保证不断链。</p><p>表示在第 k个插入的数后面插入一个数 x（此操作中 k 均大于 0）</p><p>z-&gt;y-&gt;x-&gt;NULL，在第二个插入的数y后面插入x，链表变为z-&gt;y-&gt;x-&gt;x-&gt;NULL</p><table><thead><tr><th>Array</th><th>1</th><th>2</th><th>H:3</th><th>4</th><th></th></tr></thead><tbody><tr><td>value[N]</td><td>x</td><td>y</td><td>z</td><td>x</td><td></td></tr><tr><td>pointer[N]</td><td>-1</td><td>4</td><td>2</td><td>1</td><td></td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>  value[avil] = x;<br>  pointer[avil] = pointer[k];<br>  pointer[k] = avil;<br>  avil++;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>7、输出链表</p><p>输出链表主要是靠头指针的标识，从头指针开始遍历，找好对应关系，index = pointer[i]的数值是value[i]的下标</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">out_List</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">for</span>(i = head;i!=<span class="hljs-number">-1</span>;i = pointer[i]<span class="hljs-built_in">cout</span> &lt;&lt; value[i]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;)<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-19-023554.png" alt="image-20210319103554334" style="zoom:50%;" /><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-19-023615.png" alt="image-20210319103615345" style="zoom:50%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> elem[M],List[M];<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> head,avil;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head = <span class="hljs-number">0</span>;<br>    avil = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Head</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    elem[avil] = x;<br>    List[avil] = head;<br>    head = avil;<br>    avil ++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    elem[avil] = x;<br>    List[avil] = List[k];<br>    List[k] = avil;<br>    avil ++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    List[k] = List[List[k]];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Init();<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;m);<br>    <span class="hljs-keyword">char</span> op;<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> x,k;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; op;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;H&#x27;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>            Head(x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;I&#x27;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt;k &gt;&gt; x;<br>            Insert(k,x);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; k;<br>            <span class="hljs-keyword">if</span>(!k)  head = List[head];  <span class="hljs-comment">//这里不是很清楚，头结点的作用是什么？为了遍历？</span><br>            Delete(k);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i= head;i!=<span class="hljs-number">0</span>;i=List[i])     <span class="hljs-built_in">cout</span> &lt;&lt; elem[i]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure></blockquote><h4 id="2｜双链表"><a href="#2｜双链表" class="headerlink" title="2｜双链表"></a>2｜双链表</h4><h5 id="1｜双链表的性质"><a href="#1｜双链表的性质" class="headerlink" title="1｜双链表的性质"></a>1｜双链表的性质</h5><blockquote><p>双链表给定一个结点node，可以通过该结点的left和right指针可以找到node-1和node+1结点。</p></blockquote><h5 id="2｜双链表的构造"><a href="#2｜双链表的构造" class="headerlink" title="2｜双链表的构造"></a>2｜双链表的构造</h5><blockquote><p>通过三个数组进行构造，node结点的left[N]表示的是node-1的下标，right[N]表示的是node+1的下标。</p><p>边界判断：</p><ul><li>当链表中没有结点的时候</li><li>当链表中只有一个结点的时候</li></ul></blockquote><blockquote><p>1、双链表的数据成员：</p><p>1｜数据规模的大小为N</p><p>2｜存储链表中值的数组$value[N]$</p><p>3｜记录结点node的前后元素的指针数组$left[N]$    $right[N]$,数组中存储的值是对应node的数组的下标。</p><p>4｜avil表示下一个可用的数组空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e56</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> value[N],left[N],right[N],avil;<br></code></pre></td></tr></table></figure><p>使用数组的0号元素和1号元素记录数组的头结点和尾结点，在头结点和尾结点中插入链表的元素。</p><p>$Head -&gt; Tail$        //初始化链表</p><p>$Head -&gt; x -&gt; Tail$     //插入元素x</p><table><thead><tr><th>下标</th><th>0｜H</th><th>1｜T</th><th>2</th></tr></thead><tbody><tr><td>value</td><td>Head</td><td>Tail</td><td>x</td></tr><tr><td>left</td><td>1</td><td>2</td><td>0</td></tr><tr><td>right</td><td>2</td><td>0</td><td>1</td></tr><tr><td>avil</td><td>2</td><td>2</td><td>3</td></tr></tbody></table></blockquote><blockquote><p>2、初始化</p><p>1｜取0号元素为头结点、1号元素为尾结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  right[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>  left[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  avil = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>3、插入元素：左插入、右插入</p><p>$Head -&gt; x -&gt; Tail$     //插入元素x</p><blockquote><p>右插法<code>（在下标为k的点的右侧插入z）</code></p><p>avil = 3；</p><p>$Head -&gt;x -&gt; y -&gt; Tail$     //在y的右边插入z,此时不考虑边界条件,k = 2;</p><p>$Head -&gt;x -&gt; y -&gt; z -&gt; Tail$     </p><ul><li><input disabled="" type="checkbox"> 写一个debug工具，可以可视化的按照表格的形式输出各个值，类似excel的数据透视表的功能。</li></ul><table><thead><tr><th>下标</th><th>0｜H</th><th>1｜T</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>value</td><td>Head</td><td>Tail</td><td>x</td><td>y</td><td>z</td></tr><tr><td>left</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>right</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>avil</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>保证不断链<code>（链表操作的关键）</code></p><p>1｜要先设置插入元素的指针</p><p>2｜在断链后修改原有指针；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert_Right</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> z)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//先保证插入元素的指针，也就是z的指针的指向。</span><br>value[avil] = z;<br>  right[avil] = right[k];<br>  left[avil] = k;<br>  <span class="hljs-comment">//断链,注意断链的顺序，因为要使用right[k]的值，所以要先保证right[k]的值没有改变前调用。</span><br>  <span class="hljs-comment">//难点其实在于找前指针和后指针的表达式，找到之后保证不断链的前提下，修改链。</span><br>  left[right[k]] = avil;<br>  right[k] = avil;<br>  avil++;<br>&#125; <br></code></pre></td></tr></table></figure></blockquote><blockquote><p>左插法<code>（在下标为k的点的左侧插入z）</code></p><p>avil = 3；</p><p>$Head -&gt;x -&gt; z-&gt; y -&gt;Tail$     //在y的左边插入z,此时不考虑边界条件,k = 2;</p><p>保证不断链的条件和右插一样，但是指针不同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert_Left</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> z)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//先赋值</span><br>  value[avil] = z;<br>  left[avil] = left[k];<br>  right[avil] = k;<br>  <span class="hljs-comment">//断链</span><br>  right[left[k]] = avil;<br>  left[k] = avil;<br>  avil++;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></blockquote><blockquote><p>4、删除操作<code>删除第k个点</code></p><p>$Head -&gt;x -&gt; y -&gt; z -&gt; Tail$  //删除z，那么就是删除第3个点，数组的话是删除avil = k+1的点，因为插入是从avil = 2开始操作的；删除也存在保证不断链的要求。</p><p>也就是修改前一个元素的右链和后一个元素的左链；</p><p>前一个元素的右链：right[left[k+1]]</p><p>后一个元素的左链：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>  right[left[k+<span class="hljs-number">1</span>]] = right[k+<span class="hljs-number">1</span>];<br>  left[right[k+<span class="hljs-number">1</span>]] = left[k+<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>5、输出（从头结点开始输出，到尾结点结束）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Input_List</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i!=<span class="hljs-number">1</span>;i=left[i])<span class="hljs-built_in">cout</span> &lt;&lt; value[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><ul><li><input disabled="" type="checkbox"> 未完成</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> value[N],_left[N],_right[N];<br><span class="hljs-keyword">int</span> M,avil;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    _right[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    _left[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    avil = <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">//实现头插</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Head</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    value[avil] = x;<br>    _right[avil] = _right[<span class="hljs-number">0</span>];<br>    _left[avil] = <span class="hljs-number">0</span>;<br>    _left[_right[<span class="hljs-number">0</span>]] = avil;<br>    _right[<span class="hljs-number">0</span>] = avil;<br>    avil++;<br>&#125;<br><span class="hljs-comment">//实现尾插</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Tail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    value[avil] = x;<br>    _right[avil] = <span class="hljs-number">1</span>;<br>    _left[avil] = _left[<span class="hljs-number">1</span>];<br>    _right[_left[<span class="hljs-number">1</span>]] = avil;<br>    _left[<span class="hljs-number">1</span>] = avil;<br>    avil++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Inster_Left</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    value[avil] = x;<br>    _left[avil] = _right[k];<br>    _right[avil] = k;<br>    _left[_right[k]] = avil;<br>    _right[k] = avil;<br>    avil ++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert_Right</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    value[avil] = x;<br>    _right[avil] = _left[k];<br>    _left[avil] = k;<br>    _left[_right[k]] = avil;<br>    _right[k] = avil;<br>    avil++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    _left[_right[k]] = _left[k];<br>    _right[_left[k]] = _right[k];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output_List</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i!= <span class="hljs-number">1</span>;i = _right[i])   <span class="hljs-built_in">cout</span> &lt;&lt; value[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;M);<br>    Init();<br>    <span class="hljs-built_in">string</span> op;<br>    <span class="hljs-keyword">int</span> k,x;<br>    <span class="hljs-keyword">while</span>(M--)<br>    &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; op;<br>        <span class="hljs-keyword">if</span>( op == <span class="hljs-string">&quot;R&quot;</span>)  <br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>            Head(x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( op == <span class="hljs-string">&quot;L&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>            Tail(x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( op == <span class="hljs-string">&quot;D&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; k;<br>            Delete(k+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;IL&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; k &gt;&gt; x;<br>            Inster_Left(k,x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( op == <span class="hljs-string">&quot;IR&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; k &gt;&gt; x;<br>            Insert_Right(k,x);<br>        &#125;<br>    &#125;<br>    output_List();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3｜栈"><a href="#3｜栈" class="headerlink" title="3｜栈"></a>3｜栈</h4><h5 id="1｜栈的性质"><a href="#1｜栈的性质" class="headerlink" title="1｜栈的性质"></a>1｜栈的性质</h5><blockquote><p>1、先进后出，所以适用于记录什么样的数据？</p><p>1｜优先处理新加入的数据</p><p>2、栈的操作：初始化、进栈、出栈、判空、判满</p></blockquote><h5 id="2｜栈的实现"><a href="#2｜栈的实现" class="headerlink" title="2｜栈的实现"></a>2｜栈的实现</h5><blockquote><p>1、栈的数据组成：栈分为两种，一种是链栈（利用指针实现），另一种是顺序栈（利用数组实现）</p><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-21-011946.jpg" alt="img"></p><p>在算法实现中，大多是利用顺序栈来实现，一般在算法做题中，栈是作为一种中间的工具实现一些功能。</p><ul><li><input disabled="" type="checkbox"> 所以注意栈用于哪些场景，要总结。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<span class="hljs-comment">//栈内最大的容量为1e6</span><br><span class="hljs-keyword">int</span> Stack[N];<span class="hljs-comment">//顺序栈</span><br><span class="hljs-keyword">int</span> top;<span class="hljs-comment">//栈顶指针，因为栈先进栈的指针并不能进行操作，只能操作后进栈的指针，所以只需要栈顶指针即可。</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>2、栈的初始化（先不考虑边界条件）</p><p>初始化只要对top指针进行初始化，初始化方式有两种<code>top = -1</code>或是<code>top = 0</code>，会导致判空与判满的条件不同。</p><p><code>top = -1 </code>:那么栈的元素与数组下标一致，</p><p><code>top = 0</code>：栈的元素的顺序与插入的顺序一致</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  top = <span class="hljs-number">0</span>;<span class="hljs-comment">//个人喜好</span><br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>3、进栈(未考虑边界条件)</p><p>top相当于栈顶的一个指针，标记栈顶，所以进栈和出栈都是对top进行操作；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//未优化代码</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>  top ++;<span class="hljs-comment">//top标记栈顶，所以先为插入元素找到下一个插入的空间，也就是进行top++；</span><br>  Stack[top] = x;<span class="hljs-comment">//找到空间后，对空间进行赋值,所以就是先++，后赋值</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//优化代码</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>  Stack[++top] = x;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>4、出栈（未考虑边界条件）</p><p>top指向栈顶，要出栈只需要挪动栈顶指针即可，如果要输出栈顶元素，要先输出后挪动top指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//优化代码</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Pop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> x;<br>  x = Stack[top --];<span class="hljs-comment">//先赋值，再--</span><br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>5、获取栈顶元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getTop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> Stack[top];<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>6、判空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Empty</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> (top == <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>7、判满</p><p>一半的算法题中貌似不会判满</p></blockquote><h5 id="3｜栈的应用"><a href="#3｜栈的应用" class="headerlink" title="3｜栈的应用"></a>3｜栈的应用</h5><blockquote><p>一般来说很多问题，栈都作为辅助的工具，而不能够直接解题。</p><p>将栈作为存储的工具，然后根据栈的性质，输出结果</p></blockquote><blockquote><p>括号匹配</p><p>左括号与之相邻的最近的右括号匹配</p></blockquote><blockquote><p>栈思想的应用：</p><p>利用栈的出栈和入栈思想，这个题是对出栈入栈的条件进行了限制，遇到’(‘相当于入栈，遇到’)’，相当于出栈；因为要去掉最外层的（），所以栈底保留一个元素，也就是要求top &gt; 1；</p><p><a href="https://leetcode-cn.com/problems/remove-outermost-parentheses/">https://leetcode-cn.com/problems/remove-outermost-parentheses/</a></p><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-21-083054.png" alt="image-20210321163054142"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">removeOuterParentheses</span><span class="hljs-params">(<span class="hljs-built_in">string</span> S)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> top = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">string</span> ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;S.length();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(S[i] == <span class="hljs-string">&#x27;(&#x27;</span>) <br>            &#123;<br>                top ++;<br>                <span class="hljs-keyword">if</span>(top &gt;<span class="hljs-number">1</span>)    ans += <span class="hljs-string">&#x27;(&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(top &gt; <span class="hljs-number">1</span>)     ans += <span class="hljs-string">&#x27;)&#x27;</span>;<br>                top --;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></blockquote><h4 id="4｜队列"><a href="#4｜队列" class="headerlink" title="4｜队列"></a>4｜队列</h4><h5 id="1｜队列的性质"><a href="#1｜队列的性质" class="headerlink" title="1｜队列的性质"></a>1｜队列的性质</h5><blockquote><p> 只允许一端输入，另一端输出，允许输出是队头，允许输入是队尾，先进先出（FIFO）。</p></blockquote><h5 id="2｜队列实现（数组）"><a href="#2｜队列实现（数组）" class="headerlink" title="2｜队列实现（数组）"></a>2｜队列实现（数组）</h5><p><code>未进行边界条件判断</code></p><blockquote><p>1、数据成员</p><p>因为输入和输出操作的是不同的位置，所以需要双指针来进行操作，设置队头指针为front，队尾指针为rear</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxSize <span class="hljs-number">1e6</span>+!<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> SeqQueue[maxSize];<br><span class="hljs-keyword">int</span> front,rear;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>2、初始化队列</p><p>初始化时队列中没有元素，所以front = rear = 0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  front = rear = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>3、插入元素(入队)</p><p>插入元素只需操作队尾指针，指针rear的含义是下一个可以插入的位置，并不是指向真正的队尾。所以应该是rear ++ ，而不是++rear；这个操作和front = rear = 0 的初始化方式有关。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>  SeqQueue(rear++) = x;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>4、出队</p><p>出队因为只能在队头出队，所以只需要操作队头指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  front ++ ;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>5、判空</p><p>判空的条件就是当队头和队尾相同的时候</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Empty</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> (front == rear);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>6、取出队头元素</p><p>操作front指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getFront</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> SeqQueue[front];<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote> <img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-22-001421.png" alt="image-20210322081421032" style="zoom:50%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxSize = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> M,que[maxSize];<br><span class="hljs-built_in">string</span> op;<br><span class="hljs-keyword">int</span> x,front,rear;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    front = rear = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    que[rear++] = x;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    front ++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">query</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cout</span> &lt;&lt;  que[front] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(front == rear)   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">else</span>                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;M);<br>    Init();<br>    <span class="hljs-keyword">while</span>(M--)<br>    &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; op;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;push&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>            push(x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;pop&quot;</span>)    pop();<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;query&quot;</span>)  query();<br>        <span class="hljs-keyword">else</span>                    empty();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Sorting</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法导论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP/IP-简介</title>
    <link href="/2021/03/01/9_TCP-IP/"/>
    <url>/2021/03/01/9_TCP-IP/</url>
    
    <content type="html"><![CDATA[<h3 id="一、TCP-IP-简介"><a href="#一、TCP-IP-简介" class="headerlink" title="一、TCP IP 简介"></a>一、TCP IP 简介</h3><p><code>实验环境：Linux-Ubuntu20.04｜Mac</code></p><h4 id="1｜应用模型"><a href="#1｜应用模型" class="headerlink" title="1｜应用模型"></a>1｜应用模型</h4><h4 id="2｜知识点"><a href="#2｜知识点" class="headerlink" title="2｜知识点"></a>2｜知识点</h4><h5 id="1｜IP地址"><a href="#1｜IP地址" class="headerlink" title="1｜IP地址"></a>1｜IP地址</h5><h5 id="2｜域名"><a href="#2｜域名" class="headerlink" title="2｜域名"></a>2｜域名</h5><h5 id="3｜MAC地址"><a href="#3｜MAC地址" class="headerlink" title="3｜MAC地址"></a>3｜MAC地址</h5><h5 id="4｜端口号"><a href="#4｜端口号" class="headerlink" title="4｜端口号"></a>4｜端口号</h5><blockquote><p>端口号作用：</p></blockquote><blockquote><p>常用端口号：</p></blockquote><blockquote><p>端口号实际应用：</p></blockquote><h5 id="5｜封装与分用"><a href="#5｜封装与分用" class="headerlink" title="5｜封装与分用"></a>5｜封装与分用</h5><h5 id="6｜Linux网络相关常用命令"><a href="#6｜Linux网络相关常用命令" class="headerlink" title="6｜Linux网络相关常用命令"></a>6｜Linux网络相关常用命令</h5><p><code>借助netstat命令行工具</code></p><h3 id="二、链路层"><a href="#二、链路层" class="headerlink" title="二、链路层"></a>二、链路层</h3><h4 id="1｜链路层简介"><a href="#1｜链路层简介" class="headerlink" title="1｜链路层简介"></a>1｜链路层简介</h4><p><code>知识点：控制帧的传输、以太网、PPP、SLIP与PPP、MTU</code></p><blockquote><p>以太网<code>CSMA/CD</code></p></blockquote><blockquote><p>MTU</p></blockquote><blockquote><p>PPP</p></blockquote><blockquote><p>SLIP</p></blockquote><h4 id="2｜链路层实现功能以及链路层协议"><a href="#2｜链路层实现功能以及链路层协议" class="headerlink" title="2｜链路层实现功能以及链路层协议"></a>2｜链路层实现功能以及链路层协议</h4><h5 id="1｜差错控制"><a href="#1｜差错控制" class="headerlink" title="1｜差错控制"></a>1｜差错控制</h5><h5 id="2｜反馈重发"><a href="#2｜反馈重发" class="headerlink" title="2｜反馈重发"></a>2｜反馈重发</h5><h5 id="3｜计时器"><a href="#3｜计时器" class="headerlink" title="3｜计时器"></a>3｜计时器</h5><h5 id="4｜序号"><a href="#4｜序号" class="headerlink" title="4｜序号"></a>4｜序号</h5><h5 id="5｜流量控制"><a href="#5｜流量控制" class="headerlink" title="5｜流量控制"></a>5｜流量控制</h5><h3 id="三、网络层"><a href="#三、网络层" class="headerlink" title="三、网络层"></a>三、网络层</h3><h4 id="1｜IP数据报"><a href="#1｜IP数据报" class="headerlink" title="1｜IP数据报"></a>1｜IP数据报</h4><h4 id="2｜地址划分"><a href="#2｜地址划分" class="headerlink" title="2｜地址划分"></a>2｜地址划分</h4><h4 id="3｜子网划分"><a href="#3｜子网划分" class="headerlink" title="3｜子网划分"></a>3｜子网划分</h4><h5 id="1｜子网掩码：netmask："><a href="#1｜子网掩码：netmask：" class="headerlink" title="1｜子网掩码：netmask："></a>1｜子网掩码：netmask：</h5><h4 id="4｜IP路由选择"><a href="#4｜IP路由选择" class="headerlink" title="4｜IP路由选择"></a>4｜IP路由选择</h4><h4 id="5｜NAT技术"><a href="#5｜NAT技术" class="headerlink" title="5｜NAT技术"></a>5｜NAT技术</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ifconfig eth0<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">en0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=400&lt;CHANNEL_IO&gt;<br>ether 38:f9:d3:93:33:9f<br>inet 192.168.3.12 netmask 0xffffff00 broadcast 192.168.3.255<br>media: autoselect<br>status: active<br></code></pre></td></tr></table></figure><blockquote><p>内网IP(192.168.X.X和172.16.X.X)          <code>私网地址</code></p><p>内网与外网的区别？</p><p>广播地址怎么用？</p></blockquote><h4 id="6｜IP的发展及未来"><a href="#6｜IP的发展及未来" class="headerlink" title="6｜IP的发展及未来"></a>6｜IP的发展及未来</h4><blockquote><p>IPV6</p></blockquote><h4 id="7｜网络层协议"><a href="#7｜网络层协议" class="headerlink" title="7｜网络层协议"></a>7｜网络层协议</h4><p><code>ARP|RARP|ICMP|ping|traceroute|IGMP</code></p><h5 id="1｜ARP协议"><a href="#1｜ARP协议" class="headerlink" title="1｜ARP协议"></a>1｜ARP协议</h5><blockquote><p>协议工作原理：</p></blockquote><blockquote><p>ARP代理</p></blockquote><blockquote><p>ARP欺骗</p></blockquote><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">arp<br><br></code></pre></td></tr></table></figure></blockquote><h5 id="2｜icmp协议"><a href="#2｜icmp协议" class="headerlink" title="2｜icmp协议"></a>2｜icmp协议</h5><blockquote><p>协议的工作原理：</p></blockquote><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ping<br></code></pre></td></tr></table></figure><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-17-002443.png" alt="image-20210317082443464" style="zoom:50%;" /><p>ping是什么原理？</p></blockquote><h4 id="7｜实践"><a href="#7｜实践" class="headerlink" title="7｜实践"></a>7｜实践</h4><h5 id="1｜ifconfig命令详解"><a href="#1｜ifconfig命令详解" class="headerlink" title="1｜ifconfig命令详解"></a>1｜ifconfig命令详解</h5><ul><li><input disabled="" type="checkbox"> 搞清楚每一个的含义是什么，分别在网络层有什么用</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs bash">lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384<br>options=1203&lt;RXCSUM,TXCSUM,TXSTATUS,SW_TIMESTAMP&gt;<br>inet 127.0.0.1 netmask 0xff000000<br>inet6 ::1 prefixlen 128<br>inet6 fe80::1%lo0 prefixlen 64 scopeid 0x1<br>nd6 options=201&lt;PERFORMNUD,DAD&gt;<br>gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280<br>stf0: flags=0&lt;&gt; mtu 1280<br>en6: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500<br>ether ac:de:48:00:11:22<br>inet6 fe80::aede:48ff:fe00:1122%en6 prefixlen 64 scopeid 0x4<br>nd6 options=201&lt;PERFORMNUD,DAD&gt;<br>media: autoselect (100baseTX &lt;full-duplex&gt;)<br>status: active<br>ap1: flags=8802&lt;BROADCAST,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=400&lt;CHANNEL_IO&gt;<br>ether 3a:f9:d3:93:33:9f<br>media: autoselect<br>status: inactive<br>en0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=400&lt;CHANNEL_IO&gt;<br>ether 38:f9:d3:93:33:9f<br>inet 192.168.3.12 netmask 0xffffff00 broadcast 192.168.3.255<br>media: autoselect<br>status: active<br>awdl0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=400&lt;CHANNEL_IO&gt;<br>ether 3e:73:6e:0b:bb:ac<br>inet6 fe80::3c73:6eff:fe0b:bbac%awdl0 prefixlen 64 scopeid 0x7<br>nd6 options=201&lt;PERFORMNUD,DAD&gt;<br>media: autoselect<br>status: active<br>llw0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=400&lt;CHANNEL_IO&gt;<br>ether 3e:73:6e:0b:bb:ac<br>inet6 fe80::3c73:6eff:fe0b:bbac%llw0 prefixlen 64 scopeid 0x8<br>nd6 options=201&lt;PERFORMNUD,DAD&gt;<br>media: autoselect<br>status: active<br>en3: flags=8963&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=460&lt;TSO4,TSO6,CHANNEL_IO&gt;<br>ether 82:23:4a:a0:88:05<br>media: autoselect &lt;full-duplex&gt;<br>status: inactive<br>en4: flags=8963&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=460&lt;TSO4,TSO6,CHANNEL_IO&gt;<br>ether 82:23:4a:a0:88:04<br>media: autoselect &lt;full-duplex&gt;<br>status: inactive<br>en2: flags=8963&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=460&lt;TSO4,TSO6,CHANNEL_IO&gt;<br>ether 82:23:4a:a0:88:00<br>media: autoselect &lt;full-duplex&gt;<br>status: inactive<br>en1: flags=8963&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=460&lt;TSO4,TSO6,CHANNEL_IO&gt;<br>ether 82:23:4a:a0:88:01<br>media: autoselect &lt;full-duplex&gt;<br>status: inactive<br>en5: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=6467&lt;RXCSUM,TXCSUM,VLAN_MTU,TSO4,TSO6,CHANNEL_IO,PARTIAL_CSUM,ZEROINVERT_CSUM&gt;<br>ether 00:e0:4c:68:01:5a<br>nd6 options=201&lt;PERFORMNUD,DAD&gt;<br>media: autoselect (none)<br>status: inactive<br>bridge0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=63&lt;RXCSUM,TXCSUM,TSO4,TSO6&gt;<br>ether 82:23:4a:a0:88:01<br>Configuration:<br>id 0:0:0:0:0:0 priority 0 hellotime 0 fwddelay 0<br>maxage 0 holdcnt 0 proto stp maxaddr 100 timeout 1200<br>root id 0:0:0:0:0:0 priority 0 ifcost 0 port 0<br>ipfilter disabled flags 0x0<br>member: en1 flags=3&lt;LEARNING,DISCOVER&gt;<br>        ifmaxaddr 0 port 12 priority 0 path cost 0<br>member: en2 flags=3&lt;LEARNING,DISCOVER&gt;<br>        ifmaxaddr 0 port 11 priority 0 path cost 0<br>member: en3 flags=3&lt;LEARNING,DISCOVER&gt;<br>        ifmaxaddr 0 port 9 priority 0 path cost 0<br>member: en4 flags=3&lt;LEARNING,DISCOVER&gt;<br>        ifmaxaddr 0 port 10 priority 0 path cost 0<br>nd6 options=201&lt;PERFORMNUD,DAD&gt;<br>media: &lt;unknown <span class="hljs-built_in">type</span>&gt;<br>status: inactive<br>utun0: flags=8051&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu 1380<br>inet6 fe80::cdc3:569c:b8e5:27cd%utun0 prefixlen 64 scopeid 0xf<br>nd6 options=201&lt;PERFORMNUD,DAD&gt;<br>utun1: flags=8051&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu 2000<br>inet6 fe80::b3d5:d5dc:d9d:f593%utun1 prefixlen 64 scopeid 0x10<br>nd6 options=201&lt;PERFORMNUD,DAD&gt;<br></code></pre></td></tr></table></figure><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br></code></pre></td></tr></table></figure></blockquote><h5 id="2｜tcpdump抓包"><a href="#2｜tcpdump抓包" class="headerlink" title="2｜tcpdump抓包"></a>2｜tcpdump抓包</h5><blockquote><p>IP数据报(20B)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo tcpdump -nx -c 2<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tcpdump: verbose output suppressed, use -v[v]... <span class="hljs-keyword">for</span> full protocol decode<br>listening on en0, link-type EN10MB (Ethernet), snapshot length 262144 bytes<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">10:25:09.140340 <br>IP 120.232.214.205.22004 &gt; 192.168.3.12.53969: Flags [.], <br>ack 885193681, win 21, length 0<br>0x0000:  4504 0028 5eb6 4000 3606 d2ab 78e8 d6cd<br>0x0010:  c0a8 030c 55f4 d2d1 b856 3706 34c2 fbd1<br>0x0020:  5010 0015 539e 0000 0000 0000 0000<br></code></pre></td></tr></table></figure><blockquote><p>首部分析：</p><p>版本协议：0x4</p><p>首部长度：0x5</p><p>服务类型：04</p><p>总长度：0028</p><p>标识：5eb6</p><p>标志与片偏移：4000</p><p>生存时间：36</p><p>协议：06</p><p>首部校验和：d2ab</p><p><code> 源地址</code>78e8 d6cd</p><p>转化为二进制：01111000｜11101000｜11010110｜11001101</p><p>转化为点分十进制：</p><p><code>目的地址</code>c0a8 030c </p><p>转换为二进制：11000000｜10101000｜00000011｜00001100</p><p>转化为点分十进制：192.168.3.12<code>与192.168.3.12.53969可以对应</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">10:25:09.140420 <br>IP 192.168.3.12.53969 &gt; 120.232.214.205.22004: Flags [.], <br>ack 1, win 4096, length 0<br>0x0000:  4500 0028 0000 4000 4006 2766 c0a8 030c<br>0x0010:  78e8 d6cd d2d1 55f4 34c2 fbd1 b856 3707<br>0x0020:  5010 1000 43b2 0000<br></code></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 怎么样了解这些输出是什么</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">traceroute www.baidu.com<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"> 1  192.168.3.1 (192.168.3.1)  3.086 ms  2.898 ms  1.976 ms<br> 2  192.168.1.1 (192.168.1.1)  2.303 ms  2.396 ms  3.538 ms<br> 3  10.139.0.1 (10.139.0.1)  9.640 ms  8.780 ms  7.852 ms<br> 4  111.56.2.185 (111.56.2.185)  10.049 ms  10.867 ms  9.565 ms<br> 5  221.183.58.205 (221.183.58.205)  12.810 ms<br>    221.183.75.49 (221.183.75.49)  13.646 ms<br>    221.183.58.205 (221.183.58.205)  15.570 ms<br> 6  221.183.37.193 (221.183.37.193)  25.510 ms<br>    221.183.40.21 (221.183.40.21)  29.624 ms<br>    221.183.37.193 (221.183.37.193)  24.770 ms<br> 7  * * 221.183.49.130 (221.183.49.130)  33.833 ms<br> 8  39.156.27.5 (39.156.27.5)  23.339 ms * *<br> 9  39.156.67.73 (39.156.67.73)  35.292 ms<br>    39.156.27.1 (39.156.27.1)  33.018 ms<br>    39.156.67.53 (39.156.67.53)  28.759 ms<br>10  * * 39.156.67.81 (39.156.67.81)  38.491 ms<br>11  * * *<br></code></pre></td></tr></table></figure><blockquote><p>解析：</p><p>每一个序号代表的是一跳，每跳表示一个网关</p><ul><li><input disabled="" type="checkbox"> 网关没有理解是什么东西？就代表的是路由器？</li></ul><p>每一跳后面的三个时间：代表的是探测数据包向每个网关发送三个数据包后，网关响应后的返回时间</p><p>使用的是华为的路由器，所以192.168.3.1表示的是华为路由器的地址，</p><p>192.168.1.1</p><p><code>192.168.1.1 IP地址是大多数无线路由器或ADSL调制解调器的默认网关。路由器可以使用多个IP主地址</code></p></blockquote><h5 id="3｜netstat-使用"><a href="#3｜netstat-使用" class="headerlink" title="3｜netstat 使用"></a>3｜netstat 使用</h5><blockquote><p>1、使用netstat查询路由信息</p><p>Destination:</p><p>Gateway:</p><p>Flags:</p><p>Netif:</p><p>Expire:</p></blockquote><h5 id="4｜traceroute命令"><a href="#4｜traceroute命令" class="headerlink" title="4｜traceroute命令"></a>4｜traceroute命令</h5><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><h4 id="TCP服务"><a href="#TCP服务" class="headerlink" title="TCP服务"></a>TCP服务</h4><p><code>面向连接服务｜可靠数据传输服务｜拥塞控制机制</code></p><blockquote><p>面向连接的服务：</p><p>1、应用层数据报文开始流动之前，TCP让客户和服务器下相互交换<code>运输层控制信息</code>，即所谓经典的三次握手和四次挥手。握手是为了在两个进程的套接字之间建立TCP连接。</p><p>可靠的数据传输：</p><p>1、无差错</p><p>2、按照适当顺序交付所有发送的数据</p><p>3、保证传输的字节没有丢失或者是冗余</p><p>拥塞控制</p></blockquote><blockquote><p>TCP安全</p><p>为了保证隐私和其他的安全问题，可以使用TCP加强版即SSL（安全套接字层），除了TCP的经典服务以外，利用SSL可以提供关键的进程到进程的安全性服务。</p><p>SSL已经有高度优化的库和类，调用SSL API即可实现加密等服务。</p><p>当一个应用使用SSL时，发送进程想SSL的套接字传递明文数据，在主机中的SSL则加密该数据并将加密的数据传递给TCP套接字。</p><p><code>char ==&gt; SSL(API) ==&gt; TCP SOCKET</code></p></blockquote><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><blockquote><p>UDP不提供不必要的轻量级运输协议，<code>UDP是无连接的</code>而且<code>UDP提供不可靠的数据传输服务</code>，同时也没有拥塞控制机制。</p></blockquote><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p><code>2021-3-18</code>                                                            </p><p><code>DNS|FTP|Telnet|SMTP|HTTP|RIP|NFS</code></p><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-18-014102.png" alt="image-20210318094059472"></p><h4 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h4><blockquote><p>应用层协议定义了以下的几样东西：</p><p>1、交换的报文类型：如请求报文和响应报文</p><p>2、各类报文类型的语法：报文中各个字段以及各个字段如何描述</p><p>3、字段的语义：每个字段中包含的信息的含义</p><p>4、一个进程何时以及如何发送报文，对报文进行响应的规则</p><p>应用层协议有的是公开的，有的是专用的，如果你想构建一个web浏览器的应用程序，你就要在参照HTTP RFC规则，这样你写出来的浏览器可以访问遵从该文档标准的web服务器，并获取相应的web页面。</p><ul><li><input disabled="" type="checkbox"> 尝试读取HTTP RFC规则</li><li><input disabled="" type="checkbox"> 所以这就是学会如何使用轮子</li></ul></blockquote><blockquote><p>区分网络应用和应用层协议：</p><p>应用层协议只是网络应用的一部分，但是是很重要的一部分。网络应用包含多个功能，参照浏览器的功能，不仅仅是能够访问web页面一个功能。</p></blockquote><h4 id="Web和HTTP"><a href="#Web和HTTP" class="headerlink" title="Web和HTTP"></a>Web和HTTP</h4><h5 id="1｜HTTP概况"><a href="#1｜HTTP概况" class="headerlink" title="1｜HTTP概况"></a>1｜HTTP概况</h5><p><code>HTTP:超文本传输协议（HyperText Transfer Protocol</code></p><blockquote><p>1、HTTP由两个程序实现：一个是客户程序，一个是服务器程序。这两个程序运行在不同的端系统中，通过交换HTTP报文进行会话。HTTP协议定义了这些报文的结构以及客户和服务器进行报文交换的方式。</p><p><code>python网络爬虫就是对HTTP报文进行操作的一个实际的例子</code></p></blockquote><blockquote><p>2、Web页面（也即前端）</p><p>Web页面由对象组成，一个对象可以是HTML文件、图片、视频或者是一个小程序。他们通过一个URL地址寻址，图示为页面中的对象</p><p><code>URL地址的构成</code></p><p>http<code>协议名</code>://<a href="http://www.someschool.edu`主机名`/someDepartment/picture.gif%60%E8%AE%BF%E9%97%AE%E7%9A%84%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E5%90%8D%60">www.someSchool.edu`主机名`/someDepartment/picture.gif`访问的文件路径名`</a></p><p><code>python爬虫中对于页面的解析</code></p><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-18-020234.png" alt="image-20210318100234461"></p><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-18-020303.png" alt="image-20210318100302919"></p></blockquote><h4 id="1｜DNS"><a href="#1｜DNS" class="headerlink" title="1｜DNS"></a>1｜DNS</h4><blockquote><p>DNS协议的作用：域名与ip地址之间通过DNS服务器实现相互转化。</p></blockquote><blockquote><p>DNS服务器：</p><p>根DNS服务器</p><p>顶级DNS服务器</p><p>权威DNS服务器</p><p>本地DNS服务器</p><ul><li><input disabled="" type="checkbox"> 为什么不能讲DNS服务器的内容存储在主机中，然后从主机调用，因为个人访问的网站比较少，并不是所有的网站都访问到。</li></ul></blockquote><blockquote><p>域名解析过程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">host + 域名<br></code></pre></td></tr></table></figure><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-17-003825.png" alt="image-20210317083820648"></p><p>返回的值就是域名对应的ip地址</p></blockquote><blockquote><p>DNS报文</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Base</category>
      
      <category>Experiment</category>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>408实验</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++[基础阶段刷题练习]</title>
    <link href="/2021/02/28/0_C++_CodeWars/"/>
    <url>/2021/02/28/0_C++_CodeWars/</url>
    
    <content type="html"><![CDATA[<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h4 id="1｜数值计算"><a href="#1｜数值计算" class="headerlink" title="1｜数值计算"></a>1｜数值计算</h4><blockquote><p>1、浮点数与整数的计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a=<span class="hljs-number">8</span>,b=<span class="hljs-number">10</span>;<br><span class="hljs-keyword">float</span> result;<br>result = a/b;<span class="hljs-comment">//输出还是int类型，输出结果为0</span><br>result = (<span class="hljs-keyword">float</span>) a / (<span class="hljs-keyword">float</span>) b;<span class="hljs-comment">//这个为想要的结果</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>2、数字字符串转换为数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">string</span> str;<br><span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; a;<br>getline(<span class="hljs-built_in">cin</span>,str);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;str.size();i++)a.push_back(str[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>3、判断是不是完全平方数</p><blockquote><p>sqrt(sq) 如果是完全</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;    </span></span><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findNextSquare</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> sq)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sqrt</span>(sq) != (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">sqrt</span>(sq))&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<br>  <span class="hljs-keyword">return</span>  <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">sqrt</span>(sq) + <span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="2｜字符串操作"><a href="#2｜字符串操作" class="headerlink" title="2｜字符串操作"></a>2｜字符串操作</h4><blockquote><p>字符串操作题目类型:</p><p>1、统计字符串中的数字个数、特殊字符个数以及字母个数</p></blockquote><blockquote><p>2、cin 和 fgets的区别</p><ul><li>声明为string使用cin输入</li><li>声明为char str[n]，使用fgets输入；如果声明为string使用fgets输入的话，会报错<code>不存在从 &quot;std::__1::string&quot; 到 &quot;char *&quot; 的适当转换函数C/C++(413)</code></li></ul></blockquote><blockquote><p>3、使用cin、getline等输入方法</p></blockquote><blockquote><p>4、字符串添加操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">string</span> str1,str2;<br><span class="hljs-keyword">int</span> len = str.size();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>  str2 += str1[i]+str1[(i+<span class="hljs-number">1</span>) % len]; <span class="hljs-comment">//字符串可以直接的添加操作，但是数组不可以</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>5、正则表达式</p><ul><li>检查一个字符串中是否包含某种形式的子串</li><li>将匹配的子串替换</li><li>从某个串中取出符合条件的子串</li><li><code>参考文件</code>：<a href="https://www.cnblogs.com/xiaofeiIDO/p/7892185.html">https://www.cnblogs.com/xiaofeiIDO/p/7892185.html</a></li></ul><p>正则表达式中主要在于是把握子串的形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">regex <span class="hljs-title">rx</span> <span class="hljs-params">(<span class="hljs-string">&quot;\\b&quot;</span> + sub + <span class="hljs-string">&quot;\\b&quot;</span>)</span></span>;    <span class="hljs-comment">//需要进行替换的子串</span><br><span class="hljs-built_in">string</span> ans = regex_replace(str,rx,rep);    <span class="hljs-comment">//将str中符合rx要求的子串替换为rep，保存到ans中</span><br><span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt;<span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure></blockquote><h4 id="3｜条件判断"><a href="#3｜条件判断" class="headerlink" title="3｜条件判断"></a>3｜条件判断</h4><blockquote><p>1、类型为bool类型的返回值</p><blockquote><p>// return xcount == oCount；直接返回判断值</p><p>// algorithm头文件中的count函数用于计数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">XO</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; str)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> xCount = <span class="hljs-built_in">std</span>::count(str.begin(), str.end(), <span class="hljs-string">&#x27;x&#x27;</span>) + <span class="hljs-built_in">std</span>::count(str.begin(), str.end(), <span class="hljs-string">&#x27;X&#x27;</span>);<br>  <span class="hljs-keyword">int</span> oCount = <span class="hljs-built_in">std</span>::count(str.begin(), str.end(), <span class="hljs-string">&#x27;o&#x27;</span>) + <span class="hljs-built_in">std</span>::count(str.begin(), str.end(), <span class="hljs-string">&#x27;O&#x27;</span>);<br>  <span class="hljs-keyword">return</span> xCount ==  oCount;<br>&#125;<br><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>2、条件判断中？ ： 的使用，主要用于简化代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">return</span> (num%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)?<span class="hljs-string">&quot;Even&quot;</span>:<span class="hljs-string">&quot;Odd&quot;</span>;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>3、</p></blockquote><h4 id="4｜头文件中的函数"><a href="#4｜头文件中的函数" class="headerlink" title="4｜头文件中的函数"></a>4｜头文件中的函数</h4><blockquote><p>1、判断最小值</p><blockquote><p>//algorithm头文件中有直接取出最小值的函数min_element</p><ul><li><input disabled="" type="checkbox"> cbegin和begin的区别是什么？</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findSmallest</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; xs)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> *<span class="hljs-built_in">std</span>::min_element(xs.cbegin(), xs.cend());<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="5｜宏定义"><a href="#5｜宏定义" class="headerlink" title="5｜宏定义"></a>5｜宏定义</h4><blockquote><p>1、宏定义的使用</p><blockquote><p>题目：一个greet函数输出hello world!</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> roses std</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> are </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> red ::</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> violets string</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> are </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> blue greet</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> this ()</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> poem &#123;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> makes return</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> no <span class="hljs-meta-string">&quot;hello world!&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> sense ;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> microwave &#125;</span><br><br><span class="hljs-comment">// Write a function &quot;greet&quot; that returns &quot;hello world!&quot; of type std::string</span><br>roses are red<br>violets are blue<br><span class="hljs-keyword">this</span> poem makes no sense<br>microwave<br></code></pre></td></tr></table></figure></blockquote><h4 id="6｜容器使用"><a href="#6｜容器使用" class="headerlink" title="6｜容器使用"></a>6｜容器使用</h4><h5 id="1｜vector"><a href="#1｜vector" class="headerlink" title="1｜vector"></a>1｜vector</h5><blockquote><p>1、vector排序:使用al头文件中的sort函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">sumTwoSmallestNumbers</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; numbers)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">std</span>::sort(numbers.begin(), numbers.end());<br>    <br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">long</span>)numbers[<span class="hljs-number">0</span>] + (<span class="hljs-keyword">long</span>)numbers[<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>2、定义一个vector的pair，并对pair内元素进行计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;utility&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">number</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;&amp; busStops)</span></span>&#123;<br>  <span class="hljs-keyword">int</span> passengers = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i: busStops)  passengers += i.first - i.second;<br>  <span class="hljs-keyword">return</span> passengers;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="2｜string"><a href="#2｜string" class="headerlink" title="2｜string"></a>2｜string</h5><blockquote><p>string中大小写转换以及find函数</p><p>toupper()函数只能对字符进行转换，而不能对全部字符串进行转换</p><p><code>toupper(char t)</code>//toupper()函数的参数为字符，而不能是字符串</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">abbrevName</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s = <span class="hljs-string">&quot;&quot;</span>;<br>  s += <span class="hljs-built_in">toupper</span>(name[<span class="hljs-number">0</span>]);<br>  s += <span class="hljs-string">&#x27;.&#x27;</span>;<br>  s += <span class="hljs-built_in">toupper</span>(name[name.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27; &#x27;</span>)+<span class="hljs-number">1</span>]);<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="3｜数组操作"><a href="#3｜数组操作" class="headerlink" title="3｜数组操作"></a>3｜数组操作</h4><blockquote><p>1、下标的转换与数组的首地址和地址操作，下标转换需要一定的积累，多刷题，掌握下标转换的一些技巧。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//遍历仅含a-z的字符串，统计每个字符的数目</span><br><span class="hljs-comment">//通过数量关系转换为数组下标</span><br><span class="hljs-keyword">int</span> count[<span class="hljs-number">26</span>];<br><span class="hljs-built_in">string</span> str;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;str[i] == <span class="hljs-string">&#x27;\0&#x27;</span>;i++)<br>count[str[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br><span class="hljs-comment">//此时，count的下标为str[i] - &#x27;a&#x27;即a的数目存储在count[0]中，以此类推</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>2、如果要进行两个字符串数组操作，如将其中一个字符串数组的元素进行拷贝，增加空格等操作；那么需要设置两个参数<code>int i  |  int j</code>分别对两个数组进行操作；因为可能存在不同步的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//对应的字符串增加空格</span><br><span class="hljs-comment">//增加相应的参数，理解为双指针</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;str1[i] &amp;&amp; str1[i] != <span class="hljs-string">&#x27;\n&#x27;</span>;i++,j+=<span class="hljs-number">2</span>)<br>&#123;<br>  str2[j] = str1[i];<br>  str2[j+<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="4｜基本算法思路"><a href="#4｜基本算法思路" class="headerlink" title="4｜基本算法思路"></a>4｜基本算法思路</h4><blockquote><p>1、字符加密，字符轮回偏移</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//首先要得出偏移量+偏移基础</span><br><span class="hljs-comment">//轮回使用取模运算</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c:s)<br>  <span class="hljs-keyword">if</span>(c &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)c = (c-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>) % <span class="hljs-number">26</span> + <span class="hljs-string">&#x27;a&#x27;</span>;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>2、第一类双指针算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)<br>&#123;<br>  <span class="hljs-keyword">int</span> j = i;<br><span class="hljs-keyword">while</span>(j&lt;str.size() &amp;&amp; str[i] == str[j])j++;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  需要进行的操作</span><br><span class="hljs-comment">  */</span><br>i = j+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>3、做算法题要有逆向思维，比如求子串的循环次数，从字符串入手比较复杂，那么考虑从循环次数入手。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Base</category>
      
      <category>Grammar</category>
      
      <category>Code</category>
      
      <category>Practise</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++_Grammar</title>
    <link href="/2021/02/28/0_C++_Grammar/"/>
    <url>/2021/02/28/0_C++_Grammar/</url>
    
    <content type="html"><![CDATA[<h3 id="1｜C-｜数组操作"><a href="#1｜C-｜数组操作" class="headerlink" title="1｜C++｜数组操作"></a>1｜C++｜数组操作</h3><h4 id="1｜C-数组长度"><a href="#1｜C-数组长度" class="headerlink" title="1｜C++数组长度"></a>1｜C++数组长度</h4><blockquote><p>在c++中没有函数直接返回数组长度的，所以使用宏定义和局部变量返回到数组长度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> c = <span class="hljs-keyword">sizeof</span>(a[]) / <span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>]);<br><span class="hljs-comment">//但是总求错，不知道为什么</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="2｜多维数组"><a href="#2｜多维数组" class="headerlink" title="2｜多维数组"></a>2｜多维数组</h4><blockquote><p>C++中二维数组默认是先行后列，a[i] [j]默认为先输出第i行，后输出第j列</p></blockquote><h3 id="2｜C-｜函数"><a href="#2｜C-｜函数" class="headerlink" title="2｜C++｜函数"></a>2｜C++｜函数</h3><h4 id="1｜作用域"><a href="#1｜作用域" class="headerlink" title="1｜作用域"></a>1｜作用域</h4><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><blockquote><p>单个模块使用（函数模块、循环与判断模块）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<span class="hljs-comment">//此时的a只哟ing与main模块中</span><br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-comment">//此时i只用于for循环模块中</span><br></code></pre></td></tr></table></figure></blockquote><h5 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h5><blockquote><p>如果没有发生重名，可以在本.cpp文件中全局使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> global = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">cout</span> &lt;&lt; global &lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">cout</span> &lt;&lt; global &lt;&lt; enld;<br>  func();<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="重名现象"><a href="#重名现象" class="headerlink" title="重名现象"></a>重名现象</h5><blockquote><p>如果全局变量和局部变量重名的话，那么当作是局部变量使用</p></blockquote><h5 id="常量的使用"><a href="#常量的使用" class="headerlink" title="常量的使用"></a>常量的使用</h5><blockquote><p>使用#define定义：只要是C++数据类型都可以使用宏来进行定义；同时宏定义还可以使用函数的形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PI 3.1415926</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NEWLINE <span class="hljs-meta-string">&#x27;\n&#x27;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//宏定义函数形式</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>使用const关键字定义：</p><p>const type(数据类型)    name（名称）</p><p><code>注意语法区别：使用define定义没有&#39;;&#39;，使用const定义有</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi= <span class="hljs-number">3.14</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> p = <span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure></blockquote><h4 id="2｜递归"><a href="#2｜递归" class="headerlink" title="2｜递归"></a>2｜递归</h4><h5 id="1｜递归实现借助堆栈"><a href="#1｜递归实现借助堆栈" class="headerlink" title="1｜递归实现借助堆栈"></a>1｜递归实现借助堆栈</h5><p>​    <code>静态存储分配｜栈内存分配｜堆内存分配</code></p><blockquote><p>c++程序在运行时，计算机的内存区被分为程序代码去、全局数据去、堆区和栈区</p></blockquote><blockquote><p>静态存储区分配：</p><p><code>使用static变量和static object（全局对象）的方式声明</code></p><p>内存在程序编译的时候就已经分配好并且存在于程序的整个运行过程</p></blockquote><ul><li><input disabled="" type="checkbox"> 程序的执行过程：编译、链接、运行</li></ul><blockquote><p>栈内存分配：</p><p>存在于某一个作用域的一块空间，如函数中的局部变量；</p></blockquote><blockquote><p>堆内存分配：</p><p>相当于是动态内存分配，通常使用new和delete关键字进行管理；堆内存空间可以由用户手动分配和释放。</p><p>堆内存的管理借助指针进行管理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> *p; <span class="hljs-comment">//定义一个指向int类型的指针p</span><br>  p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;<span class="hljs-comment">//开辟一个int大小的内存空间，指针p指向这片空间</span><br>  *p = <span class="hljs-number">6</span>;<span class="hljs-comment">//为这片空间中的变量赋值</span><br>  <span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-comment">//输出</span><br>  <span class="hljs-keyword">delete</span> p;<span class="hljs-comment">//释放内存空间</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><ul><li><input disabled="" type="checkbox"> 全局变量是静态存储分配还是堆栈类型？</li><li><input disabled="" type="checkbox"> new｜delete和malloc｜free有什么区别？</li><li><input disabled="" type="checkbox"> 递归是如何借助堆栈实现的？为什么借助了堆？还是只借助了栈？</li></ul><h4 id="3｜引用的使用"><a href="#3｜引用的使用" class="headerlink" title="3｜引用的使用"></a>3｜引用的使用</h4><blockquote><p>修改形参会影响实际参数;</p><p>引用和指针的区别：</p><ul><li>可以通过 <code>指针名=0</code> 描述一个空指针，但不存在空引用。</li><li>指针可在任何时间进行初始化操作，而引用只能在定义时进行初始化操作。</li><li>指针变量指向内存的一个存储单元；而引用只不过是原变量的一个别名而已。</li><li>定义的方式不同：应用的定义为<code>int &amp;x = i;</code>指针的定义为<code>int *s;</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i=<span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">int</span> j=<span class="hljs-number">4</span>;<br><br>    <span class="hljs-keyword">int</span> &amp;x = i;<br>    <span class="hljs-keyword">int</span> *s;<br>    s = &amp;j;<br><br>    <span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; *s &lt;&lt;<span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="4｜函数重载"><a href="#4｜函数重载" class="headerlink" title="4｜函数重载"></a>4｜函数重载</h4><blockquote><p>定义一个参数类型或者是参数个数不同的函数，当程序执行时，程序会根据参数类型和个数匹配函数。</p></blockquote><h3 id="3｜C-｜类和对象"><a href="#3｜C-｜类和对象" class="headerlink" title="3｜C++｜类和对象"></a>3｜C++｜类和对象</h3><p><code>抽象｜封装｜继承｜多态</code></p><blockquote><p>抽象：数据抽象和行为抽象，比如英雄联盟的防御塔，数据抽象就是血量是多少、防御使多少；行为抽象就是英雄进入范围后攻击</p><p>封装：对外提供ganging访问方式，内部的数据和行为进行隐藏；比如防御塔，在main函数中，直接调用防御塔这个对象就可以。</p><p>继承：通过代码复用，对子类进行具体说明；比如防御塔，二塔有一塔全部的属性和行为，但是在一塔告破后，二塔增加属性。</p><p>多态：一段程序能够处理多种类型对象的能力。多态包含：强制多态、重载多态、类型参数话多态、包含多态。<code>没理解</code></p></blockquote><h4 id="1｜类的定义"><a href="#1｜类的定义" class="headerlink" title="1｜类的定义"></a>1｜类的定义</h4><blockquote><p>对具有相同性质的对象进行抽象，找出共同的属性，构成同一类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> 类的名称：</span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">public</span>:<br>  外部接口<br>  <span class="hljs-keyword">protected</span>:<br>  保护性成员<br>  <span class="hljs-keyword">private</span>：<br>    私有成员<br>&#125;；<br></code></pre></td></tr></table></figure></blockquote><h4 id="2｜类的成员访问控制"><a href="#2｜类的成员访问控制" class="headerlink" title="2｜类的成员访问控制"></a>2｜类的成员访问控制</h4><ul><li><input disabled="" type="checkbox"> 没有掌握</li></ul><h5 id="1｜public"><a href="#1｜public" class="headerlink" title="1｜public"></a>1｜public</h5><h5 id="2｜protected"><a href="#2｜protected" class="headerlink" title="2｜protected"></a>2｜protected</h5><h5 id="3｜private"><a href="#3｜private" class="headerlink" title="3｜private"></a>3｜private</h5><h4 id="3｜对象的声明"><a href="#3｜对象的声明" class="headerlink" title="3｜对象的声明"></a>3｜对象的声明</h4><h4 id="4｜类的成员函数"><a href="#4｜类的成员函数" class="headerlink" title="4｜类的成员函数"></a>4｜类的成员函数</h4><h4 id="5｜struct基本结构体"><a href="#5｜struct基本结构体" class="headerlink" title="5｜struct基本结构体"></a>5｜struct基本结构体</h4><h5 id="1｜结构体声明"><a href="#1｜结构体声明" class="headerlink" title="1｜结构体声明"></a>1｜结构体声明</h5><h4 id="6｜类练习"><a href="#6｜类练习" class="headerlink" title="6｜类练习"></a>6｜类练习</h4><blockquote><p>声明枚举类型CPU_Rank，例如enum CPU_Rank{P1=1，P2，P3，P4，P5，P6，P7}，再声明成员函数run，stop，用来输出提示信息，在构造函数和析构函数中也可以输出提示信息。在主程序中声明一个CPU的对象，调用其成员函数，观察类对象的构造与析构顺序，以及成员函数的调用。</p></blockquote><h3 id="4｜C-基本数据类型与表达式"><a href="#4｜C-基本数据类型与表达式" class="headerlink" title="4｜C++|基本数据类型与表达式"></a>4｜C++|基本数据类型与表达式</h3><h4 id="1｜string类"><a href="#1｜string类" class="headerlink" title="1｜string类"></a>1｜string类</h4><blockquote><p>使用string头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br></code></pre></td></tr></table></figure></blockquote><h4 id="2-｜字符串操作"><a href="#2-｜字符串操作" class="headerlink" title="2 ｜字符串操作"></a>2 ｜字符串操作</h4><h4 id="1｜读与写"><a href="#1｜读与写" class="headerlink" title="1｜读与写"></a>1｜读与写</h4><p><code>fgets|scanf|fscanf|sscanf|gets|fputs｜cin</code></p><p><code>输入的方法比较多，实践后慢慢补全</code></p><h5 id="1｜fgets-读入字符串"><a href="#1｜fgets-读入字符串" class="headerlink" title="1｜fgets 读入字符串"></a>1｜fgets 读入字符串</h5><ul><li><p>Reads at most <code>count - 1</code> characters from the given file stream and stores them in the character array pointed to by <code>str</code>. Parsing stops if a newline character is found, in which case <code>str</code> will contain that newline character, or if end-of-file occurs. If bytes are read and no errors occur, writes a null character at the position immediately after the last character written to <code>str</code>.</p></li><li><p>fgets() 函数用来从指定的文件中读取一个字符串，并保存到字符数组中</p></li><li><p>fgets是将<code>std::FILE* stream</code>读取到<code>char* str</code>中，如果是没有超过<code>count</code>的话</p></li><li><p>fgets会读取回车<code>\n</code>，所以在计算字符串长度的时候需要增加边界条件<code>str[i] != &#39;\n&#39;</code>,但是fgets遇到</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">fgets</span><span class="hljs-params">( <span class="hljs-keyword">char</span>* str, <span class="hljs-keyword">int</span> count, <span class="hljs-built_in">std</span>::FILE* stream ）</span></span><br></code></pre></td></tr></table></figure><table><thead><tr><th>str</th><th>-</th><th>pointer to an element of a char array（指向数组的指针｜数组名字）</th></tr></thead><tbody><tr><td><strong>count</strong></td><td><strong>-</strong></td><td><strong>maximum number of characters to write (typically the length of <code>str</code>)（字符串允许输入的最大长度）</strong></td></tr><tr><td><strong>stream</strong></td><td><strong>-</strong></td><td><strong>file stream to read the data from（数据的输入形式）</strong></td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">std</span>::FILE* tmpf = <span class="hljs-built_in">std</span>::tmpfile();<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;Alan Turing\n&quot;</span>, tmpf);<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;John von Neumann\n&quot;</span>, tmpf);<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;Alonzo Church\n&quot;</span>, tmpf);<br> <br>    <span class="hljs-built_in">std</span>::rewind(tmpf);<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">8</span>];<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">std</span>::fgets(buf, <span class="hljs-keyword">sizeof</span> buf, tmpf) != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&#x27;&quot;&#x27;</span> &lt;&lt; buf &lt;&lt; <span class="hljs-string">&#x27;&quot;&#x27;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>fgets通常配合fopen、puts进行文件内容的输出</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* fgets example */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   FILE * pFile;<br>   <span class="hljs-keyword">char</span> mystring [<span class="hljs-number">100</span>];<br><br>   pFile = fopen (<span class="hljs-string">&quot;myfile.txt&quot;</span> , <span class="hljs-string">&quot;r&quot;</span>);<br>   <span class="hljs-keyword">if</span> (pFile == <span class="hljs-literal">NULL</span>) perror (<span class="hljs-string">&quot;Error opening file&quot;</span>);<br>   <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-keyword">if</span> ( fgets (mystring , <span class="hljs-number">100</span> , pFile) != <span class="hljs-literal">NULL</span> )<br>       <span class="hljs-built_in">puts</span> (mystring);<br>     fclose (pFile);<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> fgets输入到字符串中长度是否包含<code>&#39;\0&#39;</code></li><li><input disabled="" type="checkbox"> 一个文件的结束标记是什么？fgets如何读取出整个文件的内容，包括<code>&#39;\n&#39;</code>等内容</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* fgets example</span><br><span class="hljs-comment"> 可以输出myfile.txt中的全部内容</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   FILE * pFile;<br>   <span class="hljs-keyword">char</span> mystring [<span class="hljs-number">100</span>];<br><br>   pFile = fopen (<span class="hljs-string">&quot;myfile.txt&quot;</span> , <span class="hljs-string">&quot;r&quot;</span>);<br>   <span class="hljs-keyword">if</span> (pFile == <span class="hljs-literal">NULL</span>) perror (<span class="hljs-string">&quot;Error opening file&quot;</span>);<br>   <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-keyword">while</span> ( fgets (mystring , <span class="hljs-number">100</span> , pFile) != <span class="hljs-literal">NULL</span> )<br>       <span class="hljs-built_in">puts</span> (mystring);<br>     fclose (pFile);<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2｜fputs-写入字符串"><a href="#2｜fputs-写入字符串" class="headerlink" title="2｜fputs()写入字符串"></a>2｜fputs()写入字符串</h5><ul><li>Writes every character from the null-terminated string <code>str</code> to the output stream <code>stream</code>, as if by repeatedly executing [std::fputc](dfile:///Users/uoruichi/Library/Application Support/Dash/DocSets/C++/C++.docset/Contents/Resources/Documents/en.cppreference.com/w/cpp/io/c/fputc.html).</li><li>fputs() 函数用来向指定的文件写入一个字符串；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fputs</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str, [<span class="hljs-built_in">std</span>::FILE]</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> rc = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;Hello World&quot;</span>, <span class="hljs-built_in">stdout</span>);<span class="hljs-comment">//向stdout写入字符串</span><br> <br>    <span class="hljs-keyword">if</span> (rc == EOF)<br>       <span class="hljs-built_in">std</span>::perror(<span class="hljs-string">&quot;fputs()&quot;</span>); <span class="hljs-comment">// POSIX requires that errno is set</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 实现将vs code的输出保存为txt文件，相当于输出日志</li></ul><h5 id="3｜字符串操作函数-基于char"><a href="#3｜字符串操作函数-基于char" class="headerlink" title="3｜字符串操作函数            基于char[]"></a>3｜字符串操作函数            <code>基于char[]</code></h5><blockquote><p>在头文件<code>#include &lt;cstring&gt;</code>中有很多对字符串操作的函数；</p><p>但是只能用于<code>char str[n]</code>类型的声明，不能用于<code>string str</code>的声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> str1[<span class="hljs-number">10</span>] = <span class="hljs-string">&quot;hello&quot;</span>;<br>  <span class="hljs-keyword">char</span> str2[<span class="hljs-number">18</span>] = <span class="hljs-string">&quot;python&quot;</span>;<br>  <br>  <span class="hljs-built_in">strcat</span>(str1,str2);<br>  <span class="hljs-built_in">cout</span> &lt;&lt; str1 &lt;&lt; <span class="hljs-built_in">endl</span>;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>name</th><th>func</th></tr></thead><tbody><tr><td>函数</td><td>作用</td></tr><tr><td>strcpy(s1,s2)</td><td>复制字符串s2到s1中</td></tr><tr><td>strcat(s1,s2)</td><td>将字符串s2连接到s1的末尾</td></tr><tr><td>strlen(s)</td><td>计算字符串s的长度</td></tr><tr><td>strcmp(s1,s2)</td><td>比较字符串的长度，相同返回0；s2大的话返回-1;s1大的话返回1</td></tr><tr><td>strchr(s1,ch)</td><td>返回一个指针，指针指向ch在s1中的首个位置</td></tr><tr><td>strstr(s1,s2)</td><td>返回一个指针，指针指向s2在s1中的首位置</td></tr></tbody></table></blockquote><h5 id="4｜string类"><a href="#4｜string类" class="headerlink" title="4｜string类"></a>4｜string类</h5><blockquote><p>使用<code>string str;</code>声明的变量不是基于数组的，而是基于string类的；</p><p>对于字符串类中的str，使用‘+’号为连接</p><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-09-001200.png" alt="image-20210309081159704"></p></blockquote><h3 id="5｜C-循环与条件判断"><a href="#5｜C-循环与条件判断" class="headerlink" title="5｜C++循环与条件判断"></a>5｜C++循环与条件判断</h3><h4 id="使用三元运算符"><a href="#使用三元运算符" class="headerlink" title="使用三元运算符"></a>使用三元运算符</h4><h5 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h5><blockquote><p>使用环境：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">c = (a&gt;b) ? a:b;<br><span class="hljs-comment">//a &gt; b 为条件判断===&gt;if else结构，如果a&gt;b成立则返回a；否则返回b</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="6｜STL"><a href="#6｜STL" class="headerlink" title="6｜STL"></a>6｜STL</h3><p><code>模版编程｜泛型编程｜STL常用组件｜lambda表达式｜异常处理｜内存处理</code></p><p><code>算法｜容器｜迭代器｜适配器｜仿函数（函数对象）｜空间适配器</code></p><p><code>泛型｜模版｜oop</code></p><blockquote><p>本部分所有代码至少需要开启 -std=c++11 选项来支持 C++11 相关特性，在介绍 C++14 特性时的相关代码需要开启 -std=c++14 的编译选项；可以在使用命令行g++的时候使用<code>g++ main.cpp -std = c++ 11(14)</code>来进行操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ main.cpp -std = c++ 11(14)<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>STL的算法是基于容器进行的，是通用的算法；并不依赖一某种数据结构和对象。</p></blockquote><blockquote><p>使用迭代器完成对容器的访问，迭代器底层是由指针实现的，这也是c++和c的区别，c实现算法和数据结构都是由指针实现的；c++实现算法和数据结构是通过容器+迭代器实现的；所以是不是可以理解为c比c++更加接近底层。</p></blockquote><blockquote><p>STL的基本容器是vector、list、queue；基本容器的适配器是queue、stack</p></blockquote><blockquote><p>空间适配器就是STL自己的内存池</p></blockquote><h4 id="1｜容器"><a href="#1｜容器" class="headerlink" title="1｜容器"></a>1｜容器</h4><h5 id="1｜vector（向量—-变长数组）"><a href="#1｜vector（向量—-变长数组）" class="headerlink" title="1｜vector（向量—-变长数组）"></a>1｜vector（向量—-变长数组）</h5><p><code>邻接表的方式存储图｜解决普通数组超内存|用于处理输入数据数量不确定的情况</code></p><blockquote><p>定义vector</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">typename</span>&gt; name;<span class="hljs-comment">//定义一个typename类型的vector变量,变量名字为name</span><br><span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">array</span>;<span class="hljs-comment">//相当于定义一个int类型的array[SIZE]数组</span><br></code></pre></td></tr></table></figure><p>进阶定义</p><ul><li>定义一个vector的结构体</li><li>定义一个二维数组</li></ul></blockquote><blockquote><p>vector内元素循环访问</p><ul><li>通过下标访问</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dc++">vector &lt;int&gt; vi;<br>printf(&quot;%&quot;,vi[index]);&#x2F;&#x2F;通过index进行访问，index的范围为[0,vi.size()]，可以直接调用vi.size()输出vi数组的长度<br></code></pre></td></tr></table></figure><ul><li>通过迭代器访问，迭代器可以理解为指针，迭代器也是需要定义的，可以理解为一个变量。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; ::iterator it;<span class="hljs-comment">//得到迭代器it，it是迭代器的名字，所以可以定义为别的名字</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; vi;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)  vi.push_back(i);<br>    <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; ::iterator it = vi.begin();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<span class="hljs-comment">//迭代器使用的第一种用法</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,*(it+i));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">for</span>(it=vi.begin();it != vi.end();it++)<span class="hljs-comment">//迭代器循环的第二种用法</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,*it);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>push_back函数与pop_back函数的使用</p><p>push_back()是在vector的末尾添加x</p><p>pop_back()是删除vector的末尾元素但是不会输出删除了哪些。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; vi;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">6</span>;i++)   vi.push_back(i);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t%d\n&quot;</span>,vi[<span class="hljs-number">0</span>],vi[<span class="hljs-number">6</span>]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)    vi.pop_back();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;vi.size();i++)    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,vi[i]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>size函数，返回值为int类型，返回vector的大小</p></blockquote><blockquote><p>clear()函数，晴空vector容器</p></blockquote><blockquote><p>insert()，基于迭代器进行操作，需要添加两个参数，<code>vi.insert(it+2,-1)</code>，将-1添加到<code>vi[2]</code>的位置</p></blockquote><blockquote><p>erase()，删除区间内的元素，<code>vi.erase(it.begin(),it.end())</code>，删除元素的范围左开右闭<code>[it.begin(),it.end())</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; vi;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)  vi.push_back(i);<br>    <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; ::iterator it = vi.begin();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,*(it+i));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-comment">//  for(vector &lt;int&gt; ::iterator it = vi.begin();it != vi.end();it++)</span><br><span class="hljs-comment">//      printf(&quot;%d &quot;,*it);</span><br>    vi.erase(vi.begin(),vi.begin()+<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;vi.size();i++)    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,vi[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    vi.erase(vi.begin(),vi.end());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;vi.size();i++)    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,vi[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// output</span><br><span class="hljs-comment">// 0 1 2 3 4 </span><br><span class="hljs-comment">// 2 3 4  //经过第一次erase()，begin(),begin+2,删除的区间是[begin()+0,begin()+2)的区间</span><br><span class="hljs-comment">// //经过第二次erase(),可以看出来begin(),end()的范围的话，是全部删除</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 使用vector定义邻接表</li></ul></blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 使用完vector后，是不是不用释放空间？</li></ul></blockquote><h5 id="2｜list（列表）"><a href="#2｜list（列表）" class="headerlink" title="2｜list（列表）"></a>2｜list（列表）</h5><h5 id="3｜queue（队列）"><a href="#3｜queue（队列）" class="headerlink" title="3｜queue（队列）"></a>3｜queue（队列）</h5><h5 id="4｜deque（双端队列）"><a href="#4｜deque（双端队列）" class="headerlink" title="4｜deque（双端队列）"></a>4｜deque（双端队列）</h5><h5 id="5｜set（集合）"><a href="#5｜set（集合）" class="headerlink" title="5｜set（集合）"></a>5｜set（集合）</h5><h5 id="6｜multiset（多种集合）"><a href="#6｜multiset（多种集合）" class="headerlink" title="6｜multiset（多种集合）"></a>6｜multiset（多种集合）</h5><h5 id="7｜map（映射）"><a href="#7｜map（映射）" class="headerlink" title="7｜map（映射）"></a>7｜map（映射）</h5><h5 id="8｜multimap（多重映射）"><a href="#8｜multimap（多重映射）" class="headerlink" title="8｜multimap（多重映射）"></a>8｜multimap（多重映射）</h5><h4 id="2｜模版编程"><a href="#2｜模版编程" class="headerlink" title="2｜模版编程"></a>2｜模版编程</h4><p><code>基本语法｜模版函数｜类模版｜成员模版｜模版中的静态成员｜typename与class｜迭代器</code></p><h5 id="1｜函数模版化"><a href="#1｜函数模版化" class="headerlink" title="1｜函数模版化"></a>1｜函数模版化</h5><blockquote><p>为什么要使用模版编程的思想？</p><p>因为C++中对于数据类型区分比较明确，所以使用模版编程的话会简化工作，也就是使用模版来定义数据类型。</p><p>向 <code>add</code> 函数提供参数时，编译器会自动分析参数的类型，然后将所有用到 T 定义的换成相对性的类型。其实主要的作用在于自动分析参数的类型。这样定义的函数可以多次重复调用，而不用多次编辑。</p><p>其实也就是使用<code>template &lt;typename T&gt;</code>替换类型，再由编译器自动分析参数类型</p><p>定义：<code>template</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T lva,<span class="hljs-keyword">const</span> T rva)</span></span><br><span class="hljs-function"></span>&#123;<br>  T a;<br>  a = lva + rva;<br>  <span class="hljs-keyword">return</span> a;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">cout</span> &lt;&lt; add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br> <span class="hljs-built_in">cout</span> &lt;&lt; add(<span class="hljs-number">1.0</span>,<span class="hljs-number">2.2</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="2｜类模版化"><a href="#2｜类模版化" class="headerlink" title="2｜类模版化"></a>2｜类模版化</h5><blockquote><p>使用类模版化的前提是对类的操作要熟悉</p><p>在定义类模板的时候，常常使用 class 作为关键字，增加代码可读性。其它则用 typename，上面的代码大都遵循这样的标准，但是并无强制规定。</p></blockquote><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Myclass</span></span><br><span class="hljs-class">&#123;</span><br>  T a;<br>  <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">T <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T lva,<span class="hljs-keyword">const</span> T rva)</span></span>;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br>T Myclass &lt;T&gt;::add(<span class="hljs-keyword">const</span> T lva,<span class="hljs-keyword">const</span> T rva)<br>&#123;<br>  a = lva + rva;<br>  <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="3-迭代器"><a href="#3-迭代器" class="headerlink" title="3|迭代器"></a>3|迭代器</h5><blockquote><p>迭代器（iterator）是一种对象，它能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址。迭代器修改了常规指针的接口，所谓迭代器是一种概念上的抽象：那些行为上像迭代器的东西都可以叫做迭代器。然而迭代器有很多不同的能力，它可以把抽象容器和通用算法有机的统一起来。迭代器基本分为五种，输入输出迭代器，前向逆向迭代器，双向迭代器和随机迭代器。</p><p>迭代是重复反馈过程的活动，其目的通常是为了接近并到达所需的目标或结果。 每一次对过程的重复被称为一次“迭代”，而每一次迭代得到的结果会被用来作为下一次迭代的初始值。</p></blockquote><blockquote><p>理解：</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Base</category>
      
      <category>Grammar</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
