<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Introduction to Algorithms：Sorting And Finding</title>
    <link href="/2021/03/03/Introduction_to_Algorithms_Sorting/"/>
    <url>/2021/03/03/Introduction_to_Algorithms_Sorting/</url>
    
    <content type="html"><![CDATA[<h3 id="一、排序"><a href="#一、排序" class="headerlink" title="一、排序"></a>一、排序</h3><h4 id="0｜two-pointers"><a href="#0｜two-pointers" class="headerlink" title="0｜two pointers"></a>0｜two pointers</h4><h4 id="1｜选择排序"><a href="#1｜选择排序" class="headerlink" title="1｜选择排序"></a>1｜选择排序</h4><p><code>直接选择｜胜者树｜堆</code></p><h5 id="1｜直接选择排序模版"><a href="#1｜直接选择排序模版" class="headerlink" title="1｜直接选择排序模版"></a>1｜直接选择排序模版</h5><blockquote><p>从V[i] ~V[n-1]中每轮次选取出最小的元素（或者是最小排序码<code>即数组的下标</code>）</p><p><code>Notice:</code>使用排序码也是一种编程技巧</p><p><code>KCN比较次数</code>：KCN = ${n(n-1)\over 2}$</p><p><code>RMN移动次数</code>：$RMN<del>max</del>= 3(n-1)$​</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SelectSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left;i&lt;right;i++)<br>  &#123;<br>   <span class="hljs-comment">//设置单指针，为了后续的交换使用</span><br>    <span class="hljs-keyword">int</span> k = i;<br>   <span class="hljs-comment">//从q[i]~q[right-1]中选取最小的元素，找出当前元素的最小排序码。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>;j&lt;right;j++)<span class="hljs-keyword">if</span>(q[j] &lt; q[k])k=j;<br>   <span class="hljs-comment">//边界条件，如果说存在排序码则进行交换</span><br>  <span class="hljs-keyword">if</span>(k!=i)swap(q[k],q[i]);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2｜锦标赛排序模版（使用胜者树实现）"><a href="#2｜锦标赛排序模版（使用胜者树实现）" class="headerlink" title="2｜锦标赛排序模版（使用胜者树实现）"></a>2｜锦标赛排序模版（使用胜者树实现）</h5><h5 id="3｜堆排序（使用堆结构和形成堆的算法实现）"><a href="#3｜堆排序（使用堆结构和形成堆的算法实现）" class="headerlink" title="3｜堆排序（使用堆结构和形成堆的算法实现）"></a>3｜堆排序（使用堆结构和形成堆的算法实现）</h5><h4 id="2｜插入排序"><a href="#2｜插入排序" class="headerlink" title="2｜插入排序"></a>2｜插入排序</h4><h4 id="3｜快速排序"><a href="#3｜快速排序" class="headerlink" title="3｜快速排序"></a>3｜快速排序</h4><h5 id="1｜快速排序模版"><a href="#1｜快速排序模版" class="headerlink" title="1｜快速排序模版"></a>1｜快速排序模版</h5><p><code>双指针｜边界条件判断｜时间复杂度｜TLE（超时）错误</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//此模版存在问题，做题可能会出现Time Limit Exceeded问题</span><br><span class="hljs-comment">//因为此模版式中定义起始位置为A[left],如果为递增或者是递减序列，则时间复杂度为O(n^2),而不是O（nlogn）</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Partition</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> A[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> temp = A[left];<br>  <span class="hljs-keyword">while</span>(left &lt; right)<br>  &#123;<br>    <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; A[right]&gt;temp)right--;<br>    A[left] = A[right];<br>    <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; A[left] &lt;= temp)left++;<br>    A[right] = A[left];<br>  &#125;<br>  A[left] = temp;<br>  <span class="hljs-keyword">return</span> left;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(left &lt; right)<br>  &#123;<br>    <span class="hljs-keyword">int</span> pos = Partition(A,left,right);<br>    quickSort(A,left,pos<span class="hljs-number">-1</span>);<br>    quickSort(A,pos+<span class="hljs-number">1</span>,right);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//测试通过的快速排序模版</span><br><span class="hljs-comment">//边界条件的判断比较多，所以建议在理解的基础上练熟悉模版</span><br><span class="hljs-comment">//很多算法的模版都是使用了双指针的方法进行操作的，所以双指针的使用是比较重要的，需要多加练习</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(left &gt;= right)<span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">//边界条件判断</span><br>  <span class="hljs-keyword">int</span> tmp = q[(left+right)/<span class="hljs-number">2</span>];<br>  <span class="hljs-comment">//随机取值</span><br>  <span class="hljs-keyword">int</span> i = left<span class="hljs-number">-1</span>;<br>  <span class="hljs-comment">//设置双指针</span><br>  <span class="hljs-keyword">int</span> j = right+<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(i &lt; j)<br>  <span class="hljs-comment">//循环操作，直到i与j相遇</span><br>  &#123;<br>    <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(q[i] &lt; tmp);<br>    <span class="hljs-comment">//与第7行的i取值有关</span><br>    <span class="hljs-keyword">do</span> j++; <span class="hljs-keyword">while</span>(q[j] &gt; tmp);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    此处双指针已经就位，需要补入进行的操作；进行交换、对比、取出等操作。</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span>(i &lt; j)swap(q[i],q[j]);<br>    <span class="hljs-comment">//此时双指针已经就位了，需要对满足条件的数据进行操作。</span><br>  &#125;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  1、循环结束，此时i == j的；</span><br><span class="hljs-comment">  2、后续递归处理的范围是[left,j]</span><br><span class="hljs-comment">  */</span><br>  quickSort(q,left,j);<br>  <span class="hljs-comment">//递归处理前半段</span><br>  quickSort(q,j+<span class="hljs-number">1</span>,right);<br>  <span class="hljs-comment">//递归处理后半段</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 需要进行测试，调试输出</li></ul><h4 id="4｜归并排序"><a href="#4｜归并排序" class="headerlink" title="4｜归并排序"></a>4｜归并排序</h4><h5 id="0｜算法思想"><a href="#0｜算法思想" class="headerlink" title="0｜算法思想"></a>0｜算法思想</h5><blockquote><p>基于分治的思想，将整体序列分为<code>logn</code>组数据，组内数据进行排序，排序后合并；</p><p>快排：n/2｜n/4｜n/8……</p><p>归并：……｜n/8｜n/4｜n/2｜=&gt;归并为n</p><p>所以递归调用的位置不同</p><p>归并排序需要开辟新的数组，空间换时间</p></blockquote><h5 id="1｜递归实现归并排序"><a href="#1｜递归实现归并排序" class="headerlink" title="1｜递归实现归并排序"></a>1｜递归实现归并排序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(left &gt;= right)<span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">//边界条件判断，如果只有一个元素则返回</span><br>  <span class="hljs-keyword">int</span> mid = left+right &gt;&gt; <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">//设置数组下标</span><br>  mergeSort(q,left,mid);<br>  <span class="hljs-comment">//递归调用划分左区间</span><br>  mergeSort(q,mid+<span class="hljs-number">1</span>,right);<br>  <span class="hljs-comment">//递归调用划分右区间</span><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  1、递归执行完成后，相当于是序列中的q[i]和q[j]两两对比，所以在执行16-17时已经有序了</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">//设置新开辟数组的下标</span><br>  <span class="hljs-keyword">int</span> i = left;<br>  <span class="hljs-comment">//设置双指针</span><br>  <span class="hljs-keyword">int</span> j = mid+<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right)<br>  <span class="hljs-comment">//执行循环，双指针移动</span><br>    <span class="hljs-keyword">if</span>(q[i] &lt;= q[j])tmp[k++] = q[i++];<br>  <span class="hljs-comment">//给新开辟数组赋值</span><br>  <span class="hljs-keyword">else</span> tmp[k++] = q[j++];<br>  <span class="hljs-comment">//给新开辟数组赋值</span><br>  <span class="hljs-keyword">while</span>(i&lt;= mid)tmp[k++] = q[i++];<br>  <span class="hljs-comment">//将未排序的数组导入到新开辟数组中</span><br>  <span class="hljs-keyword">while</span>(j&lt;=right)tmp[k++] = q[j++];<br>  <span class="hljs-comment">//同上</span><br>  <br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l,j=<span class="hljs-number">0</span>;i&lt;=right;i++,j++)q[i] = tmp[j];<br>  <span class="hljs-comment">//将tmp拷贝到q中，也可以直接使用c++的copy函数</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2｜非递归实现归并排序"><a href="#2｜非递归实现归并排序" class="headerlink" title="2｜非递归实现归并排序"></a>2｜非递归实现归并排序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Sorting</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法导论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP/IP-简介</title>
    <link href="/2021/03/01/TCP-IP/"/>
    <url>/2021/03/01/TCP-IP/</url>
    
    <content type="html"><![CDATA[<h3 id="一、TCP-IP-简介"><a href="#一、TCP-IP-简介" class="headerlink" title="一、TCP IP 简介"></a>一、TCP IP 简介</h3><p><code>实验环境：Linux-Ubuntu20.04｜Mac</code></p><h4 id="1｜应用模型"><a href="#1｜应用模型" class="headerlink" title="1｜应用模型"></a>1｜应用模型</h4><h4 id="2｜知识点"><a href="#2｜知识点" class="headerlink" title="2｜知识点"></a>2｜知识点</h4><h5 id="1｜IP地址"><a href="#1｜IP地址" class="headerlink" title="1｜IP地址"></a>1｜IP地址</h5><h5 id="2｜域名"><a href="#2｜域名" class="headerlink" title="2｜域名"></a>2｜域名</h5><h5 id="3｜MAC地址"><a href="#3｜MAC地址" class="headerlink" title="3｜MAC地址"></a>3｜MAC地址</h5><h5 id="4｜端口号"><a href="#4｜端口号" class="headerlink" title="4｜端口号"></a>4｜端口号</h5><blockquote><p>端口号作用：</p></blockquote><blockquote><p>常用端口号：</p></blockquote><blockquote><p>端口号实际应用：</p></blockquote><h5 id="5｜封装与分用"><a href="#5｜封装与分用" class="headerlink" title="5｜封装与分用"></a>5｜封装与分用</h5><h5 id="6｜Linux网络相关常用命令"><a href="#6｜Linux网络相关常用命令" class="headerlink" title="6｜Linux网络相关常用命令"></a>6｜Linux网络相关常用命令</h5><p><code>借助netstat命令行工具</code></p><h3 id="二、链路层"><a href="#二、链路层" class="headerlink" title="二、链路层"></a>二、链路层</h3><h4 id="1｜链路层简介"><a href="#1｜链路层简介" class="headerlink" title="1｜链路层简介"></a>1｜链路层简介</h4><p><code>知识点：控制帧的传输、以太网、PPP、SLIP与PPP、MTU</code></p><blockquote><p>以太网<code>CSMA/CD</code></p></blockquote><blockquote><p>MTU</p></blockquote><blockquote><p>PPP</p></blockquote><blockquote><p>SLIP</p></blockquote><h4 id="2｜链路层实现功能以及链路层协议"><a href="#2｜链路层实现功能以及链路层协议" class="headerlink" title="2｜链路层实现功能以及链路层协议"></a>2｜链路层实现功能以及链路层协议</h4><h5 id="1｜差错控制"><a href="#1｜差错控制" class="headerlink" title="1｜差错控制"></a>1｜差错控制</h5><h5 id="2｜反馈重发"><a href="#2｜反馈重发" class="headerlink" title="2｜反馈重发"></a>2｜反馈重发</h5><h5 id="3｜计时器"><a href="#3｜计时器" class="headerlink" title="3｜计时器"></a>3｜计时器</h5><h5 id="4｜序号"><a href="#4｜序号" class="headerlink" title="4｜序号"></a>4｜序号</h5><h5 id="5｜流量控制"><a href="#5｜流量控制" class="headerlink" title="5｜流量控制"></a>5｜流量控制</h5><h3 id="三、网络层"><a href="#三、网络层" class="headerlink" title="三、网络层"></a>三、网络层</h3><h4 id="1｜IP数据报"><a href="#1｜IP数据报" class="headerlink" title="1｜IP数据报"></a>1｜IP数据报</h4><h4 id="2｜地址划分"><a href="#2｜地址划分" class="headerlink" title="2｜地址划分"></a>2｜地址划分</h4><h4 id="3｜子网划分"><a href="#3｜子网划分" class="headerlink" title="3｜子网划分"></a>3｜子网划分</h4><h5 id="1｜子网掩码：netmask："><a href="#1｜子网掩码：netmask：" class="headerlink" title="1｜子网掩码：netmask："></a>1｜子网掩码：netmask：</h5><h4 id="4｜IP路由选择"><a href="#4｜IP路由选择" class="headerlink" title="4｜IP路由选择"></a>4｜IP路由选择</h4><h4 id="5｜NAT技术"><a href="#5｜NAT技术" class="headerlink" title="5｜NAT技术"></a>5｜NAT技术</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ifconfig eth0<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br></code></pre></td></tr></table></figure><blockquote><p>内网IP(192.168.X.X和172.16.X.X)          <code>私网地址</code></p></blockquote><h4 id="6｜IP的发展及未来"><a href="#6｜IP的发展及未来" class="headerlink" title="6｜IP的发展及未来"></a>6｜IP的发展及未来</h4><blockquote><p>IPV6</p></blockquote><h4 id="7｜实践"><a href="#7｜实践" class="headerlink" title="7｜实践"></a>7｜实践</h4><h5 id="1｜ifconfig命令详解"><a href="#1｜ifconfig命令详解" class="headerlink" title="1｜ifconfig命令详解"></a>1｜ifconfig命令详解</h5><ul><li><input disabled="" type="checkbox"> 搞清楚每一个的含义是什么，分别在网络层有什么用</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs bash">lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384<br>options=1203&lt;RXCSUM,TXCSUM,TXSTATUS,SW_TIMESTAMP&gt;<br>inet 127.0.0.1 netmask 0xff000000<br>inet6 ::1 prefixlen 128<br>inet6 fe80::1%lo0 prefixlen 64 scopeid 0x1<br>nd6 options=201&lt;PERFORMNUD,DAD&gt;<br>gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280<br>stf0: flags=0&lt;&gt; mtu 1280<br>en6: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500<br>ether ac:de:48:00:11:22<br>inet6 fe80::aede:48ff:fe00:1122%en6 prefixlen 64 scopeid 0x4<br>nd6 options=201&lt;PERFORMNUD,DAD&gt;<br>media: autoselect (100baseTX &lt;full-duplex&gt;)<br>status: active<br>ap1: flags=8802&lt;BROADCAST,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=400&lt;CHANNEL_IO&gt;<br>ether 3a:f9:d3:93:33:9f<br>media: autoselect<br>status: inactive<br>en0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=400&lt;CHANNEL_IO&gt;<br>ether 38:f9:d3:93:33:9f<br>inet 192.168.3.12 netmask 0xffffff00 broadcast 192.168.3.255<br>media: autoselect<br>status: active<br>awdl0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=400&lt;CHANNEL_IO&gt;<br>ether 3e:73:6e:0b:bb:ac<br>inet6 fe80::3c73:6eff:fe0b:bbac%awdl0 prefixlen 64 scopeid 0x7<br>nd6 options=201&lt;PERFORMNUD,DAD&gt;<br>media: autoselect<br>status: active<br>llw0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=400&lt;CHANNEL_IO&gt;<br>ether 3e:73:6e:0b:bb:ac<br>inet6 fe80::3c73:6eff:fe0b:bbac%llw0 prefixlen 64 scopeid 0x8<br>nd6 options=201&lt;PERFORMNUD,DAD&gt;<br>media: autoselect<br>status: active<br>en3: flags=8963&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=460&lt;TSO4,TSO6,CHANNEL_IO&gt;<br>ether 82:23:4a:a0:88:05<br>media: autoselect &lt;full-duplex&gt;<br>status: inactive<br>en4: flags=8963&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=460&lt;TSO4,TSO6,CHANNEL_IO&gt;<br>ether 82:23:4a:a0:88:04<br>media: autoselect &lt;full-duplex&gt;<br>status: inactive<br>en2: flags=8963&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=460&lt;TSO4,TSO6,CHANNEL_IO&gt;<br>ether 82:23:4a:a0:88:00<br>media: autoselect &lt;full-duplex&gt;<br>status: inactive<br>en1: flags=8963&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=460&lt;TSO4,TSO6,CHANNEL_IO&gt;<br>ether 82:23:4a:a0:88:01<br>media: autoselect &lt;full-duplex&gt;<br>status: inactive<br>en5: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=6467&lt;RXCSUM,TXCSUM,VLAN_MTU,TSO4,TSO6,CHANNEL_IO,PARTIAL_CSUM,ZEROINVERT_CSUM&gt;<br>ether 00:e0:4c:68:01:5a<br>nd6 options=201&lt;PERFORMNUD,DAD&gt;<br>media: autoselect (none)<br>status: inactive<br>bridge0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=63&lt;RXCSUM,TXCSUM,TSO4,TSO6&gt;<br>ether 82:23:4a:a0:88:01<br>Configuration:<br>id 0:0:0:0:0:0 priority 0 hellotime 0 fwddelay 0<br>maxage 0 holdcnt 0 proto stp maxaddr 100 timeout 1200<br>root id 0:0:0:0:0:0 priority 0 ifcost 0 port 0<br>ipfilter disabled flags 0x0<br>member: en1 flags=3&lt;LEARNING,DISCOVER&gt;<br>        ifmaxaddr 0 port 12 priority 0 path cost 0<br>member: en2 flags=3&lt;LEARNING,DISCOVER&gt;<br>        ifmaxaddr 0 port 11 priority 0 path cost 0<br>member: en3 flags=3&lt;LEARNING,DISCOVER&gt;<br>        ifmaxaddr 0 port 9 priority 0 path cost 0<br>member: en4 flags=3&lt;LEARNING,DISCOVER&gt;<br>        ifmaxaddr 0 port 10 priority 0 path cost 0<br>nd6 options=201&lt;PERFORMNUD,DAD&gt;<br>media: &lt;unknown <span class="hljs-built_in">type</span>&gt;<br>status: inactive<br>utun0: flags=8051&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu 1380<br>inet6 fe80::cdc3:569c:b8e5:27cd%utun0 prefixlen 64 scopeid 0xf<br>nd6 options=201&lt;PERFORMNUD,DAD&gt;<br>utun1: flags=8051&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu 2000<br>inet6 fe80::b3d5:d5dc:d9d:f593%utun1 prefixlen 64 scopeid 0x10<br>nd6 options=201&lt;PERFORMNUD,DAD&gt;<br></code></pre></td></tr></table></figure><h5 id="2｜tcpdump抓包"><a href="#2｜tcpdump抓包" class="headerlink" title="2｜tcpdump抓包"></a>2｜tcpdump抓包</h5><blockquote><p>IP数据报(20B)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo tcpdump -nx -c 2<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tcpdump: verbose output suppressed, use -v[v]... <span class="hljs-keyword">for</span> full protocol decode<br>listening on en0, link-type EN10MB (Ethernet), snapshot length 262144 bytes<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">10:25:09.140340 <br>IP 120.232.214.205.22004 &gt; 192.168.3.12.53969: Flags [.], <br>ack 885193681, win 21, length 0<br>0x0000:  4504 0028 5eb6 4000 3606 d2ab 78e8 d6cd<br>0x0010:  c0a8 030c 55f4 d2d1 b856 3706 34c2 fbd1<br>0x0020:  5010 0015 539e 0000 0000 0000 0000<br></code></pre></td></tr></table></figure><blockquote><p>首部分析：</p><p>版本协议：0x4</p><p>首部长度：0x5</p><p>服务类型：04</p><p>总长度：0028</p><p>标识：5eb6</p><p>标志与片偏移：4000</p><p>生存时间：36</p><p>协议：06</p><p>首部校验和：d2ab</p><p><code> 源地址</code>78e8 d6cd</p><p>转化为二进制：01111000｜11101000｜11010110｜11001101</p><p>转化为点分十进制：</p><p><code>目的地址</code>c0a8 030c </p><p>转换为二进制：11000000｜10101000｜00000011｜00001100</p><p>转化为点分十进制：192.168.3.12<code>与192.168.3.12.53969可以对应</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">10:25:09.140420 <br>IP 192.168.3.12.53969 &gt; 120.232.214.205.22004: Flags [.], <br>ack 1, win 4096, length 0<br>0x0000:  4500 0028 0000 4000 4006 2766 c0a8 030c<br>0x0010:  78e8 d6cd d2d1 55f4 34c2 fbd1 b856 3707<br>0x0020:  5010 1000 43b2 0000<br></code></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 怎么样了解这些输出是什么</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">traceroute www.baidu.com<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"> 1  192.168.3.1 (192.168.3.1)  3.086 ms  2.898 ms  1.976 ms<br> 2  192.168.1.1 (192.168.1.1)  2.303 ms  2.396 ms  3.538 ms<br> 3  10.139.0.1 (10.139.0.1)  9.640 ms  8.780 ms  7.852 ms<br> 4  111.56.2.185 (111.56.2.185)  10.049 ms  10.867 ms  9.565 ms<br> 5  221.183.58.205 (221.183.58.205)  12.810 ms<br>    221.183.75.49 (221.183.75.49)  13.646 ms<br>    221.183.58.205 (221.183.58.205)  15.570 ms<br> 6  221.183.37.193 (221.183.37.193)  25.510 ms<br>    221.183.40.21 (221.183.40.21)  29.624 ms<br>    221.183.37.193 (221.183.37.193)  24.770 ms<br> 7  * * 221.183.49.130 (221.183.49.130)  33.833 ms<br> 8  39.156.27.5 (39.156.27.5)  23.339 ms * *<br> 9  39.156.67.73 (39.156.67.73)  35.292 ms<br>    39.156.27.1 (39.156.27.1)  33.018 ms<br>    39.156.67.53 (39.156.67.53)  28.759 ms<br>10  * * 39.156.67.81 (39.156.67.81)  38.491 ms<br>11  * * *<br></code></pre></td></tr></table></figure><blockquote><p>解析：</p><p>每一个序号代表的是一跳，每跳表示一个网关</p><ul><li><input disabled="" type="checkbox"> 网关没有理解是什么东西？就代表的是路由器？</li></ul><p>每一跳后面的三个时间：代表的是探测数据包向每个网关发送三个数据包后，网关响应后的返回时间</p><p>使用的是华为的路由器，所以192.168.3.1表示的是华为路由器的地址，</p><p>192.168.1.1</p><p><code>192.168.1.1 IP地址是大多数无线路由器或ADSL调制解调器的默认网关。路由器可以使用多个IP主地址</code></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Base</category>
      
      <category>Experiment</category>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>408实验</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++[基础阶段刷题练习]</title>
    <link href="/2021/02/28/1_C++_CodeWars/"/>
    <url>/2021/02/28/1_C++_CodeWars/</url>
    
    <content type="html"><![CDATA[<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h4 id="1｜数值计算"><a href="#1｜数值计算" class="headerlink" title="1｜数值计算"></a>1｜数值计算</h4><blockquote><p>1、浮点数与整数的计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a=<span class="hljs-number">8</span>,b=<span class="hljs-number">10</span>;<br><span class="hljs-keyword">float</span> result;<br>result = a/b;<span class="hljs-comment">//输出还是int类型，输出结果为0</span><br>result = (<span class="hljs-keyword">float</span>) a / (<span class="hljs-keyword">float</span>) b;<span class="hljs-comment">//这个为想要的结果</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="2｜字符串操作"><a href="#2｜字符串操作" class="headerlink" title="2｜字符串操作"></a>2｜字符串操作</h4><blockquote><p>字符串操作题目类型:</p><p>1、统计字符串中的数字个数、特殊字符个数以及字母个数</p></blockquote><blockquote><p>2、cin 和 fgets的区别</p><ul><li>声明为string使用cin输入</li><li>声明为char str[n]，使用fgets输入；如果声明为string使用fgets输入的话，会报错<code>不存在从 &quot;std::__1::string&quot; 到 &quot;char *&quot; 的适当转换函数C/C++(413)</code></li></ul></blockquote><blockquote><p>3、使用cin、getline等输入方法</p></blockquote><blockquote><p>4、字符串添加操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">string</span> str1,str2;<br><span class="hljs-keyword">int</span> len = str.size();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>  str2 += str1[i]+str1[(i+<span class="hljs-number">1</span>) % len]; <span class="hljs-comment">//字符串可以直接的添加操作，但是数组不可以</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>5、正则表达式</p><ul><li>检查一个字符串中是否包含某种形式的子串</li><li>将匹配的子串替换</li><li>从某个串中取出符合条件的子串</li><li><code>参考文件</code>：<a href="https://www.cnblogs.com/xiaofeiIDO/p/7892185.html">https://www.cnblogs.com/xiaofeiIDO/p/7892185.html</a></li></ul><p>正则表达式中主要在于是把握子串的形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">regex <span class="hljs-title">rx</span> <span class="hljs-params">(<span class="hljs-string">&quot;\\b&quot;</span> + sub + <span class="hljs-string">&quot;\\b&quot;</span>)</span></span>;    <span class="hljs-comment">//需要进行替换的子串</span><br><span class="hljs-built_in">string</span> ans = regex_replace(str,rx,rep);    <span class="hljs-comment">//将str中符合rx要求的子串替换为rep，保存到ans中</span><br><span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt;<span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure></blockquote><h4 id="3｜数组操作"><a href="#3｜数组操作" class="headerlink" title="3｜数组操作"></a>3｜数组操作</h4><blockquote><p>1、下标的转换与数组的首地址和地址操作，下标转换需要一定的积累，多刷题，掌握下标转换的一些技巧。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//遍历仅含a-z的字符串，统计每个字符的数目</span><br><span class="hljs-comment">//通过数量关系转换为数组下标</span><br><span class="hljs-keyword">int</span> count[<span class="hljs-number">26</span>];<br><span class="hljs-built_in">string</span> str;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;str[i] == <span class="hljs-string">&#x27;\0&#x27;</span>;i++)<br>count[str[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br><span class="hljs-comment">//此时，count的下标为str[i] - &#x27;a&#x27;即a的数目存储在count[0]中，以此类推</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>2、如果要进行两个字符串数组操作，如将其中一个字符串数组的元素进行拷贝，增加空格等操作；那么需要设置两个参数<code>int i  |  int j</code>分别对两个数组进行操作；因为可能存在不同步的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//对应的字符串增加空格</span><br><span class="hljs-comment">//增加相应的参数，理解为双指针</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;str1[i] &amp;&amp; str1[i] != <span class="hljs-string">&#x27;\n&#x27;</span>;i++,j+=<span class="hljs-number">2</span>)<br>&#123;<br>  str2[j] = str1[i];<br>  str2[j+<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="4｜基本算法思路"><a href="#4｜基本算法思路" class="headerlink" title="4｜基本算法思路"></a>4｜基本算法思路</h4><blockquote><p>1、字符加密，字符轮回偏移</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//首先要得出偏移量+偏移基础</span><br><span class="hljs-comment">//轮回使用取模运算</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c:s)<br>  <span class="hljs-keyword">if</span>(c &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)c = (c-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>) % <span class="hljs-number">26</span> + <span class="hljs-string">&#x27;a&#x27;</span>;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>2、第一类双指针算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)<br>&#123;<br>  <span class="hljs-keyword">int</span> j = i;<br><span class="hljs-keyword">while</span>(j&lt;str.size() &amp;&amp; str[i] == str[j])j++;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  需要进行的操作</span><br><span class="hljs-comment">  */</span><br>i = j+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>3、做算法题要有逆向思维，比如求子串的循环次数，从字符串入手比较复杂，那么考虑从循环次数入手。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Base</category>
      
      <category>Grammar</category>
      
      <category>Code</category>
      
      <category>Practise</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++_Grammar</title>
    <link href="/2021/02/28/0_C++_Grammar/"/>
    <url>/2021/02/28/0_C++_Grammar/</url>
    
    <content type="html"><![CDATA[<h3 id="C-String操作—-fgets-｜fputs（）"><a href="#C-String操作—-fgets-｜fputs（）" class="headerlink" title="C++|String操作—-fgets()｜fputs（）"></a>C++|String操作—-fgets()｜fputs（）</h3><h4 id="1｜读与写"><a href="#1｜读与写" class="headerlink" title="1｜读与写"></a>1｜读与写</h4><p><code>fgets|scanf|fscanf|sscanf|gets|fputs｜cin</code></p><p><code>输入的方法比较多，实践后慢慢补全</code></p><h5 id="1｜fgets-读入字符串"><a href="#1｜fgets-读入字符串" class="headerlink" title="1｜fgets 读入字符串"></a>1｜fgets 读入字符串</h5><ul><li><p>Reads at most <code>count - 1</code> characters from the given file stream and stores them in the character array pointed to by <code>str</code>. Parsing stops if a newline character is found, in which case <code>str</code> will contain that newline character, or if end-of-file occurs. If bytes are read and no errors occur, writes a null character at the position immediately after the last character written to <code>str</code>.</p></li><li><p>fgets() 函数用来从指定的文件中读取一个字符串，并保存到字符数组中</p></li><li><p>fgets是将<code>std::FILE* stream</code>读取到<code>char* str</code>中，如果是没有超过<code>count</code>的话</p></li><li><p>fgets会读取回车<code>\n</code>，所以在计算字符串长度的时候需要增加边界条件<code>str[i] != &#39;\n&#39;</code>,但是fgets遇到</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">fgets</span><span class="hljs-params">( <span class="hljs-keyword">char</span>* str, <span class="hljs-keyword">int</span> count, <span class="hljs-built_in">std</span>::FILE* stream ）</span></span><br></code></pre></td></tr></table></figure><table><thead><tr><th>str</th><th>-</th><th>pointer to an element of a char array（指向数组的指针｜数组名字）</th></tr></thead><tbody><tr><td><strong>count</strong></td><td><strong>-</strong></td><td><strong>maximum number of characters to write (typically the length of <code>str</code>)（字符串允许输入的最大长度）</strong></td></tr><tr><td><strong>stream</strong></td><td><strong>-</strong></td><td><strong>file stream to read the data from（数据的输入形式）</strong></td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">std</span>::FILE* tmpf = <span class="hljs-built_in">std</span>::tmpfile();<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;Alan Turing\n&quot;</span>, tmpf);<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;John von Neumann\n&quot;</span>, tmpf);<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;Alonzo Church\n&quot;</span>, tmpf);<br> <br>    <span class="hljs-built_in">std</span>::rewind(tmpf);<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">8</span>];<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">std</span>::fgets(buf, <span class="hljs-keyword">sizeof</span> buf, tmpf) != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&#x27;&quot;&#x27;</span> &lt;&lt; buf &lt;&lt; <span class="hljs-string">&#x27;&quot;&#x27;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>fgets通常配合fopen、puts进行文件内容的输出</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* fgets example */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   FILE * pFile;<br>   <span class="hljs-keyword">char</span> mystring [<span class="hljs-number">100</span>];<br><br>   pFile = fopen (<span class="hljs-string">&quot;myfile.txt&quot;</span> , <span class="hljs-string">&quot;r&quot;</span>);<br>   <span class="hljs-keyword">if</span> (pFile == <span class="hljs-literal">NULL</span>) perror (<span class="hljs-string">&quot;Error opening file&quot;</span>);<br>   <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-keyword">if</span> ( fgets (mystring , <span class="hljs-number">100</span> , pFile) != <span class="hljs-literal">NULL</span> )<br>       <span class="hljs-built_in">puts</span> (mystring);<br>     fclose (pFile);<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> fgets输入到字符串中长度是否包含<code>&#39;\0&#39;</code></li><li><input disabled="" type="checkbox"> 一个文件的结束标记是什么？fgets如何读取出整个文件的内容，包括<code>&#39;\n&#39;</code>等内容</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* fgets example</span><br><span class="hljs-comment"> 可以输出myfile.txt中的全部内容</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   FILE * pFile;<br>   <span class="hljs-keyword">char</span> mystring [<span class="hljs-number">100</span>];<br><br>   pFile = fopen (<span class="hljs-string">&quot;myfile.txt&quot;</span> , <span class="hljs-string">&quot;r&quot;</span>);<br>   <span class="hljs-keyword">if</span> (pFile == <span class="hljs-literal">NULL</span>) perror (<span class="hljs-string">&quot;Error opening file&quot;</span>);<br>   <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-keyword">while</span> ( fgets (mystring , <span class="hljs-number">100</span> , pFile) != <span class="hljs-literal">NULL</span> )<br>       <span class="hljs-built_in">puts</span> (mystring);<br>     fclose (pFile);<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2｜fputs-写入字符串"><a href="#2｜fputs-写入字符串" class="headerlink" title="2｜fputs()写入字符串"></a>2｜fputs()写入字符串</h5><ul><li>Writes every character from the null-terminated string <code>str</code> to the output stream <code>stream</code>, as if by repeatedly executing [std::fputc](dfile:///Users/uoruichi/Library/Application Support/Dash/DocSets/C++/C++.docset/Contents/Resources/Documents/en.cppreference.com/w/cpp/io/c/fputc.html).</li><li>fputs() 函数用来向指定的文件写入一个字符串；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fputs</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str, [<span class="hljs-built_in">std</span>::FILE]</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> rc = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;Hello World&quot;</span>, <span class="hljs-built_in">stdout</span>);<span class="hljs-comment">//向stdout写入字符串</span><br> <br>    <span class="hljs-keyword">if</span> (rc == EOF)<br>       <span class="hljs-built_in">std</span>::perror(<span class="hljs-string">&quot;fputs()&quot;</span>); <span class="hljs-comment">// POSIX requires that errno is set</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 实现将vs code的输出保存为txt文件，相当于输出日志</li></ul>]]></content>
    
    
    <categories>
      
      <category>Base</category>
      
      <category>Grammar</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
