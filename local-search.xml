<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++_Acwing</title>
    <link href="/2021/03/16/C-Acwing/"/>
    <url>/2021/03/16/C-Acwing/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>环境搭建常见问题</title>
    <link href="/2021/03/12/2_%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2021/03/12/2_%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="环境搭建常见问题及处理"><a href="#环境搭建常见问题及处理" class="headerlink" title="环境搭建常见问题及处理"></a>环境搭建常见问题及处理</h3><h4 id="1｜VS-Code配置C-的debug"><a href="#1｜VS-Code配置C-的debug" class="headerlink" title="1｜VS Code配置C++的debug"></a>1｜VS Code配置C++的debug</h4><p><code>mac OS</code></p><h5 id="问题1-无法在vs-code的内置终端中进行输入，也就是会出现终端将被任务重用，按任意键关闭，而且不启动外部终端，即使启动外部终端也无法读入输入。"><a href="#问题1-无法在vs-code的内置终端中进行输入，也就是会出现终端将被任务重用，按任意键关闭，而且不启动外部终端，即使启动外部终端也无法读入输入。" class="headerlink" title="问题1:无法在vs code的内置终端中进行输入，也就是会出现终端将被任务重用，按任意键关闭，而且不启动外部终端，即使启动外部终端也无法读入输入。"></a>问题1:无法在vs code的内置终端中进行输入，也就是会出现终端将被任务重用，按任意键关闭，而且不启动外部终端，即使启动外部终端也无法读入输入。</h5><blockquote><p>问题原因：The issue is when VSCode launches the debug adapter, then the debug adapter launches <code>lldb-mi</code>, then <code>lldb-mi</code> launches <code>Terminal</code>. There is a prompt that should appear, but somehow the DebugAdapter is not forwarding this permissions request.</p><p>解决方法：因为vscode的macos版本目前还不支持C++的debug的内置终端输入，所以要启动自带的终端进行调试的输入。按照官方文档配置launch.json和tasks.json文件，然后在tasks.json文件中加入启动外部终端的代码块。</p><p><code>launch.json配置</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>    <span class="hljs-comment">// 使用 IntelliSense 了解相关属性。 </span><br>    <span class="hljs-comment">// 悬停以查看现有属性的描述。</span><br>    <span class="hljs-comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span><br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.2.0&quot;</span>,<br>    <span class="hljs-string">&quot;configurations&quot;</span>: [<br>        &#123;<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;g++-10 - 生成和调试活动文件&quot;</span>,<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;cppdbg&quot;</span>,<br>            <span class="hljs-string">&quot;request&quot;</span>: <span class="hljs-string">&quot;launch&quot;</span>,<br>            <span class="hljs-string">&quot;program&quot;</span>: <span class="hljs-string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span>,<br>            <span class="hljs-string">&quot;args&quot;</span>: [],<br>            <span class="hljs-string">&quot;stopAtEntry&quot;</span>: <span class="hljs-literal">false</span>,<br>            <span class="hljs-string">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,<br>            <span class="hljs-string">&quot;environment&quot;</span>: [],<br>            <span class="hljs-string">&quot;externalConsole&quot;</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-string">&quot;MIMode&quot;</span>: <span class="hljs-string">&quot;lldb&quot;</span>,<br>            <span class="hljs-string">&quot;preLaunchTask&quot;</span>: <span class="hljs-string">&quot;C/C++: g++-10 生成活动文件&quot;</span><br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p><code>tasks.json配置</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>    <span class="hljs-string">&quot;tasks&quot;</span>: [<br>        &#123;<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;cppbuild&quot;</span>,<br>            <span class="hljs-string">&quot;label&quot;</span>: <span class="hljs-string">&quot;C/C++: g++-10 生成活动文件&quot;</span>,<br>            <span class="hljs-string">&quot;command&quot;</span>: <span class="hljs-string">&quot;/usr/local/bin/g++-10&quot;</span>,<br>            <span class="hljs-string">&quot;args&quot;</span>: [<br>                <span class="hljs-string">&quot;-g&quot;</span>,<br>                <span class="hljs-string">&quot;$&#123;file&#125;&quot;</span>,<br>                <span class="hljs-string">&quot;-o&quot;</span>,<br>                <span class="hljs-string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span><br>            ],<br>            <span class="hljs-string">&quot;options&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><br>            &#125;,<br>            <span class="hljs-string">&quot;problemMatcher&quot;</span>: [<br>                <span class="hljs-string">&quot;$gcc&quot;</span><br>            ],<br>            <span class="hljs-string">&quot;group&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;kind&quot;</span>: <span class="hljs-string">&quot;build&quot;</span>,<br>                <span class="hljs-string">&quot;isDefault&quot;</span>: <span class="hljs-literal">true</span><br>            &#125;,<br>            <span class="hljs-string">&quot;detail&quot;</span>: <span class="hljs-string">&quot;调试器生成的任务。&quot;</span><br>        &#125;,<br><span class="hljs-comment">//需要在tasks的内容中增加以下的代码块以启动终端</span><br>        &#123;<br>            <span class="hljs-string">&quot;label&quot;</span>: <span class="hljs-string">&quot;Open Terminal&quot;</span>,<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>,<br>            <span class="hljs-string">&quot;command&quot;</span>: <span class="hljs-string">&quot;osascript -e &#x27;tell application \&quot;Terminal\&quot;\ndo script \&quot;echo hello\&quot;\nend tell&#x27;&quot;</span>,<br>            <span class="hljs-string">&quot;problemMatcher&quot;</span>: []<br>          &#125;<br>    ],<br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;2.0.0&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>配置完tasks.json文件后</p><p>1、You can run this specific task using <code>Command + Shift + p</code>. </p><p>2、Type <code>Tasks</code> and look for <code>Tasks: Run Tasks</code> then select <code>Open Terminal</code>.</p><p>Once you allow this permission, then the external console should appear when you debug.</p><p>成功配置后进行debug显示：</p><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-12-003807.png" alt="image-20210312083804302"></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>VSCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python语法</title>
    <link href="/2021/03/10/1_Python%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/03/10/1_Python%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h4 id="0｜目标"><a href="#0｜目标" class="headerlink" title="0｜目标"></a>0｜目标</h4><ul><li><input disabled="" type="checkbox"> 实验楼中的python百题冲关学习完成</li><li><input disabled="" type="checkbox"> 实验楼中的pandas百题冲关学习完成</li><li><input disabled="" type="checkbox"> 实验楼中的NumPy百题冲关学习完成</li></ul><h4 id="1｜字符串string"><a href="#1｜字符串string" class="headerlink" title="1｜字符串string"></a>1｜字符串string</h4><h5 id="1｜基本操作"><a href="#1｜基本操作" class="headerlink" title="1｜基本操作"></a>1｜基本操作</h5><blockquote><p>1、<code>split()|join()</code></p><p><code>str.split(&#39;char&#39;)</code> : 其中str为待操作的字符串，参数char为以什么字符分割</p><p><code>str.join(iterable)</code> : str为在迭代对象<code>iterable</code>的各个成员之间添加的字符。</p><p>2、生成器：在Python中，这种一边循环一边计算的机制，称为<strong>生成器</strong>：generator。</p><p>3、迭代器：</p><p>我们已经知道，可以直接作用于<code>for</code>循环的数据类型有以下几种：一类是集合数据类型，如<code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code>、<code>str</code>等；一类是<code>generator</code>，包括生成器和带<code>yield</code>的generator function。这些可以直接作用于<code>for</code>循环的对象统称为可迭代对象：<code>Iterable</code>。可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterable</code>对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#return 返回时一个string类型变量</span><br><span class="hljs-comment"># 字符串切片</span><br><span class="hljs-comment"># 字符串逆序输出</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse_words</span>(<span class="hljs-params"><span class="hljs-built_in">str</span></span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>.join(s[::-<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>.split(<span class="hljs-string">&#x27; &#x27;</span>))<br>  <br>  <br>s = <span class="hljs-string">&quot;This is an example!&quot;</span><br><span class="hljs-comment"># 实现字符串的分割</span><br>s1 = s.split(<span class="hljs-string">&#x27; &#x27;</span>)<br>print(<span class="hljs-built_in">type</span>(s1))<br><span class="hljs-comment"># &lt;class &#x27;list&#x27;&gt;</span><br><br><span class="hljs-comment"># 生成器</span><br><span class="hljs-comment"># 生成器中的item是str类型的，并且实现将item逆序</span><br>s2 = (item[::-<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> s1)<br>print(<span class="hljs-built_in">type</span>(s2))<br><span class="hljs-comment"># &lt;class &#x27;generator&#x27;&gt;</span><br>print(<span class="hljs-built_in">type</span>(item))<br><span class="hljs-comment"># &lt;class &#x27;str&#x27;&gt;</span><br><br><br><span class="hljs-comment"># string的join方法</span><br><span class="hljs-comment"># str.join()函数操作的成员要求是可迭代对象，生成器也是可迭代对象。</span><br>s3 = <span class="hljs-string">&#x27; &#x27;</span>.join(item[::-<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> s.split(<span class="hljs-string">&#x27; &#x27;</span>))<br>print(s3)<br><span class="hljs-comment"># sihT si na !elpmaxe</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="2｜list操作"><a href="#2｜list操作" class="headerlink" title="2｜list操作"></a>2｜list操作</h4><h5 id="1｜count-操作"><a href="#1｜count-操作" class="headerlink" title="1｜count 操作"></a>1｜count 操作</h5><blockquote><p>1、筛选list中满足条件的值，并返回值的数量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count_sheeps</span>(<span class="hljs-params">arrayOfSheeps</span>):</span><br>  <span class="hljs-keyword">return</span> arrayOfSheeps.count(<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 返回 list中值为True的数量</span><br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
      <category>Base</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>grammar</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0_C++_小型项目</title>
    <link href="/2021/03/10/0_C++%E5%B0%8F%E5%9E%8B%E9%A1%B9%E7%9B%AE/"/>
    <url>/2021/03/10/0_C++%E5%B0%8F%E5%9E%8B%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="C-实现监控和运动检测"><a href="#C-实现监控和运动检测" class="headerlink" title="C++ 实现监控和运动检测"></a>C++ 实现监控和运动检测</h3><p><code>Makefile|OOP|OpenGL GLUT</code></p><h4 id="1｜环境配置"><a href="#1｜环境配置" class="headerlink" title="1｜环境配置"></a>1｜环境配置</h4><h5 id="1｜安装opencv"><a href="#1｜安装opencv" class="headerlink" title="1｜安装opencv"></a>1｜安装opencv</h5><blockquote><p>1、使用brew 安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install opencv<br></code></pre></td></tr></table></figure><p>2、安装完成后需要添加部分内容到<code>.zshrc</code>中，按照要求进行添加</p><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-10-073515.png" alt="image-20210310153515559"></p><p>3、测试安装是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install opencv-python<br></code></pre></td></tr></table></figure><p>4、安装完成后，使用python测试，测试显示安装成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3 <br>import cv2<br><span class="hljs-built_in">print</span>(cv2.__version__)<br></code></pre></td></tr></table></figure><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-10-073748.png" alt="image-20210310153748185"></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>小型项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>小型项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python爬虫</title>
    <link href="/2021/03/09/1_Python%E7%88%AC%E8%99%AB/"/>
    <url>/2021/03/09/1_Python%E7%88%AC%E8%99%AB/</url>
    
    <content type="html"><![CDATA[<hr><p>[TOC]</p><h3 id="0｜目标"><a href="#0｜目标" class="headerlink" title="0｜目标"></a>0｜目标</h3><ul><li><input disabled="" type="checkbox"> 完成蓝桥的11节课程</li><li><input disabled="" type="checkbox"> 爬取2020年经济学人的文章标题</li><li><input disabled="" type="checkbox"> 爬取链家的房价数据</li><li><input disabled="" type="checkbox"> 爬取小木虫的调剂信息，并保存在excel中</li><li><input disabled="" type="checkbox"> 爬取一个感兴趣的微信公众号</li><li><input disabled="" type="checkbox"> 爬取习大大重要讲话的文章，并按照关键字进行提取内容</li><li><input disabled="" type="checkbox"> 爬取B站的弹幕实现词云图片</li></ul><h3 id="1｜爬虫实现的原理以及简单步骤"><a href="#1｜爬虫实现的原理以及简单步骤" class="headerlink" title="1｜爬虫实现的原理以及简单步骤"></a>1｜爬虫实现的原理以及简单步骤</h3><blockquote><p>写爬虫就是通过python程序模拟HTTP协议，通过python中的编程技巧，让网站的服务器通过HTTP协议返回给写好的解析程序，然后将部分有用的数据通过筛选，然后存储到本地。</p></blockquote><h4 id="1｜http协议与https协议"><a href="#1｜http协议与https协议" class="headerlink" title="1｜http协议与https协议"></a>1｜http协议与https协议</h4><blockquote><p>HTTP协议的消息结构：客户端请求消息，服务器响应消息</p><p>客户端的请求消息就是请求报文，服务器的响应消息就是响应报文。</p><p>请求报文（request)：状态行、消息报头、空行、响应正文</p><p>响应报文（response)：请求头、请求数据、响应正文</p></blockquote><h5 id="1｜requsest"><a href="#1｜requsest" class="headerlink" title="1｜requsest"></a>1｜requsest</h5><blockquote><p>request url：请求地址</p><p>request method:请求方法</p><p>status code:状态码</p><p>remote address：当前HTTP请求的远程地址</p><p>reference policy：用于设置referrer策略<code>不知道怎么用</code></p></blockquote><h5 id="2｜request-header"><a href="#2｜request-header" class="headerlink" title="2｜request header"></a>2｜request header</h5><blockquote></blockquote><h4 id="2｜浏览器与服务器"><a href="#2｜浏览器与服务器" class="headerlink" title="2｜浏览器与服务器"></a>2｜浏览器与服务器</h4><h5 id="1｜浏览器的工作原理"><a href="#1｜浏览器的工作原理" class="headerlink" title="1｜浏览器的工作原理"></a>1｜浏览器的工作原理</h5><blockquote><ul><li>请说说从你在浏览器地址栏输入网站到你看到网页中间都发生了什么？</li></ul><p><a href="https://www.youtube.com/watch?v=jaPpP3cdgDQ">https://www.youtube.com/watch?v=jaPpP3cdgDQ</a></p></blockquote><h5 id="2｜URL"><a href="#2｜URL" class="headerlink" title="2｜URL"></a>2｜URL</h5><blockquote><p>一般的URL为：<a href="//%E8%AE%BF%E9%97%AE%E8%B5%84%E6%BA%90%E9%9C%80%E8%A6%81%E7%9A%84%E5%87%AD%E8%AF%81%E4%BF%A1%E6%81%AF@%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%B0%E5%9D%80:%E7%AB%AF%E5%8F%A3%E5%8F%B7/%E8%B5%84%E6%BA%90%E5%B1%82%E7%BA%A7UNIX%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E6%96%87%E4%BB%B6%E5%90%8D?%E6%9F%A5%E8%A9%A2#%E7%89%87%E6%AE%B5ID">  协议类型  </a> : //服务器地址:端口号/资源层级UNIX文件路径文件名?查詢#片段ID</p><p>其中[访问凭证信息]、[端口号]、[查询]、[片段ID]都属于选填项。</p></blockquote><blockquote><p>通常服务器为域名，有时也为ip地址</p></blockquote><blockquote><p><a href="https://www.youtube.com/watch?v=ZMjhBB17KVY">https://www.youtube.com/watch?v=ZMjhBB17KVY</a></p><p>https 为协议</p><p><a href="http://www.youtube.com/">www.youtube.com</a> 为域名</p><p>watch 为资源层级</p><p>v=ZMjhBB17KVY 为查询</p></blockquote><h5 id="3｜服务器"><a href="#3｜服务器" class="headerlink" title="3｜服务器"></a>3｜服务器</h5><blockquote><p><strong>服务器</strong>（英語：server）指：</p><ul><li>一个管理资源并为用户提供服务的计算机软件，通常分为<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8">文件服务器</a>（能使用户在其它计算机存取<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6">文件</a>），<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8">数据库服务器</a>和<a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9C%8D%E5%8A%A1%E5%99%A8">应用程序服务器</a>。</li><li>运行以上软件的<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA">计算机</a>，或稱為**<a href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E6%9C%BA_(%E7%BD%91%E7%BB%9C)">網路主機</a>**（host）。</li></ul><p>服务器与主機不同，主机是通过<a href="https://zh.wikipedia.org/wiki/%E7%B5%82%E7%AB%AF">终端</a>给用户使用的，服务器是通过网络给<a href="https://zh.wikipedia.org/wiki/%E5%AE%A2%E6%88%B7%E7%AB%AF">客户端</a>用户使用的，所以除了要擁有終端裝置，還要利用網路才能使用伺服器電腦，但用戶連上線後就能使用伺服器上的特定服務了。</p><p><a href="https://www.youtube.com/watch?v=L1O2zo3fGys">https://www.youtube.com/watch?v=L1O2zo3fGys</a></p></blockquote><h5 id="4｜DNS缓存"><a href="#4｜DNS缓存" class="headerlink" title="4｜DNS缓存"></a>4｜DNS缓存</h5><blockquote><p>为了提升域名查询效率，设计了域名缓存机制，当访问过某个网站并得到其IP后，会将其域名和IP缓存下来，下一次访问的时候，就不需要再请求域名服务器获取IP，直接使用缓存中的IP，提高了响应的速度。当然缓存是有有效时间（即TTL值）的，当过了有效时间后，再次请求网站，还是需要先请求域名解析。</p><p>baidu和google就需要使用DNS的缓存机制了</p></blockquote><h5 id="5｜Request-Headers-计算机网络应用层"><a href="#5｜Request-Headers-计算机网络应用层" class="headerlink" title="5｜Request Headers                                                                                               计算机网络应用层"></a>5｜Request Headers                                                                                               <code>计算机网络应用层</code></h5><blockquote><p>我们不断地请求一个网页数据，肯定会被检测到异常，所以我们需要考虑使用代理和Useragent。</p><p>有一些网站不喜欢被爬虫程序访问，所以会检测连接对象，如果是爬虫程序，也就是非人点击访问，它就会不让你继续访问，所以为了要让程序可以正常运行，需要隐藏自己的爬虫程序的身份。此时，我们就可以通过设置User Agent的来达到隐藏身份的目的，User Agent的中文名为用户代理，简称UA。</p><p>在HTTP的请求中使用，其实就是HTTP的请求报文</p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-10-085113.png" alt="image-20210310165113253" style="zoom:50%;" /><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-10-085235.png" alt="image-20210310165235350" style="zoom:50%;" /></blockquote><h5 id="6｜IP代理"><a href="#6｜IP代理" class="headerlink" title="6｜IP代理"></a>6｜IP代理</h5><blockquote><p>User Agent已经设置好了，但是还应该考虑一个问题，程序的运行速度是很快的，如果我们利用一个爬虫程序在网站爬取东西，一个固定IP的访问频率就会很高，这不符合人为操作的标准，因为人操作不可能在几ms内，进行如此频繁的访问。所以一些网站会设置一个IP访问频率的阈值，如果一个IP访问频率超过这个阈值，说明这个不是人在访问，而是一个爬虫程序。</p><ul><li><input disabled="" type="checkbox"> 设置IP代理</li></ul></blockquote><h5 id="7｜设置Cookie"><a href="#7｜设置Cookie" class="headerlink" title="7｜设置Cookie"></a>7｜设置Cookie</h5><blockquote><p>Http协议是无状态的，也就是说同一个人对服务器发送了两次请求，服务器没有能力知道这是否来自同一个人，因此就需要cookie来帮助服务器进行标识，因此当我们想要爬取需要登陆的网站时，我们就需要设置相应的Cookie。</p></blockquote><h5 id="8｜HTML代码"><a href="#8｜HTML代码" class="headerlink" title="8｜HTML代码"></a>8｜HTML代码</h5><blockquote><p>分别有什么用？</p><p>我们想要爬取的信息就藏在html代码中，我们可以通过解析方法提取其中我们想要的内容。如果html代码里面没有我们想要的数据，但是在网页里面却看到了，那就是浏览器通过ajax请求异步加载（偷偷下载）了那部分数据。</p><blockquote><p>CSS文件：css文件是把css代码放入一个单独盛放css的文件，css是以.css为扩展命名的，我们看到以.css为后缀的文件就是css文件。它是一种与html语言配合使用制作网页的文件，它的作用主要是控制html文章的布局，简单的说就是控制网页的显示外观。</p><p>JS文件：JavaScript 是一种解释型语言。因此，它不需要编译。JavaScript 以交互式和动态的方式呈现网页。这允许页面对事件做出反应，展示特殊效果，接受可变文本，验证数据，创建 cookie，检测用户的浏览器等。</p></blockquote></blockquote><h4 id="3｜编码与解码"><a href="#3｜编码与解码" class="headerlink" title="3｜编码与解码"></a>3｜编码与解码</h4><h3 id="2｜项目1-爬取蓝桥的全部课程标题"><a href="#2｜项目1-爬取蓝桥的全部课程标题" class="headerlink" title="2｜项目1:爬取蓝桥的全部课程标题"></a>2｜项目1:爬取蓝桥的全部课程标题</h3><h4 id="1｜使用环境"><a href="#1｜使用环境" class="headerlink" title="1｜使用环境"></a>1｜使用环境</h4><blockquote><p>使用vs code进行实现，因为是属于小项目，所以选用vs code进行编译</p></blockquote><h4 id="2｜实现Request对象"><a href="#2｜实现Request对象" class="headerlink" title="2｜实现Request对象"></a>2｜实现Request对象</h4><blockquote><p>URL：<a href="https://lanqiao-horuikidi.vercel.app/">https://lanqiao-horuikidi.vercel.app/</a></p></blockquote><h5 id="1｜requests库中get方法"><a href="#1｜requests库中get方法" class="headerlink" title="1｜requests库中get方法"></a>1｜requests库中get方法</h5><blockquote><p><code>requests库的文档</code><a href="https://requests.readthedocs.io/en/master/">https://requests.readthedocs.io/en/master/</a></p><p>get方法是发起网络请求的方法，可以在get方法中添加相关的参数，如url、headers、proxies等参数</p></blockquote><h5 id="2｜re库"><a href="#2｜re库" class="headerlink" title="2｜re库"></a>2｜re库</h5><blockquote><p>re库为python中自带的正则表达式的库，正则表达式是要好好学习一下的，因为在c++和python中都可以用到，同时以后的数据分析也可以用到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">result = re.match(<span class="hljs-string">&quot;str1&quot;</span>,<span class="hljs-string">&quot;str2&quot;</span>)<br></code></pre></td></tr></table></figure></blockquote><h4 id="3｜代码实现"><a href="#3｜代码实现" class="headerlink" title="3｜代码实现"></a>3｜代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br><span class="hljs-comment"># 定义函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_course</span>(<span class="hljs-params">url</span>):</span><br><span class="hljs-comment"># 设置请求头</span><br>    headers = &#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span> : <span class="hljs-string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 11_1_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36&#x27;</span>&#125;<br><span class="hljs-comment"># 使用get方法来发送请求</span><br>    res = requests.get(url,headers = headers)<br><span class="hljs-comment">#保存返回内容</span><br>    html_data = res.text<br><span class="hljs-comment">#   print(html_data)</span><br><span class="hljs-comment">#利用re库中的正则表达式的findall方法，查找html_data中满足正则表达式要求的内容，并返回到</span><br><span class="hljs-comment">#  results中</span><br>    results = re.findall(<span class="hljs-string">&#x27;&lt;h6 title=&quot;(.*)&quot; class=&quot;course-name&quot;&#x27;</span>,html_data)<br><span class="hljs-comment">#   print(results)</span><br><span class="hljs-comment">#利用循环将results中的结果格式化保存到文件data.txt中</span><br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> results:<br>        new_str = <span class="hljs-string">&quot;课程名:&#123;&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(item)<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./data.txt&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:<br>            f.write(new_str)<br><span class="hljs-comment">#使用python中列表数据结构保存所有的页面，通过循环结果一次爬取各个页面中的内容</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    start_urls = [<span class="hljs-string">&#x27;https://www.lanqiao.cn/courses/?page=1&#x27;</span>,]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">32</span>):<br>        start_urls.append(<span class="hljs-string">f&#x27;https://www.lanqiao.cn/courses/?page=<span class="hljs-subst">&#123;i&#125;</span>&#x27;</span>)<br>    <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> start_urls:<br>        save_course(url)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><blockquote><ul><li><p><input disabled="" type="checkbox">  python的文件操作</p></li><li><p><input disabled="" type="checkbox">  python的函数定义及使用</p></li><li><p><input disabled="" type="checkbox">  python中元组、列表、字典等数据结构的使用</p></li><li><p><input disabled="" type="checkbox">  python中的正则表达式</p></li></ul></blockquote><h3 id="3｜小米应用商店APP排行榜爬取"><a href="#3｜小米应用商店APP排行榜爬取" class="headerlink" title="3｜小米应用商店APP排行榜爬取"></a>3｜小米应用商店APP排行榜爬取</h3><p><code>HTTP协议介绍｜requests库响应体｜re库的使用｜批量的图片存储</code></p><h4 id="1｜requests库响应体"><a href="#1｜requests库响应体" class="headerlink" title="1｜requests库响应体"></a>1｜requests库响应体</h4><blockquote><ul><li>文本形式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br>res = requests.get(<span class="hljs-string">&quot;https://app.mi.com/&quot;</span>)<br><span class="hljs-comment"># python中枚举的使用</span><br><span class="hljs-keyword">if</span> res.status_code == requests.codes.ok:<br>    print(<span class="hljs-string">&quot;请求成功&quot;</span>)<br><span class="hljs-comment"># 设置响应体内容格式</span><br>res.encoding = <span class="hljs-string">&quot;utf-8&quot;</span><br><span class="hljs-comment"># 以文本的形式访问响应体</span><br>html_data = res.text<br>print(html_data)<br></code></pre></td></tr></table></figure><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-12-032505.png" alt="image-20210312112505040"></p><ul><li>字节形式：获取响应体的主要场景应用在图片获取、文件获取、视频音频获取</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br>img_url = <span class="hljs-string">&quot;https://image.baidu.com/search/detail?ct=503316480&amp;z=0&amp;ipn=d&amp;word=tupian&amp;step_word=&amp;hs=0&amp;pn=0&amp;spn=0&amp;di=8360&amp;pi=0&amp;rn=1&amp;tn=baiduimagedetail&amp;is=0%2C0&amp;istype=0&amp;ie=utf-8&amp;oe=utf-8&amp;in=&amp;cl=2&amp;lm=-1&amp;st=undefined&amp;cs=3363295869%2C2467511306&amp;os=892371676%2C71334739&amp;simid=4203536407%2C592943110&amp;adpicid=0&amp;lpn=0&amp;ln=1584&amp;fr=&amp;fmq=1615519984102_R&amp;fm=&amp;ic=undefined&amp;s=undefined&amp;hd=undefined&amp;latest=undefined&amp;copyright=undefined&amp;se=&amp;sme=&amp;tab=0&amp;width=undefined&amp;height=undefined&amp;face=undefined&amp;ist=&amp;jit=&amp;cg=&amp;bdtype=0&amp;oriquery=&amp;objurl=https%3A%2F%2Fgimg2.baidu.com%2Fimage_search%2Fsrc%3Dhttp%3A%2F%2Fa0.att.hudong.com%2F30%2F29%2F01300000201438121627296084016.jpg%26refer%3Dhttp%3A%2F%2Fa0.att.hudong.com%26app%3D2002%26size%3Df9999%2C10000%26q%3Da80%26n%3D0%26g%3D0n%26fmt%3Djpeg%3Fsec%3D1618111986%26t%3D9ce41e27eeee1e538b7f6dd2f32a3687&amp;fromurl=ippr_z2C%24qAzdH3FAzdH3Fooo_z%26e3Bfhyvg8_z%26e3Bv54AzdH3F4AzdH3Fetjo_z%26e3Brir%3Fwt1%3Dmb9l9&amp;gsm=1&amp;rpstart=0&amp;rpnum=0&amp;islist=&amp;querylist=&amp;force=undefined&quot;</span><br>res2 = requests.get(img_url)<br><span class="hljs-keyword">if</span> res2.status_code == requests.codes.ok:<br>    print(<span class="hljs-string">&quot;OK&quot;</span>)<br>html_context = res2.content<br>print(html_context)<br></code></pre></td></tr></table></figure><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-12-032603.png" alt="image-20210312112603085"></p><ul><li>json序列化</li></ul><p>报错</p><ul><li>套接字</li></ul><p>&lt;urllib3.response.HTTPResponse object at 0x7f828c02ef10&gt;</p></blockquote><h4 id="2｜代码实现"><a href="#2｜代码实现" class="headerlink" title="2｜代码实现"></a>2｜代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> time<br><span class="hljs-comment"># 请求的网址</span><br>url = <span class="hljs-string">&#x27;https://app.mi.com/topList?page=1&#x27;</span><br><span class="hljs-comment"># 设置请求头</span><br>headers = &#123;<br>    <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 11_1_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82 Safari/537.36&#x27;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_img</span>(<span class="hljs-params">img_url,name</span>):</span><br>    img_res = requests.get(url = img_url,headers = headers)<br>    <span class="hljs-keyword">if</span> img_res.status_code == requests.codes.ok:<br>        data = img_res.content<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span> (<span class="hljs-string">&quot;./icons/&#123;name&#125;.png&quot;</span>.<span class="hljs-built_in">format</span>(name = name),<span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>            f.write(data)<br>        print(<span class="hljs-string">&quot;&#123;name&#125; - 图片存储完毕&quot;</span>.<span class="hljs-built_in">format</span>(name = name))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_item</span>(<span class="hljs-params">page</span>):</span><br>    url = <span class="hljs-string">&quot;https://app.mi.com/topList?page=&#123;page&#125;&quot;</span>.<span class="hljs-built_in">format</span>(page = page)<br>    res = requests.get(url=url,headers = headers)<br>    <span class="hljs-keyword">if</span> res.status_code == requests.codes.ok:<br>        html = res.text<br>        pattern = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;&lt;li&gt;&lt;a href=&quot;/details(.*?)&quot;&gt;&lt;img data-src=&quot;(.*?)&quot; src=&quot;(.*?)&quot; alt=&quot;(.*?)&quot; width=&quot;72&quot; height=&quot;72&quot;&gt;&lt;/a&gt;&lt;h5&gt;&lt;a href=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&lt;/h5&gt;&lt;p class=&quot;(.*?)&quot;&gt;&lt;a href=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#x27;</span>)<br>        iterms = pattern.findall(html)<br>        <span class="hljs-keyword">for</span> iterm <span class="hljs-keyword">in</span> iterms:<br>            save_img(iterm[<span class="hljs-number">1</span>],iterm[<span class="hljs-number">3</span>])<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>):<br>        print(<span class="hljs-string">&quot;正在爬取第&#123;page&#125;页&quot;</span>.<span class="hljs-built_in">format</span>(page = page))<br>        get_item(page)<br>        time.sleep(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><blockquote><p>这个就属于一个小型的python爬虫了，一步一步分析</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>爬虫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>408_高数</title>
    <link href="/2021/03/09/9_408-%E9%AB%98%E6%95%B0/"/>
    <url>/2021/03/09/9_408-%E9%AB%98%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="一、极限"><a href="#一、极限" class="headerlink" title="一、极限"></a>一、极限</h3><h4 id="1｜极限基础理解"><a href="#1｜极限基础理解" class="headerlink" title="1｜极限基础理解"></a>1｜极限基础理解</h4><h4 id="2｜极限的概念"><a href="#2｜极限的概念" class="headerlink" title="2｜极限的概念"></a>2｜极限的概念</h4><h5 id="1｜泰勒公式"><a href="#1｜泰勒公式" class="headerlink" title="1｜泰勒公式"></a>1｜泰勒公式</h5><blockquote><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-15-003430.png" alt="image-20210315083425612"></p></blockquote><h4 id="3｜极限计算技巧"><a href="#3｜极限计算技巧" class="headerlink" title="3｜极限计算技巧"></a>3｜极限计算技巧</h4><h4 id="4｜错题"><a href="#4｜错题" class="headerlink" title="4｜错题"></a>4｜错题</h4><h5 id="1｜1800"><a href="#1｜1800" class="headerlink" title="1｜1800"></a>1｜1800</h5><blockquote><p>P3</p></blockquote><ul><li><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-09-133427.png" alt="image-20210309213426821" style="zoom:50%;" /></li><li><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-09-133451.png" alt="image-20210309213450849" style="zoom:50%;" /></li><li><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-09-133505.png" alt="image-20210309213504928" style="zoom:50%;" /></li></ul>]]></content>
    
    
    <categories>
      
      <category>408</category>
      
      <category>高数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Introduction to Algorithms：Sorting And Finding</title>
    <link href="/2021/03/03/0_Introduction_to_Algorithms_Sorting/"/>
    <url>/2021/03/03/0_Introduction_to_Algorithms_Sorting/</url>
    
    <content type="html"><![CDATA[<h2 id="第一部分：基础知识"><a href="#第一部分：基础知识" class="headerlink" title="第一部分：基础知识"></a>第一部分：基础知识</h2><h2 id="第二部分-：排序与顺序统计量"><a href="#第二部分-：排序与顺序统计量" class="headerlink" title="第二部分 ：排序与顺序统计量"></a>第二部分 ：排序与顺序统计量</h2><h3 id="一、排序"><a href="#一、排序" class="headerlink" title="一、排序"></a>一、排序</h3><h4 id="0｜two-pointers"><a href="#0｜two-pointers" class="headerlink" title="0｜two pointers"></a>0｜two pointers</h4><h4 id="1｜选择排序"><a href="#1｜选择排序" class="headerlink" title="1｜选择排序"></a>1｜选择排序</h4><p><code>直接选择｜胜者树｜堆</code></p><h5 id="1｜直接选择排序模版"><a href="#1｜直接选择排序模版" class="headerlink" title="1｜直接选择排序模版"></a>1｜直接选择排序模版</h5><blockquote><p>从V[i] ~V[n-1]中每轮次选取出最小的元素（或者是最小排序码<code>即数组的下标</code>）</p><p><code>Notice:</code>使用排序码也是一种编程技巧</p><p><code>KCN比较次数</code>：KCN = ${n(n-1)\over 2}$</p><p><code>RMN移动次数</code>：$RMN<del>max</del>= 3(n-1)$​</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SelectSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left;i&lt;right;i++)<br>  &#123;<br>   <span class="hljs-comment">//设置单指针，为了后续的交换使用</span><br>    <span class="hljs-keyword">int</span> k = i;<br>   <span class="hljs-comment">//从q[i]~q[right-1]中选取最小的元素，找出当前元素的最小排序码。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>;j&lt;right;j++)<span class="hljs-keyword">if</span>(q[j] &lt; q[k])k=j;<br>   <span class="hljs-comment">//边界条件，如果说存在排序码则进行交换</span><br>  <span class="hljs-keyword">if</span>(k!=i)swap(q[k],q[i]);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2｜锦标赛排序模版（使用胜者树实现）"><a href="#2｜锦标赛排序模版（使用胜者树实现）" class="headerlink" title="2｜锦标赛排序模版（使用胜者树实现）"></a>2｜锦标赛排序模版（使用胜者树实现）</h5><h5 id="3｜堆排序（使用堆结构和形成堆的算法实现）"><a href="#3｜堆排序（使用堆结构和形成堆的算法实现）" class="headerlink" title="3｜堆排序（使用堆结构和形成堆的算法实现）"></a>3｜堆排序（使用堆结构和形成堆的算法实现）</h5><h4 id="2｜插入排序"><a href="#2｜插入排序" class="headerlink" title="2｜插入排序"></a>2｜插入排序</h4><h4 id="3｜快速排序"><a href="#3｜快速排序" class="headerlink" title="3｜快速排序"></a>3｜快速排序</h4><h5 id="1｜快速排序模版"><a href="#1｜快速排序模版" class="headerlink" title="1｜快速排序模版"></a>1｜快速排序模版</h5><p><code>双指针｜边界条件判断｜时间复杂度｜TLE（超时）错误</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//此模版存在问题，做题可能会出现Time Limit Exceeded问题</span><br><span class="hljs-comment">//因为此模版式中定义起始位置为A[left],如果为递增或者是递减序列，则时间复杂度为O(n^2),而不是O（nlogn）</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Partition</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> A[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> temp = A[left];<br>  <span class="hljs-keyword">while</span>(left &lt; right)<br>  &#123;<br>    <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; A[right]&gt;temp)right--;<br>    A[left] = A[right];<br>    <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; A[left] &lt;= temp)left++;<br>    A[right] = A[left];<br>  &#125;<br>  A[left] = temp;<br>  <span class="hljs-keyword">return</span> left;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(left &lt; right)<br>  &#123;<br>    <span class="hljs-keyword">int</span> pos = Partition(A,left,right);<br>    quickSort(A,left,pos<span class="hljs-number">-1</span>);<br>    quickSort(A,pos+<span class="hljs-number">1</span>,right);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//测试通过的快速排序模版</span><br><span class="hljs-comment">//边界条件的判断比较多，所以建议在理解的基础上练熟悉模版</span><br><span class="hljs-comment">//很多算法的模版都是使用了双指针的方法进行操作的，所以双指针的使用是比较重要的，需要多加练习</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(left &gt;= right)<span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">//边界条件判断</span><br>  <span class="hljs-keyword">int</span> tmp = q[(left+right)/<span class="hljs-number">2</span>];<br>  <span class="hljs-comment">//随机取值</span><br>  <span class="hljs-keyword">int</span> i = left<span class="hljs-number">-1</span>;<br>  <span class="hljs-comment">//设置双指针</span><br>  <span class="hljs-keyword">int</span> j = right+<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(i &lt; j)<br>  <span class="hljs-comment">//循环操作，直到i与j相遇</span><br>  &#123;<br>    <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(q[i] &lt; tmp);<br>    <span class="hljs-comment">//与第7行的i取值有关</span><br>    <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(q[j] &gt; tmp);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    此处双指针已经就位，需要补入进行的操作；进行交换、对比、取出等操作。</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span>(i &lt; j)swap(q[i],q[j]);<br>    <span class="hljs-comment">//此时双指针已经就位了，需要对满足条件的数据进行操作。</span><br>  &#125;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  1、循环结束，此时i == j的；</span><br><span class="hljs-comment">  2、后续递归处理的范围是[left,j]</span><br><span class="hljs-comment">  */</span><br>  quickSort(q,left,j);<br>  <span class="hljs-comment">//递归处理前半段</span><br>  quickSort(q,j+<span class="hljs-number">1</span>,right);<br>  <span class="hljs-comment">//递归处理后半段</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 需要进行测试，调试输出</li></ul><blockquote><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-09-021013.png" alt="image-20210309100704169" style="zoom:50%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">quickSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right,<span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(left == right)   <span class="hljs-keyword">return</span> q[left];<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">int</span> i=left<span class="hljs-number">-1</span>,j=right+<span class="hljs-number">1</span>,mid = q[left+right &gt;&gt; <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span>(i &lt; j)<br>        &#123;<br>            <span class="hljs-keyword">do</span>(i++);<span class="hljs-keyword">while</span>(q[i] &lt; mid);<br>            <span class="hljs-keyword">do</span>(j--);<span class="hljs-keyword">while</span>(q[j] &gt; mid);<br>            <span class="hljs-keyword">if</span>(i &lt; j)   swap(q[i],q[j]);<br>        &#125;<br>        quickSearch(q,left,j,k);<br>        quickSearch(q,j+<span class="hljs-number">1</span>,right,k);<br>        <br>        <span class="hljs-keyword">return</span> q[k<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n,k;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br>    <br>    <span class="hljs-built_in">cout</span> &lt;&lt; quickSearch(q,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>,k);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="4｜归并排序"><a href="#4｜归并排序" class="headerlink" title="4｜归并排序"></a>4｜归并排序</h4><h5 id="0｜算法思想"><a href="#0｜算法思想" class="headerlink" title="0｜算法思想"></a>0｜算法思想</h5><blockquote><p>基于分治的思想，将整体序列分为<code>logn</code>组数据，组内数据进行排序，排序后合并；</p><p>快排：n/2｜n/4｜n/8……</p><p>归并：……｜n/8｜n/4｜n/2｜=&gt;归并为n</p><p>所以递归调用的位置不同</p><p>归并排序需要开辟新的数组，空间换时间</p></blockquote><h5 id="1｜递归实现归并排序"><a href="#1｜递归实现归并排序" class="headerlink" title="1｜递归实现归并排序"></a>1｜递归实现归并排序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(left &gt;= right)<span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">//边界条件判断，如果只有一个元素则返回</span><br>  <span class="hljs-keyword">int</span> mid = left+right &gt;&gt; <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">//设置数组下标</span><br>  mergeSort(q,left,mid);<br>  <span class="hljs-comment">//递归调用划分左区间</span><br>  mergeSort(q,mid+<span class="hljs-number">1</span>,right);<br>  <span class="hljs-comment">//递归调用划分右区间</span><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  1、递归执行完成后，相当于是序列中的q[i]和q[j]两两对比，所以在执行16-17时已经有序了</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">//设置新开辟数组的下标</span><br>  <span class="hljs-keyword">int</span> i = left;<br>  <span class="hljs-comment">//设置双指针</span><br>  <span class="hljs-keyword">int</span> j = mid+<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right)<br>  <span class="hljs-comment">//执行循环，双指针移动</span><br>    <span class="hljs-keyword">if</span>(q[i] &lt;= q[j])tmp[k++] = q[i++];<br>  <span class="hljs-comment">//给新开辟数组赋值</span><br>  <span class="hljs-keyword">else</span> tmp[k++] = q[j++];<br>  <span class="hljs-comment">//给新开辟数组赋值</span><br>  <span class="hljs-keyword">while</span>(i&lt;= mid)tmp[k++] = q[i++];<br>  <span class="hljs-comment">//将未排序的数组导入到新开辟数组中</span><br>  <span class="hljs-keyword">while</span>(j&lt;=right)tmp[k++] = q[j++];<br>  <span class="hljs-comment">//同上</span><br>  <br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left,j=<span class="hljs-number">0</span>;i&lt;=right;i++,j++)q[i] = tmp[j];<br>  <span class="hljs-comment">//将tmp拷贝到q中，也可以直接使用c++的copy函数</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-09-094303.png" alt="image-20210309174303153" style="zoom:50%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> q[N],tmp[N];<br><span class="hljs-keyword">int</span> n;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">if</span>( left &gt;= right)  <span class="hljs-keyword">return</span>;<br> <span class="hljs-keyword">int</span> mid = (left+right) &gt;&gt; <span class="hljs-number">1</span>;<br> mergeSort(q,left,mid);<br> mergeSort(q,mid+<span class="hljs-number">1</span>,right);<br><br> <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>,i=left,j=mid+<span class="hljs-number">1</span>;<br> <span class="hljs-keyword">while</span>(i&lt;=mid &amp;&amp; j &lt;= right)<br> &#123;<br>     <span class="hljs-keyword">if</span>(q[i] &lt;= q[j]) tmp[k++] = q[i++];<br>     <span class="hljs-keyword">else</span>             tmp[k++] = q[j++];<br> &#125;<br> <span class="hljs-keyword">while</span>(i&lt;=mid)   tmp[k++] = q[i++];<br> <span class="hljs-keyword">while</span>(j&lt;=right) tmp[k++] = q[j++];<br><br> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left,j=<span class="hljs-number">0</span>;i&lt;=right;i++,j++)   q[i] = tmp[j];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br> mergeSort(q,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,q[i]);<br><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-12-090059.png" alt="image-20210312170059531" style="zoom:50%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> q[N],tmp[N];<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<br><span class="hljs-comment">//注意返回值res的类型</span><br><span class="hljs-function">LL <span class="hljs-title">Inversion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(left &gt;= right)   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> mid = (left+right) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-comment">//调用递归，递归叠加</span><br>    LL res = Inversion(q,left,mid) + Inversion(q,mid+<span class="hljs-number">1</span>,right);<br>    <span class="hljs-keyword">int</span> i=left,j=mid+<span class="hljs-number">1</span>,k=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;= mid &amp;&amp; j&lt;=right)<br>        <span class="hljs-keyword">if</span>(q[i] &lt;= q[j])    tmp[k++] = q[i++];<br>        <span class="hljs-keyword">else</span>                  <br>        &#123;<br>            res += mid-i+<span class="hljs-number">1</span>;<br>            tmp[k++] = q[j++];<br>        &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid)   tmp[k++] = q[i++];<br>    <span class="hljs-keyword">while</span>(j&lt;=right) tmp[k++] = q[j++];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left,j=<span class="hljs-number">0</span>;i&lt;=right;i++,j++)    q[i] = tmp[j];<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> n;<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br>  <span class="hljs-built_in">cout</span> &lt;&lt; Inversion(q,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="2｜非递归实现归并排序"><a href="#2｜非递归实现归并排序" class="headerlink" title="2｜非递归实现归并排序"></a>2｜非递归实现归并排序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br></code></pre></td></tr></table></figure><h3 id="二、查找"><a href="#二、查找" class="headerlink" title="二、查找"></a>二、查找</h3><h4 id="1｜二分基于数组的下标进行操作"><a href="#1｜二分基于数组的下标进行操作" class="headerlink" title="1｜二分基于数组的下标进行操作"></a>1｜二分<code>基于数组的下标进行操作</code></h4><blockquote><p>严格单调的话：不存在边界问题</p><p>有重复元素存在大量边界问题会造成死循环和查找不完全</p></blockquote><h5 id="1｜基于严格单调的有序数列"><a href="#1｜基于严格单调的有序数列" class="headerlink" title="1｜基于严格单调的有序数列"></a>1｜基于严格单调的有序数列</h5><h5 id="2｜基于不严格单调的有序序列（仍为有序序列）"><a href="#2｜基于不严格单调的有序序列（仍为有序序列）" class="headerlink" title="2｜基于不严格单调的有序序列（仍为有序序列）"></a>2｜基于不严格单调的有序序列（仍为有序序列）</h5><blockquote><p>思想：</p><p>1、找到序列中第一个大于等于x的元素的位置L，以及找到第一个大于x元素位置的R，找这两个位置都要基于二分进行查找，查找出来的区间就是[L,R），返回值为lower_bound和upper_bound</p><p>2、这样的边界主要是在代码中的判断条件进行控制。</p><p>3、基于序列<code>1 2 2 3 3 3 4 5 6</code></p><ul><li>left = 0 | right = 8 | mid = 4.    ====&gt; mid的左右两侧都有3</li><li>对left和right重新赋值if(a[mid] &lt; x)   left = mid+1;else right = mid;</li><li>left = 0｜right =4 ｜mid = 2     ====&gt;mid只有右侧有3</li><li>此时a[mid] &lt; x left = mid+1=3;</li><li>left = 3 ｜right =4｜mid = 3</li><li>此时a[mid] ==x ，则right = mid = 3,不满足循环条件while（left&lt;right)</li><li>此时如果循环条件为while（left &lt;= right)，则 mid = 3｜right = 3｜left = 3那么会发生死循环，为了</li></ul><p><code>例题：</code><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-08-144339.png" alt="image-20210308224339528"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lower_bound</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right,<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> mid;<br>    <span class="hljs-keyword">while</span>(left &lt; right)<br>    &#123;<br>        mid = left+right &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(a[mid] &gt;= x) right = mid;<br>        <span class="hljs-keyword">else</span> left = mid+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">upper_bound</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right,<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> mid;<br>    <span class="hljs-keyword">while</span>(left &lt; right)<br>    &#123;<br>        mid = left + right &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(a[mid] &gt; x)  right = mid;<br>        <span class="hljs-keyword">else</span> left = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n,x,que,LB,RB;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;x);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br><br>    <span class="hljs-keyword">while</span>(x--)<br>    &#123;   <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;que);<br>        LB = lower_bound(q,<span class="hljs-number">0</span>,n,que);<br>        RB = upper_bound(q,<span class="hljs-number">0</span>,n,que);<br>        <span class="hljs-keyword">if</span>(q[LB] != que)  LB = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(q[RB] != que )  RB = <span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; LB &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>&lt;&lt; RB &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="二、高精度计算"><a href="#二、高精度计算" class="headerlink" title="二、高精度计算"></a>二、高精度计算</h3><blockquote><p>利用结构体实现</p><p>利用vector实现</p><p>比较大小</p></blockquote><h4 id="1｜高精度加法"><a href="#1｜高精度加法" class="headerlink" title="1｜高精度加法"></a>1｜高精度加法</h4><h5 id="1｜存储方式"><a href="#1｜存储方式" class="headerlink" title="1｜存储方式"></a>1｜存储方式</h5><blockquote><p>进行运算的过程中从整数的低位到高位进行枚举，因为存在进位情况</p></blockquote><h5 id="2｜算法实现"><a href="#2｜算法实现" class="headerlink" title="2｜算法实现"></a>2｜算法实现</h5><blockquote><p>实现从低到高位存储，封装在函数内部</p><p>进位处理</p><p>位数多进行存储</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;a,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; c;<br><br>    <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;a.size() || i &lt; b.size();i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i &lt; a.size())    carry += a[i];<br>        <span class="hljs-keyword">if</span>(i &lt; b.size())    carry += b[i];<br>        c.push_back(carry % <span class="hljs-number">10</span>);<br>        carry /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>( carry ) c.push_back(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; a,b,c;<br>    <span class="hljs-built_in">string</span> add1,add2;<br>    getline(<span class="hljs-built_in">cin</span>,add1);<br>    getline(<span class="hljs-built_in">cin</span>,add2);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=add1.size()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) a.push_back(add1[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=add2.size()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) b.push_back(add2[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    c = add(a,b);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=c.size()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,c[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="2｜高精度减法"><a href="#2｜高精度减法" class="headerlink" title="2｜高精度减法"></a>2｜高精度减法</h4><h4 id="3｜高精度乘法"><a href="#3｜高精度乘法" class="headerlink" title="3｜高精度乘法"></a>3｜高精度乘法</h4><h4 id="4｜高精度除法"><a href="#4｜高精度除法" class="headerlink" title="4｜高精度除法"></a>4｜高精度除法</h4><h3 id="三｜前缀与差分"><a href="#三｜前缀与差分" class="headerlink" title="三｜前缀与差分"></a>三｜前缀与差分</h3><h4 id="1｜前缀和"><a href="#1｜前缀和" class="headerlink" title="1｜前缀和"></a>1｜前缀和</h4><blockquote><p>1、前缀和简单的理解就是数列中的前n项和，实现通过<code>递推关系实现</code>，主要把握递推关系</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//前缀和数组第i项 = 原数组的[0,i-1]+第i项的和</span><br>B[<span class="hljs-number">0</span>] = A [<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)B[i] = B[i - <span class="hljs-number">1</span>] + A[i];<br><span class="hljs-comment">//如果用原数组求的话，要定义一个sum的辅助变量。</span><br><span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>&#123;<br>  sum += A[i];<br>  B[i] = sum;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>2、C++中实现前缀和</p><ul><li><input disabled="" type="checkbox"> 需要一定的模版和类的基础，所以模版和类的语法还需要练习。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;numeric&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iterator&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>&#125;; <span class="hljs-comment">// 或 std::vector&lt;int&gt;v(10, 2);</span><br> <br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;The first 10 even numbers are: &quot;</span>;<br>    <span class="hljs-built_in">std</span>::partial_sum(v.begin(), v.end(), <br>                     <span class="hljs-built_in">std</span>::ostream_iterator&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>, <span class="hljs-string">&quot; &quot;</span>));<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br> <br>    <span class="hljs-built_in">std</span>::partial_sum(v.begin(), v.end(), v.begin(), <span class="hljs-built_in">std</span>::multiplies&lt;<span class="hljs-keyword">int</span>&gt;());<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;The first 10 powers of 2 are: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : v) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="2｜二维或者是多维的前缀和"><a href="#2｜二维或者是多维的前缀和" class="headerlink" title="2｜二维或者是多维的前缀和"></a>2｜二维或者是多维的前缀和</h4><blockquote><p>1、多维前缀和的普通求解方法几乎都是基于容斥原理，就是类似概率中去重的方法。</p><p><code>Notice：注意sum[1,0] 并不是等于sum[0,j]+sum[1,0]</code></p><p>2、求子矩阵的公式很重要的。</p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-14-030535.png" alt="image-20210314110535114" style="zoom:50%;" /><p>利用公式的时候要搞清楚边界条件</p><p>例题：</p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-14-065458.png" alt="image" style="zoom:40%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">103</span>][<span class="hljs-number">103</span>];<br><span class="hljs-keyword">int</span> b[<span class="hljs-number">103</span>][<span class="hljs-number">103</span>];  <span class="hljs-comment">// 前缀和数组，相当于上文的 sum[]</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> n, m;<br>  <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br><span class="hljs-comment">//求二维的前缀和，一般前缀和边界从1开始，到n与m结束</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>      <span class="hljs-built_in">cin</span> &gt;&gt; a[i][j];<br> <span class="hljs-comment">//二维前缀和公式</span><br>      b[i][j] =<br>          b[i][j - <span class="hljs-number">1</span>] + b[i - <span class="hljs-number">1</span>][j] - b[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + a[i][j];  <br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">int</span> l = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">while</span> (l &lt;= min(n, m)) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = l; i &lt;= n; i++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = l; j &lt;= m; j++) &#123;<br><span class="hljs-comment">//利用前缀和求子矩阵的和，因为正方形为1，所以子矩阵的和 == l*l</span><br>        <span class="hljs-keyword">if</span> (b[i][j] - b[i - l][j] - b[i][j - l] + b[i - l][j - l] == l * l) &#123;<br>          ans = max(ans, l);<br>        &#125;<br>      &#125;<br>    &#125;<br>    l++;<br>  &#125;<br><br>  <span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-built_in">endl</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="3｜基于DP求高维的前缀和"><a href="#3｜基于DP求高维的前缀和" class="headerlink" title="3｜基于DP求高维的前缀和"></a>3｜基于DP求高维的前缀和</h4><h4 id="4｜树上前缀和"><a href="#4｜树上前缀和" class="headerlink" title="4｜树上前缀和"></a>4｜树上前缀和</h4><h4 id="5｜差分"><a href="#5｜差分" class="headerlink" title="5｜差分"></a>5｜差分</h4><blockquote><p>灵活使用差分数组转前缀和，以及已知一个数组求差分数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//已知差分求前缀和</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)b[i] += b[i<span class="hljs-number">-1</span>];<br><span class="hljs-comment">// 已知前缀和求差分</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adjacent</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>  b[l] += c;<br>  b[r+<span class="hljs-number">1</span>] -= c;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)adjcent(i,i,a[i]);<span class="hljs-comment">//即得到a[N]的差分数组b[N]</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>它可以维护多次对序列的一个区间加上一个数，并在最后询问某一位的数或是多次询问某一位的数。注意修改操作一定要在查询操作之前。</p><ul><li><input disabled="" type="checkbox"> 但是为什么说减少了时间复杂度？（从$O(n) ===&gt; O(1)$)，不是还得先构造差分数组？</li></ul><p>$$a_i = b_1+b_2+……+b_i$$</p><p>$$b_1 = a_1$$</p><p>$b_2 = a_2 - a_1$</p><p>$b_3 = a_3 - a_2$</p><p>$a_1 = b_1$</p><p>$a_2 = b_1+b_2$</p><p>$a_3=b_1+b_2+b_3$</p><p>$a_4 = b_1+b_2+b_3+b_4$</p><p>实现了从1开始所有的 $a_i + c$ 的操作</p><p>$b_1=b_1+c$ </p><p>$ a_1 = a_1+c $</p><p>$a_2 = a_2+c$ </p><p>$a_3 = a_3 + c$</p><p>$a_4 = a_4 +c$</p><p>实现从5开始所有的$a_i-c$的操作，既从$a_5$开始所有的和原有数组$a_{i(&gt;=5)}$保持相同，即实现了[1,4]的区间内的书全部加c的操作</p><p>$b_5 = b_5 - c$</p><p>$a_5 = b_1+c+b_2+b_3+b_4+b_5-c$</p><p>$a_5 = a_5$</p></blockquote><blockquote><p>例题：</p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-14-084913.png" alt="image-20210314164913512" style="zoom:33%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> a[N],b[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adjacent</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    b[l] += c;<br>    b[r+<span class="hljs-number">1</span>] -=c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n,m;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br><span class="hljs-comment">//  初始化b[N],即初始化差分数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)   adjacent(i,i,a[i]);<br><span class="hljs-comment">//    printf(&quot;%d &quot;,b[0]); //b[0] == 0</span><br><span class="hljs-comment">//    for(int i=1;i&lt;=n;i++)   printf(&quot;%d &quot;,b[i]);   </span><br><span class="hljs-comment">//    cout &lt;&lt; endl;</span><br><span class="hljs-comment">//利用差分的关系来实现，在区间[l,r]内添加c的操作</span><br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> l,r,c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;c);<br>        adjacent(l,r,c);<br>    &#125;<br><span class="hljs-comment">//  操作完成之后的差分数组</span><br><span class="hljs-comment">//  for(int i=1;i&lt;=n;i++)   printf(&quot;%d &quot;,b[i]);</span><br><span class="hljs-comment">//  cout &lt;&lt; endl;</span><br><span class="hljs-comment">// 将差分数组转化为前缀和数组即所得a[N]</span><br><span class="hljs-comment">// 差分和前缀和可以相互转化，前缀和数组可以转化为差分，差分可以转化为前缀和</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)   b[i] += b[i<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,b[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="6｜树上差分"><a href="#6｜树上差分" class="headerlink" title="6｜树上差分"></a>6｜树上差分</h4><h5 id="1｜点差分"><a href="#1｜点差分" class="headerlink" title="1｜点差分"></a>1｜点差分</h5><h5 id="2｜边差分"><a href="#2｜边差分" class="headerlink" title="2｜边差分"></a>2｜边差分</h5><h3 id="四｜位运算"><a href="#四｜位运算" class="headerlink" title="四｜位运算"></a>四｜位运算</h3><h3 id="五｜离散化与区间合并"><a href="#五｜离散化与区间合并" class="headerlink" title="五｜离散化与区间合并"></a>五｜离散化与区间合并</h3><h2 id="第三部分：数据结构"><a href="#第三部分：数据结构" class="headerlink" title="第三部分：数据结构"></a>第三部分：数据结构</h2><h4 id="1｜链表"><a href="#1｜链表" class="headerlink" title="1｜链表"></a>1｜链表</h4><p><code>主要实现的功能：增｜删｜改｜查</code></p><blockquote><p>在算法中要保证运算的效率，所以链表使用静态链表来实现</p></blockquote><h5 id="1｜静态链表的构造"><a href="#1｜静态链表的构造" class="headerlink" title="1｜静态链表的构造"></a>1｜静态链表的构造</h5><blockquote><p>静态链表主要采用双数组的形式，一个数组存储value，一个数组存储下标，通过对应的关系来实现。</p><ul><li><input disabled="" type="checkbox"> 先自己实现，后面利用结构体实现更加便捷</li></ul><p>$array_{value}[N]$    |    h    e    l    l      o    NULL|</p><p>$array_{index}[N]$   |    0    1    2    3    4       -1    |</p><ul><li>除了要有数组的value、index的值同时还要引入一个变量flag，作为array的下标，所以需要操作的就是三个变量。</li></ul><p>1、初始化（init）:为value数组赋值为NULL，index赋值为-1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> b[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;<br>    a[flag] = <span class="hljs-number">0</span>;<br>    b[flag] = <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>$array_{value}[N]$    |NULL|</p><p>$array_{index}[N]$    |   -1   |</p><p>2、增加元素：断链+加链</p><p>1｜头查（HeadIn）</p><p>2｜尾插（TrailIn）</p><p>3｜输入位置插入（IndexIn）</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Sorting</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法导论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP/IP-简介</title>
    <link href="/2021/03/01/9_TCP-IP/"/>
    <url>/2021/03/01/9_TCP-IP/</url>
    
    <content type="html"><![CDATA[<h3 id="一、TCP-IP-简介"><a href="#一、TCP-IP-简介" class="headerlink" title="一、TCP IP 简介"></a>一、TCP IP 简介</h3><p><code>实验环境：Linux-Ubuntu20.04｜Mac</code></p><h4 id="1｜应用模型"><a href="#1｜应用模型" class="headerlink" title="1｜应用模型"></a>1｜应用模型</h4><h4 id="2｜知识点"><a href="#2｜知识点" class="headerlink" title="2｜知识点"></a>2｜知识点</h4><h5 id="1｜IP地址"><a href="#1｜IP地址" class="headerlink" title="1｜IP地址"></a>1｜IP地址</h5><h5 id="2｜域名"><a href="#2｜域名" class="headerlink" title="2｜域名"></a>2｜域名</h5><h5 id="3｜MAC地址"><a href="#3｜MAC地址" class="headerlink" title="3｜MAC地址"></a>3｜MAC地址</h5><h5 id="4｜端口号"><a href="#4｜端口号" class="headerlink" title="4｜端口号"></a>4｜端口号</h5><blockquote><p>端口号作用：</p></blockquote><blockquote><p>常用端口号：</p></blockquote><blockquote><p>端口号实际应用：</p></blockquote><h5 id="5｜封装与分用"><a href="#5｜封装与分用" class="headerlink" title="5｜封装与分用"></a>5｜封装与分用</h5><h5 id="6｜Linux网络相关常用命令"><a href="#6｜Linux网络相关常用命令" class="headerlink" title="6｜Linux网络相关常用命令"></a>6｜Linux网络相关常用命令</h5><p><code>借助netstat命令行工具</code></p><h3 id="二、链路层"><a href="#二、链路层" class="headerlink" title="二、链路层"></a>二、链路层</h3><h4 id="1｜链路层简介"><a href="#1｜链路层简介" class="headerlink" title="1｜链路层简介"></a>1｜链路层简介</h4><p><code>知识点：控制帧的传输、以太网、PPP、SLIP与PPP、MTU</code></p><blockquote><p>以太网<code>CSMA/CD</code></p></blockquote><blockquote><p>MTU</p></blockquote><blockquote><p>PPP</p></blockquote><blockquote><p>SLIP</p></blockquote><h4 id="2｜链路层实现功能以及链路层协议"><a href="#2｜链路层实现功能以及链路层协议" class="headerlink" title="2｜链路层实现功能以及链路层协议"></a>2｜链路层实现功能以及链路层协议</h4><h5 id="1｜差错控制"><a href="#1｜差错控制" class="headerlink" title="1｜差错控制"></a>1｜差错控制</h5><h5 id="2｜反馈重发"><a href="#2｜反馈重发" class="headerlink" title="2｜反馈重发"></a>2｜反馈重发</h5><h5 id="3｜计时器"><a href="#3｜计时器" class="headerlink" title="3｜计时器"></a>3｜计时器</h5><h5 id="4｜序号"><a href="#4｜序号" class="headerlink" title="4｜序号"></a>4｜序号</h5><h5 id="5｜流量控制"><a href="#5｜流量控制" class="headerlink" title="5｜流量控制"></a>5｜流量控制</h5><h3 id="三、网络层"><a href="#三、网络层" class="headerlink" title="三、网络层"></a>三、网络层</h3><h4 id="1｜IP数据报"><a href="#1｜IP数据报" class="headerlink" title="1｜IP数据报"></a>1｜IP数据报</h4><h4 id="2｜地址划分"><a href="#2｜地址划分" class="headerlink" title="2｜地址划分"></a>2｜地址划分</h4><h4 id="3｜子网划分"><a href="#3｜子网划分" class="headerlink" title="3｜子网划分"></a>3｜子网划分</h4><h5 id="1｜子网掩码：netmask："><a href="#1｜子网掩码：netmask：" class="headerlink" title="1｜子网掩码：netmask："></a>1｜子网掩码：netmask：</h5><h4 id="4｜IP路由选择"><a href="#4｜IP路由选择" class="headerlink" title="4｜IP路由选择"></a>4｜IP路由选择</h4><h4 id="5｜NAT技术"><a href="#5｜NAT技术" class="headerlink" title="5｜NAT技术"></a>5｜NAT技术</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ifconfig eth0<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br></code></pre></td></tr></table></figure><blockquote><p>内网IP(192.168.X.X和172.16.X.X)          <code>私网地址</code></p></blockquote><h4 id="6｜IP的发展及未来"><a href="#6｜IP的发展及未来" class="headerlink" title="6｜IP的发展及未来"></a>6｜IP的发展及未来</h4><blockquote><p>IPV6</p></blockquote><h4 id="7｜实践"><a href="#7｜实践" class="headerlink" title="7｜实践"></a>7｜实践</h4><h5 id="1｜ifconfig命令详解"><a href="#1｜ifconfig命令详解" class="headerlink" title="1｜ifconfig命令详解"></a>1｜ifconfig命令详解</h5><ul><li><input disabled="" type="checkbox"> 搞清楚每一个的含义是什么，分别在网络层有什么用</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs bash">lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384<br>options=1203&lt;RXCSUM,TXCSUM,TXSTATUS,SW_TIMESTAMP&gt;<br>inet 127.0.0.1 netmask 0xff000000<br>inet6 ::1 prefixlen 128<br>inet6 fe80::1%lo0 prefixlen 64 scopeid 0x1<br>nd6 options=201&lt;PERFORMNUD,DAD&gt;<br>gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280<br>stf0: flags=0&lt;&gt; mtu 1280<br>en6: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500<br>ether ac:de:48:00:11:22<br>inet6 fe80::aede:48ff:fe00:1122%en6 prefixlen 64 scopeid 0x4<br>nd6 options=201&lt;PERFORMNUD,DAD&gt;<br>media: autoselect (100baseTX &lt;full-duplex&gt;)<br>status: active<br>ap1: flags=8802&lt;BROADCAST,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=400&lt;CHANNEL_IO&gt;<br>ether 3a:f9:d3:93:33:9f<br>media: autoselect<br>status: inactive<br>en0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=400&lt;CHANNEL_IO&gt;<br>ether 38:f9:d3:93:33:9f<br>inet 192.168.3.12 netmask 0xffffff00 broadcast 192.168.3.255<br>media: autoselect<br>status: active<br>awdl0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=400&lt;CHANNEL_IO&gt;<br>ether 3e:73:6e:0b:bb:ac<br>inet6 fe80::3c73:6eff:fe0b:bbac%awdl0 prefixlen 64 scopeid 0x7<br>nd6 options=201&lt;PERFORMNUD,DAD&gt;<br>media: autoselect<br>status: active<br>llw0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=400&lt;CHANNEL_IO&gt;<br>ether 3e:73:6e:0b:bb:ac<br>inet6 fe80::3c73:6eff:fe0b:bbac%llw0 prefixlen 64 scopeid 0x8<br>nd6 options=201&lt;PERFORMNUD,DAD&gt;<br>media: autoselect<br>status: active<br>en3: flags=8963&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=460&lt;TSO4,TSO6,CHANNEL_IO&gt;<br>ether 82:23:4a:a0:88:05<br>media: autoselect &lt;full-duplex&gt;<br>status: inactive<br>en4: flags=8963&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=460&lt;TSO4,TSO6,CHANNEL_IO&gt;<br>ether 82:23:4a:a0:88:04<br>media: autoselect &lt;full-duplex&gt;<br>status: inactive<br>en2: flags=8963&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=460&lt;TSO4,TSO6,CHANNEL_IO&gt;<br>ether 82:23:4a:a0:88:00<br>media: autoselect &lt;full-duplex&gt;<br>status: inactive<br>en1: flags=8963&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=460&lt;TSO4,TSO6,CHANNEL_IO&gt;<br>ether 82:23:4a:a0:88:01<br>media: autoselect &lt;full-duplex&gt;<br>status: inactive<br>en5: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=6467&lt;RXCSUM,TXCSUM,VLAN_MTU,TSO4,TSO6,CHANNEL_IO,PARTIAL_CSUM,ZEROINVERT_CSUM&gt;<br>ether 00:e0:4c:68:01:5a<br>nd6 options=201&lt;PERFORMNUD,DAD&gt;<br>media: autoselect (none)<br>status: inactive<br>bridge0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=63&lt;RXCSUM,TXCSUM,TSO4,TSO6&gt;<br>ether 82:23:4a:a0:88:01<br>Configuration:<br>id 0:0:0:0:0:0 priority 0 hellotime 0 fwddelay 0<br>maxage 0 holdcnt 0 proto stp maxaddr 100 timeout 1200<br>root id 0:0:0:0:0:0 priority 0 ifcost 0 port 0<br>ipfilter disabled flags 0x0<br>member: en1 flags=3&lt;LEARNING,DISCOVER&gt;<br>        ifmaxaddr 0 port 12 priority 0 path cost 0<br>member: en2 flags=3&lt;LEARNING,DISCOVER&gt;<br>        ifmaxaddr 0 port 11 priority 0 path cost 0<br>member: en3 flags=3&lt;LEARNING,DISCOVER&gt;<br>        ifmaxaddr 0 port 9 priority 0 path cost 0<br>member: en4 flags=3&lt;LEARNING,DISCOVER&gt;<br>        ifmaxaddr 0 port 10 priority 0 path cost 0<br>nd6 options=201&lt;PERFORMNUD,DAD&gt;<br>media: &lt;unknown <span class="hljs-built_in">type</span>&gt;<br>status: inactive<br>utun0: flags=8051&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu 1380<br>inet6 fe80::cdc3:569c:b8e5:27cd%utun0 prefixlen 64 scopeid 0xf<br>nd6 options=201&lt;PERFORMNUD,DAD&gt;<br>utun1: flags=8051&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu 2000<br>inet6 fe80::b3d5:d5dc:d9d:f593%utun1 prefixlen 64 scopeid 0x10<br>nd6 options=201&lt;PERFORMNUD,DAD&gt;<br></code></pre></td></tr></table></figure><h5 id="2｜tcpdump抓包"><a href="#2｜tcpdump抓包" class="headerlink" title="2｜tcpdump抓包"></a>2｜tcpdump抓包</h5><blockquote><p>IP数据报(20B)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo tcpdump -nx -c 2<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tcpdump: verbose output suppressed, use -v[v]... <span class="hljs-keyword">for</span> full protocol decode<br>listening on en0, link-type EN10MB (Ethernet), snapshot length 262144 bytes<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">10:25:09.140340 <br>IP 120.232.214.205.22004 &gt; 192.168.3.12.53969: Flags [.], <br>ack 885193681, win 21, length 0<br>0x0000:  4504 0028 5eb6 4000 3606 d2ab 78e8 d6cd<br>0x0010:  c0a8 030c 55f4 d2d1 b856 3706 34c2 fbd1<br>0x0020:  5010 0015 539e 0000 0000 0000 0000<br></code></pre></td></tr></table></figure><blockquote><p>首部分析：</p><p>版本协议：0x4</p><p>首部长度：0x5</p><p>服务类型：04</p><p>总长度：0028</p><p>标识：5eb6</p><p>标志与片偏移：4000</p><p>生存时间：36</p><p>协议：06</p><p>首部校验和：d2ab</p><p><code> 源地址</code>78e8 d6cd</p><p>转化为二进制：01111000｜11101000｜11010110｜11001101</p><p>转化为点分十进制：</p><p><code>目的地址</code>c0a8 030c </p><p>转换为二进制：11000000｜10101000｜00000011｜00001100</p><p>转化为点分十进制：192.168.3.12<code>与192.168.3.12.53969可以对应</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">10:25:09.140420 <br>IP 192.168.3.12.53969 &gt; 120.232.214.205.22004: Flags [.], <br>ack 1, win 4096, length 0<br>0x0000:  4500 0028 0000 4000 4006 2766 c0a8 030c<br>0x0010:  78e8 d6cd d2d1 55f4 34c2 fbd1 b856 3707<br>0x0020:  5010 1000 43b2 0000<br></code></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 怎么样了解这些输出是什么</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">traceroute www.baidu.com<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"> 1  192.168.3.1 (192.168.3.1)  3.086 ms  2.898 ms  1.976 ms<br> 2  192.168.1.1 (192.168.1.1)  2.303 ms  2.396 ms  3.538 ms<br> 3  10.139.0.1 (10.139.0.1)  9.640 ms  8.780 ms  7.852 ms<br> 4  111.56.2.185 (111.56.2.185)  10.049 ms  10.867 ms  9.565 ms<br> 5  221.183.58.205 (221.183.58.205)  12.810 ms<br>    221.183.75.49 (221.183.75.49)  13.646 ms<br>    221.183.58.205 (221.183.58.205)  15.570 ms<br> 6  221.183.37.193 (221.183.37.193)  25.510 ms<br>    221.183.40.21 (221.183.40.21)  29.624 ms<br>    221.183.37.193 (221.183.37.193)  24.770 ms<br> 7  * * 221.183.49.130 (221.183.49.130)  33.833 ms<br> 8  39.156.27.5 (39.156.27.5)  23.339 ms * *<br> 9  39.156.67.73 (39.156.67.73)  35.292 ms<br>    39.156.27.1 (39.156.27.1)  33.018 ms<br>    39.156.67.53 (39.156.67.53)  28.759 ms<br>10  * * 39.156.67.81 (39.156.67.81)  38.491 ms<br>11  * * *<br></code></pre></td></tr></table></figure><blockquote><p>解析：</p><p>每一个序号代表的是一跳，每跳表示一个网关</p><ul><li><input disabled="" type="checkbox"> 网关没有理解是什么东西？就代表的是路由器？</li></ul><p>每一跳后面的三个时间：代表的是探测数据包向每个网关发送三个数据包后，网关响应后的返回时间</p><p>使用的是华为的路由器，所以192.168.3.1表示的是华为路由器的地址，</p><p>192.168.1.1</p><p><code>192.168.1.1 IP地址是大多数无线路由器或ADSL调制解调器的默认网关。路由器可以使用多个IP主地址</code></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Base</category>
      
      <category>Experiment</category>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>408实验</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++[基础阶段刷题练习]</title>
    <link href="/2021/02/28/0_C++_CodeWars/"/>
    <url>/2021/02/28/0_C++_CodeWars/</url>
    
    <content type="html"><![CDATA[<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h4 id="1｜数值计算"><a href="#1｜数值计算" class="headerlink" title="1｜数值计算"></a>1｜数值计算</h4><blockquote><p>1、浮点数与整数的计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a=<span class="hljs-number">8</span>,b=<span class="hljs-number">10</span>;<br><span class="hljs-keyword">float</span> result;<br>result = a/b;<span class="hljs-comment">//输出还是int类型，输出结果为0</span><br>result = (<span class="hljs-keyword">float</span>) a / (<span class="hljs-keyword">float</span>) b;<span class="hljs-comment">//这个为想要的结果</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>2、数字字符串转换为数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">string</span> str;<br><span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; a;<br>getline(<span class="hljs-built_in">cin</span>,str);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;str.size();i++)a.push_back(str[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>3、判断是不是完全平方数</p><blockquote><p>sqrt(sq) 如果是完全</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;    </span></span><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findNextSquare</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> sq)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sqrt</span>(sq) != (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">sqrt</span>(sq))&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<br>  <span class="hljs-keyword">return</span>  <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">sqrt</span>(sq) + <span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="2｜字符串操作"><a href="#2｜字符串操作" class="headerlink" title="2｜字符串操作"></a>2｜字符串操作</h4><blockquote><p>字符串操作题目类型:</p><p>1、统计字符串中的数字个数、特殊字符个数以及字母个数</p></blockquote><blockquote><p>2、cin 和 fgets的区别</p><ul><li>声明为string使用cin输入</li><li>声明为char str[n]，使用fgets输入；如果声明为string使用fgets输入的话，会报错<code>不存在从 &quot;std::__1::string&quot; 到 &quot;char *&quot; 的适当转换函数C/C++(413)</code></li></ul></blockquote><blockquote><p>3、使用cin、getline等输入方法</p></blockquote><blockquote><p>4、字符串添加操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">string</span> str1,str2;<br><span class="hljs-keyword">int</span> len = str.size();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>  str2 += str1[i]+str1[(i+<span class="hljs-number">1</span>) % len]; <span class="hljs-comment">//字符串可以直接的添加操作，但是数组不可以</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>5、正则表达式</p><ul><li>检查一个字符串中是否包含某种形式的子串</li><li>将匹配的子串替换</li><li>从某个串中取出符合条件的子串</li><li><code>参考文件</code>：<a href="https://www.cnblogs.com/xiaofeiIDO/p/7892185.html">https://www.cnblogs.com/xiaofeiIDO/p/7892185.html</a></li></ul><p>正则表达式中主要在于是把握子串的形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">regex <span class="hljs-title">rx</span> <span class="hljs-params">(<span class="hljs-string">&quot;\\b&quot;</span> + sub + <span class="hljs-string">&quot;\\b&quot;</span>)</span></span>;    <span class="hljs-comment">//需要进行替换的子串</span><br><span class="hljs-built_in">string</span> ans = regex_replace(str,rx,rep);    <span class="hljs-comment">//将str中符合rx要求的子串替换为rep，保存到ans中</span><br><span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt;<span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure></blockquote><h4 id="3｜条件判断"><a href="#3｜条件判断" class="headerlink" title="3｜条件判断"></a>3｜条件判断</h4><blockquote><p>1、类型为bool类型的返回值</p><blockquote><p>// return xcount == oCount；直接返回判断值</p><p>// algorithm头文件中的count函数用于计数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">XO</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; str)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> xCount = <span class="hljs-built_in">std</span>::count(str.begin(), str.end(), <span class="hljs-string">&#x27;x&#x27;</span>) + <span class="hljs-built_in">std</span>::count(str.begin(), str.end(), <span class="hljs-string">&#x27;X&#x27;</span>);<br>  <span class="hljs-keyword">int</span> oCount = <span class="hljs-built_in">std</span>::count(str.begin(), str.end(), <span class="hljs-string">&#x27;o&#x27;</span>) + <span class="hljs-built_in">std</span>::count(str.begin(), str.end(), <span class="hljs-string">&#x27;O&#x27;</span>);<br>  <span class="hljs-keyword">return</span> xCount ==  oCount;<br>&#125;<br><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>2、条件判断中？ ： 的使用，主要用于简化代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">return</span> (num%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)?<span class="hljs-string">&quot;Even&quot;</span>:<span class="hljs-string">&quot;Odd&quot;</span>;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>3、</p></blockquote><h4 id="4｜头文件中的函数"><a href="#4｜头文件中的函数" class="headerlink" title="4｜头文件中的函数"></a>4｜头文件中的函数</h4><blockquote><p>1、判断最小值</p><blockquote><p>//algorithm头文件中有直接取出最小值的函数min_element</p><ul><li><input disabled="" type="checkbox"> cbegin和begin的区别是什么？</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findSmallest</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; xs)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> *<span class="hljs-built_in">std</span>::min_element(xs.cbegin(), xs.cend());<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="5｜宏定义"><a href="#5｜宏定义" class="headerlink" title="5｜宏定义"></a>5｜宏定义</h4><blockquote><p>1、宏定义的使用</p><blockquote><p>题目：一个greet函数输出hello world!</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> roses std</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> are </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> red ::</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> violets string</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> are </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> blue greet</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> this ()</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> poem &#123;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> makes return</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> no <span class="hljs-meta-string">&quot;hello world!&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> sense ;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> microwave &#125;</span><br><br><span class="hljs-comment">// Write a function &quot;greet&quot; that returns &quot;hello world!&quot; of type std::string</span><br>roses are red<br>violets are blue<br><span class="hljs-keyword">this</span> poem makes no sense<br>microwave<br></code></pre></td></tr></table></figure></blockquote><h4 id="6｜容器使用"><a href="#6｜容器使用" class="headerlink" title="6｜容器使用"></a>6｜容器使用</h4><h5 id="1｜vector"><a href="#1｜vector" class="headerlink" title="1｜vector"></a>1｜vector</h5><blockquote><p>1、vector排序:使用al头文件中的sort函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">sumTwoSmallestNumbers</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; numbers)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">std</span>::sort(numbers.begin(), numbers.end());<br>    <br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">long</span>)numbers[<span class="hljs-number">0</span>] + (<span class="hljs-keyword">long</span>)numbers[<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>2、定义一个vector的pair，并对pair内元素进行计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;utility&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">number</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;&amp; busStops)</span></span>&#123;<br>  <span class="hljs-keyword">int</span> passengers = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i: busStops)  passengers += i.first - i.second;<br>  <span class="hljs-keyword">return</span> passengers;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="2｜string"><a href="#2｜string" class="headerlink" title="2｜string"></a>2｜string</h5><blockquote><p>string中大小写转换以及find函数</p><p>toupper()函数只能对字符进行转换，而不能对全部字符串进行转换</p><p><code>toupper(char t)</code>//toupper()函数的参数为字符，而不能是字符串</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">abbrevName</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s = <span class="hljs-string">&quot;&quot;</span>;<br>  s += <span class="hljs-built_in">toupper</span>(name[<span class="hljs-number">0</span>]);<br>  s += <span class="hljs-string">&#x27;.&#x27;</span>;<br>  s += <span class="hljs-built_in">toupper</span>(name[name.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27; &#x27;</span>)+<span class="hljs-number">1</span>]);<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="3｜数组操作"><a href="#3｜数组操作" class="headerlink" title="3｜数组操作"></a>3｜数组操作</h4><blockquote><p>1、下标的转换与数组的首地址和地址操作，下标转换需要一定的积累，多刷题，掌握下标转换的一些技巧。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//遍历仅含a-z的字符串，统计每个字符的数目</span><br><span class="hljs-comment">//通过数量关系转换为数组下标</span><br><span class="hljs-keyword">int</span> count[<span class="hljs-number">26</span>];<br><span class="hljs-built_in">string</span> str;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;str[i] == <span class="hljs-string">&#x27;\0&#x27;</span>;i++)<br>count[str[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br><span class="hljs-comment">//此时，count的下标为str[i] - &#x27;a&#x27;即a的数目存储在count[0]中，以此类推</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>2、如果要进行两个字符串数组操作，如将其中一个字符串数组的元素进行拷贝，增加空格等操作；那么需要设置两个参数<code>int i  |  int j</code>分别对两个数组进行操作；因为可能存在不同步的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//对应的字符串增加空格</span><br><span class="hljs-comment">//增加相应的参数，理解为双指针</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;str1[i] &amp;&amp; str1[i] != <span class="hljs-string">&#x27;\n&#x27;</span>;i++,j+=<span class="hljs-number">2</span>)<br>&#123;<br>  str2[j] = str1[i];<br>  str2[j+<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="4｜基本算法思路"><a href="#4｜基本算法思路" class="headerlink" title="4｜基本算法思路"></a>4｜基本算法思路</h4><blockquote><p>1、字符加密，字符轮回偏移</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//首先要得出偏移量+偏移基础</span><br><span class="hljs-comment">//轮回使用取模运算</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c:s)<br>  <span class="hljs-keyword">if</span>(c &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)c = (c-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>) % <span class="hljs-number">26</span> + <span class="hljs-string">&#x27;a&#x27;</span>;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>2、第一类双指针算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)<br>&#123;<br>  <span class="hljs-keyword">int</span> j = i;<br><span class="hljs-keyword">while</span>(j&lt;str.size() &amp;&amp; str[i] == str[j])j++;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  需要进行的操作</span><br><span class="hljs-comment">  */</span><br>i = j+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>3、做算法题要有逆向思维，比如求子串的循环次数，从字符串入手比较复杂，那么考虑从循环次数入手。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Base</category>
      
      <category>Grammar</category>
      
      <category>Code</category>
      
      <category>Practise</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++_Grammar</title>
    <link href="/2021/02/28/0_C++_Grammar/"/>
    <url>/2021/02/28/0_C++_Grammar/</url>
    
    <content type="html"><![CDATA[<h3 id="1｜C-｜数组操作"><a href="#1｜C-｜数组操作" class="headerlink" title="1｜C++｜数组操作"></a>1｜C++｜数组操作</h3><h4 id="1｜C-数组长度"><a href="#1｜C-数组长度" class="headerlink" title="1｜C++数组长度"></a>1｜C++数组长度</h4><blockquote><p>在c++中没有函数直接返回数组长度的，所以使用宏定义和局部变量返回到数组长度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> c = <span class="hljs-keyword">sizeof</span>(a[]) / <span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>]);<br><span class="hljs-comment">//但是总求错，不知道为什么</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="2｜多维数组"><a href="#2｜多维数组" class="headerlink" title="2｜多维数组"></a>2｜多维数组</h4><blockquote><p>C++中二维数组默认是先行后列，a[i] [j]默认为先输出第i行，后输出第j列</p></blockquote><h3 id="2｜C-｜函数"><a href="#2｜C-｜函数" class="headerlink" title="2｜C++｜函数"></a>2｜C++｜函数</h3><h4 id="1｜作用域"><a href="#1｜作用域" class="headerlink" title="1｜作用域"></a>1｜作用域</h4><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><blockquote><p>单个模块使用（函数模块、循环与判断模块）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<span class="hljs-comment">//此时的a只哟ing与main模块中</span><br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-comment">//此时i只用于for循环模块中</span><br></code></pre></td></tr></table></figure></blockquote><h5 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h5><blockquote><p>如果没有发生重名，可以在本.cpp文件中全局使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> global = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">cout</span> &lt;&lt; global &lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">cout</span> &lt;&lt; global &lt;&lt; enld;<br>  func();<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="重名现象"><a href="#重名现象" class="headerlink" title="重名现象"></a>重名现象</h5><blockquote><p>如果全局变量和局部变量重名的话，那么当作是局部变量使用</p></blockquote><h5 id="常量的使用"><a href="#常量的使用" class="headerlink" title="常量的使用"></a>常量的使用</h5><blockquote><p>使用#define定义：只要是C++数据类型都可以使用宏来进行定义；同时宏定义还可以使用函数的形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PI 3.1415926</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NEWLINE <span class="hljs-meta-string">&#x27;\n&#x27;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//宏定义函数形式</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>使用const关键字定义：</p><p>const type(数据类型)    name（名称）</p><p><code>注意语法区别：使用define定义没有&#39;;&#39;，使用const定义有</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi= <span class="hljs-number">3.14</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> p = <span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure></blockquote><h4 id="2｜递归"><a href="#2｜递归" class="headerlink" title="2｜递归"></a>2｜递归</h4><h5 id="1｜递归实现借助堆栈"><a href="#1｜递归实现借助堆栈" class="headerlink" title="1｜递归实现借助堆栈"></a>1｜递归实现借助堆栈</h5><p>​    <code>静态存储分配｜栈内存分配｜堆内存分配</code></p><blockquote><p>c++程序在运行时，计算机的内存区被分为程序代码去、全局数据去、堆区和栈区</p></blockquote><blockquote><p>静态存储区分配：</p><p><code>使用static变量和static object（全局对象）的方式声明</code></p><p>内存在程序编译的时候就已经分配好并且存在于程序的整个运行过程</p></blockquote><ul><li><input disabled="" type="checkbox"> 程序的执行过程：编译、链接、运行</li></ul><blockquote><p>栈内存分配：</p><p>存在于某一个作用域的一块空间，如函数中的局部变量；</p></blockquote><blockquote><p>堆内存分配：</p><p>相当于是动态内存分配，通常使用new和delete关键字进行管理；堆内存空间可以由用户手动分配和释放。</p><p>堆内存的管理借助指针进行管理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> *p; <span class="hljs-comment">//定义一个指向int类型的指针p</span><br>  p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;<span class="hljs-comment">//开辟一个int大小的内存空间，指针p指向这片空间</span><br>  *p = <span class="hljs-number">6</span>;<span class="hljs-comment">//为这片空间中的变量赋值</span><br>  <span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-comment">//输出</span><br>  <span class="hljs-keyword">delete</span> p;<span class="hljs-comment">//释放内存空间</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><ul><li><input disabled="" type="checkbox"> 全局变量是静态存储分配还是堆栈类型？</li><li><input disabled="" type="checkbox"> new｜delete和malloc｜free有什么区别？</li><li><input disabled="" type="checkbox"> 递归是如何借助堆栈实现的？为什么借助了堆？还是只借助了栈？</li></ul><h4 id="3｜引用的使用"><a href="#3｜引用的使用" class="headerlink" title="3｜引用的使用"></a>3｜引用的使用</h4><blockquote><p>修改形参会影响实际参数;</p><p>引用和指针的区别：</p><ul><li>可以通过 <code>指针名=0</code> 描述一个空指针，但不存在空引用。</li><li>指针可在任何时间进行初始化操作，而引用只能在定义时进行初始化操作。</li><li>指针变量指向内存的一个存储单元；而引用只不过是原变量的一个别名而已。</li><li>定义的方式不同：应用的定义为<code>int &amp;x = i;</code>指针的定义为<code>int *s;</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i=<span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">int</span> j=<span class="hljs-number">4</span>;<br><br>    <span class="hljs-keyword">int</span> &amp;x = i;<br>    <span class="hljs-keyword">int</span> *s;<br>    s = &amp;j;<br><br>    <span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; *s &lt;&lt;<span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="4｜函数重载"><a href="#4｜函数重载" class="headerlink" title="4｜函数重载"></a>4｜函数重载</h4><blockquote><p>定义一个参数类型或者是参数个数不同的函数，当程序执行时，程序会根据参数类型和个数匹配函数。</p></blockquote><h3 id="3｜C-｜类和对象"><a href="#3｜C-｜类和对象" class="headerlink" title="3｜C++｜类和对象"></a>3｜C++｜类和对象</h3><p><code>抽象｜封装｜继承｜多态</code></p><blockquote><p>抽象：数据抽象和行为抽象，比如英雄联盟的防御塔，数据抽象就是血量是多少、防御使多少；行为抽象就是英雄进入范围后攻击</p><p>封装：对外提供ganging访问方式，内部的数据和行为进行隐藏；比如防御塔，在main函数中，直接调用防御塔这个对象就可以。</p><p>继承：通过代码复用，对子类进行具体说明；比如防御塔，二塔有一塔全部的属性和行为，但是在一塔告破后，二塔增加属性。</p><p>多态：一段程序能够处理多种类型对象的能力。多态包含：强制多态、重载多态、类型参数话多态、包含多态。<code>没理解</code></p></blockquote><h4 id="1｜类的定义"><a href="#1｜类的定义" class="headerlink" title="1｜类的定义"></a>1｜类的定义</h4><blockquote><p>对具有相同性质的对象进行抽象，找出共同的属性，构成同一类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> 类的名称：</span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">public</span>:<br>  外部接口<br>  <span class="hljs-keyword">protected</span>:<br>  保护性成员<br>  <span class="hljs-keyword">private</span>：<br>    私有成员<br>&#125;；<br></code></pre></td></tr></table></figure></blockquote><h4 id="2｜类的成员访问控制"><a href="#2｜类的成员访问控制" class="headerlink" title="2｜类的成员访问控制"></a>2｜类的成员访问控制</h4><ul><li><input disabled="" type="checkbox"> 没有掌握</li></ul><h5 id="1｜public"><a href="#1｜public" class="headerlink" title="1｜public"></a>1｜public</h5><h5 id="2｜protected"><a href="#2｜protected" class="headerlink" title="2｜protected"></a>2｜protected</h5><h5 id="3｜private"><a href="#3｜private" class="headerlink" title="3｜private"></a>3｜private</h5><h4 id="3｜对象的声明"><a href="#3｜对象的声明" class="headerlink" title="3｜对象的声明"></a>3｜对象的声明</h4><h4 id="4｜类的成员函数"><a href="#4｜类的成员函数" class="headerlink" title="4｜类的成员函数"></a>4｜类的成员函数</h4><h4 id="5｜struct基本结构体"><a href="#5｜struct基本结构体" class="headerlink" title="5｜struct基本结构体"></a>5｜struct基本结构体</h4><h5 id="1｜结构体声明"><a href="#1｜结构体声明" class="headerlink" title="1｜结构体声明"></a>1｜结构体声明</h5><h4 id="6｜类练习"><a href="#6｜类练习" class="headerlink" title="6｜类练习"></a>6｜类练习</h4><blockquote><p>声明枚举类型CPU_Rank，例如enum CPU_Rank{P1=1，P2，P3，P4，P5，P6，P7}，再声明成员函数run，stop，用来输出提示信息，在构造函数和析构函数中也可以输出提示信息。在主程序中声明一个CPU的对象，调用其成员函数，观察类对象的构造与析构顺序，以及成员函数的调用。</p></blockquote><h3 id="4｜C-基本数据类型与表达式"><a href="#4｜C-基本数据类型与表达式" class="headerlink" title="4｜C++|基本数据类型与表达式"></a>4｜C++|基本数据类型与表达式</h3><h4 id="1｜string类"><a href="#1｜string类" class="headerlink" title="1｜string类"></a>1｜string类</h4><blockquote><p>使用string头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br></code></pre></td></tr></table></figure></blockquote><h4 id="2-｜字符串操作"><a href="#2-｜字符串操作" class="headerlink" title="2 ｜字符串操作"></a>2 ｜字符串操作</h4><h4 id="1｜读与写"><a href="#1｜读与写" class="headerlink" title="1｜读与写"></a>1｜读与写</h4><p><code>fgets|scanf|fscanf|sscanf|gets|fputs｜cin</code></p><p><code>输入的方法比较多，实践后慢慢补全</code></p><h5 id="1｜fgets-读入字符串"><a href="#1｜fgets-读入字符串" class="headerlink" title="1｜fgets 读入字符串"></a>1｜fgets 读入字符串</h5><ul><li><p>Reads at most <code>count - 1</code> characters from the given file stream and stores them in the character array pointed to by <code>str</code>. Parsing stops if a newline character is found, in which case <code>str</code> will contain that newline character, or if end-of-file occurs. If bytes are read and no errors occur, writes a null character at the position immediately after the last character written to <code>str</code>.</p></li><li><p>fgets() 函数用来从指定的文件中读取一个字符串，并保存到字符数组中</p></li><li><p>fgets是将<code>std::FILE* stream</code>读取到<code>char* str</code>中，如果是没有超过<code>count</code>的话</p></li><li><p>fgets会读取回车<code>\n</code>，所以在计算字符串长度的时候需要增加边界条件<code>str[i] != &#39;\n&#39;</code>,但是fgets遇到</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">fgets</span><span class="hljs-params">( <span class="hljs-keyword">char</span>* str, <span class="hljs-keyword">int</span> count, <span class="hljs-built_in">std</span>::FILE* stream ）</span></span><br></code></pre></td></tr></table></figure><table><thead><tr><th>str</th><th>-</th><th>pointer to an element of a char array（指向数组的指针｜数组名字）</th></tr></thead><tbody><tr><td><strong>count</strong></td><td><strong>-</strong></td><td><strong>maximum number of characters to write (typically the length of <code>str</code>)（字符串允许输入的最大长度）</strong></td></tr><tr><td><strong>stream</strong></td><td><strong>-</strong></td><td><strong>file stream to read the data from（数据的输入形式）</strong></td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">std</span>::FILE* tmpf = <span class="hljs-built_in">std</span>::tmpfile();<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;Alan Turing\n&quot;</span>, tmpf);<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;John von Neumann\n&quot;</span>, tmpf);<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;Alonzo Church\n&quot;</span>, tmpf);<br> <br>    <span class="hljs-built_in">std</span>::rewind(tmpf);<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">8</span>];<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">std</span>::fgets(buf, <span class="hljs-keyword">sizeof</span> buf, tmpf) != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&#x27;&quot;&#x27;</span> &lt;&lt; buf &lt;&lt; <span class="hljs-string">&#x27;&quot;&#x27;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>fgets通常配合fopen、puts进行文件内容的输出</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* fgets example */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   FILE * pFile;<br>   <span class="hljs-keyword">char</span> mystring [<span class="hljs-number">100</span>];<br><br>   pFile = fopen (<span class="hljs-string">&quot;myfile.txt&quot;</span> , <span class="hljs-string">&quot;r&quot;</span>);<br>   <span class="hljs-keyword">if</span> (pFile == <span class="hljs-literal">NULL</span>) perror (<span class="hljs-string">&quot;Error opening file&quot;</span>);<br>   <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-keyword">if</span> ( fgets (mystring , <span class="hljs-number">100</span> , pFile) != <span class="hljs-literal">NULL</span> )<br>       <span class="hljs-built_in">puts</span> (mystring);<br>     fclose (pFile);<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> fgets输入到字符串中长度是否包含<code>&#39;\0&#39;</code></li><li><input disabled="" type="checkbox"> 一个文件的结束标记是什么？fgets如何读取出整个文件的内容，包括<code>&#39;\n&#39;</code>等内容</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* fgets example</span><br><span class="hljs-comment"> 可以输出myfile.txt中的全部内容</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   FILE * pFile;<br>   <span class="hljs-keyword">char</span> mystring [<span class="hljs-number">100</span>];<br><br>   pFile = fopen (<span class="hljs-string">&quot;myfile.txt&quot;</span> , <span class="hljs-string">&quot;r&quot;</span>);<br>   <span class="hljs-keyword">if</span> (pFile == <span class="hljs-literal">NULL</span>) perror (<span class="hljs-string">&quot;Error opening file&quot;</span>);<br>   <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-keyword">while</span> ( fgets (mystring , <span class="hljs-number">100</span> , pFile) != <span class="hljs-literal">NULL</span> )<br>       <span class="hljs-built_in">puts</span> (mystring);<br>     fclose (pFile);<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2｜fputs-写入字符串"><a href="#2｜fputs-写入字符串" class="headerlink" title="2｜fputs()写入字符串"></a>2｜fputs()写入字符串</h5><ul><li>Writes every character from the null-terminated string <code>str</code> to the output stream <code>stream</code>, as if by repeatedly executing [std::fputc](dfile:///Users/uoruichi/Library/Application Support/Dash/DocSets/C++/C++.docset/Contents/Resources/Documents/en.cppreference.com/w/cpp/io/c/fputc.html).</li><li>fputs() 函数用来向指定的文件写入一个字符串；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fputs</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str, [<span class="hljs-built_in">std</span>::FILE]</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> rc = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;Hello World&quot;</span>, <span class="hljs-built_in">stdout</span>);<span class="hljs-comment">//向stdout写入字符串</span><br> <br>    <span class="hljs-keyword">if</span> (rc == EOF)<br>       <span class="hljs-built_in">std</span>::perror(<span class="hljs-string">&quot;fputs()&quot;</span>); <span class="hljs-comment">// POSIX requires that errno is set</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 实现将vs code的输出保存为txt文件，相当于输出日志</li></ul><h5 id="3｜字符串操作函数-基于char"><a href="#3｜字符串操作函数-基于char" class="headerlink" title="3｜字符串操作函数            基于char[]"></a>3｜字符串操作函数            <code>基于char[]</code></h5><blockquote><p>在头文件<code>#include &lt;cstring&gt;</code>中有很多对字符串操作的函数；</p><p>但是只能用于<code>char str[n]</code>类型的声明，不能用于<code>string str</code>的声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> str1[<span class="hljs-number">10</span>] = <span class="hljs-string">&quot;hello&quot;</span>;<br>  <span class="hljs-keyword">char</span> str2[<span class="hljs-number">18</span>] = <span class="hljs-string">&quot;python&quot;</span>;<br>  <br>  <span class="hljs-built_in">strcat</span>(str1,str2);<br>  <span class="hljs-built_in">cout</span> &lt;&lt; str1 &lt;&lt; <span class="hljs-built_in">endl</span>;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>name</th><th>func</th></tr></thead><tbody><tr><td>函数</td><td>作用</td></tr><tr><td>strcpy(s1,s2)</td><td>复制字符串s2到s1中</td></tr><tr><td>strcat(s1,s2)</td><td>将字符串s2连接到s1的末尾</td></tr><tr><td>strlen(s)</td><td>计算字符串s的长度</td></tr><tr><td>strcmp(s1,s2)</td><td>比较字符串的长度，相同返回0；s2大的话返回-1;s1大的话返回1</td></tr><tr><td>strchr(s1,ch)</td><td>返回一个指针，指针指向ch在s1中的首个位置</td></tr><tr><td>strstr(s1,s2)</td><td>返回一个指针，指针指向s2在s1中的首位置</td></tr></tbody></table></blockquote><h5 id="4｜string类"><a href="#4｜string类" class="headerlink" title="4｜string类"></a>4｜string类</h5><blockquote><p>使用<code>string str;</code>声明的变量不是基于数组的，而是基于string类的；</p><p>对于字符串类中的str，使用‘+’号为连接</p><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-09-001200.png" alt="image-20210309081159704"></p></blockquote><h3 id="5｜C-循环与条件判断"><a href="#5｜C-循环与条件判断" class="headerlink" title="5｜C++循环与条件判断"></a>5｜C++循环与条件判断</h3><h4 id="使用三元运算符"><a href="#使用三元运算符" class="headerlink" title="使用三元运算符"></a>使用三元运算符</h4><h5 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h5><blockquote><p>使用环境：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">c = (a&gt;b) ? a:b;<br><span class="hljs-comment">//a &gt; b 为条件判断===&gt;if else结构，如果a&gt;b成立则返回a；否则返回b</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="6｜STL"><a href="#6｜STL" class="headerlink" title="6｜STL"></a>6｜STL</h3><p><code>模版编程｜泛型编程｜STL常用组件｜lambda表达式｜异常处理｜内存处理</code></p><p><code>算法｜容器｜迭代器｜适配器｜仿函数（函数对象）｜空间适配器</code></p><p><code>泛型｜模版｜oop</code></p><blockquote><p>本部分所有代码至少需要开启 -std=c++11 选项来支持 C++11 相关特性，在介绍 C++14 特性时的相关代码需要开启 -std=c++14 的编译选项；可以在使用命令行g++的时候使用<code>g++ main.cpp -std = c++ 11(14)</code>来进行操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ main.cpp -std = c++ 11(14)<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>STL的算法是基于容器进行的，是通用的算法；并不依赖一某种数据结构和对象。</p></blockquote><blockquote><p>使用迭代器完成对容器的访问，迭代器底层是由指针实现的，这也是c++和c的区别，c实现算法和数据结构都是由指针实现的；c++实现算法和数据结构是通过容器+迭代器实现的；所以是不是可以理解为c比c++更加接近底层。</p></blockquote><blockquote><p>STL的基本容器是vector、list、queue；基本容器的适配器是queue、stack</p></blockquote><blockquote><p>空间适配器就是STL自己的内存池</p></blockquote><h4 id="1｜容器"><a href="#1｜容器" class="headerlink" title="1｜容器"></a>1｜容器</h4><h5 id="1｜vector（向量—-变长数组）"><a href="#1｜vector（向量—-变长数组）" class="headerlink" title="1｜vector（向量—-变长数组）"></a>1｜vector（向量—-变长数组）</h5><p><code>邻接表的方式存储图｜解决普通数组超内存|用于处理输入数据数量不确定的情况</code></p><blockquote><p>定义vector</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">typename</span>&gt; name;<span class="hljs-comment">//定义一个typename类型的vector变量,变量名字为name</span><br><span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">array</span>;<span class="hljs-comment">//相当于定义一个int类型的array[SIZE]数组</span><br></code></pre></td></tr></table></figure><p>进阶定义</p><ul><li>定义一个vector的结构体</li><li>定义一个二维数组</li></ul></blockquote><blockquote><p>vector内元素循环访问</p><ul><li>通过下标访问</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dc++">vector &lt;int&gt; vi;<br>printf(&quot;%&quot;,vi[index]);&#x2F;&#x2F;通过index进行访问，index的范围为[0,vi.size()]，可以直接调用vi.size()输出vi数组的长度<br></code></pre></td></tr></table></figure><ul><li>通过迭代器访问，迭代器可以理解为指针，迭代器也是需要定义的，可以理解为一个变量。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; ::iterator it;<span class="hljs-comment">//得到迭代器it，it是迭代器的名字，所以可以定义为别的名字</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; vi;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)  vi.push_back(i);<br>    <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; ::iterator it = vi.begin();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<span class="hljs-comment">//迭代器使用的第一种用法</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,*(it+i));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">for</span>(it=vi.begin();it != vi.end();it++)<span class="hljs-comment">//迭代器循环的第二种用法</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,*it);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>push_back函数与pop_back函数的使用</p><p>push_back()是在vector的末尾添加x</p><p>pop_back()是删除vector的末尾元素但是不会输出删除了哪些。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; vi;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">6</span>;i++)   vi.push_back(i);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t%d\n&quot;</span>,vi[<span class="hljs-number">0</span>],vi[<span class="hljs-number">6</span>]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)    vi.pop_back();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;vi.size();i++)    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,vi[i]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>size函数，返回值为int类型，返回vector的大小</p></blockquote><blockquote><p>clear()函数，晴空vector容器</p></blockquote><blockquote><p>insert()，基于迭代器进行操作，需要添加两个参数，<code>vi.insert(it+2,-1)</code>，将-1添加到<code>vi[2]</code>的位置</p></blockquote><blockquote><p>erase()，删除区间内的元素，<code>vi.erase(it.begin(),it.end())</code>，删除元素的范围左开右闭<code>[it.begin(),it.end())</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; vi;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)  vi.push_back(i);<br>    <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; ::iterator it = vi.begin();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,*(it+i));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-comment">//  for(vector &lt;int&gt; ::iterator it = vi.begin();it != vi.end();it++)</span><br><span class="hljs-comment">//      printf(&quot;%d &quot;,*it);</span><br>    vi.erase(vi.begin(),vi.begin()+<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;vi.size();i++)    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,vi[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    vi.erase(vi.begin(),vi.end());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;vi.size();i++)    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,vi[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// output</span><br><span class="hljs-comment">// 0 1 2 3 4 </span><br><span class="hljs-comment">// 2 3 4  //经过第一次erase()，begin(),begin+2,删除的区间是[begin()+0,begin()+2)的区间</span><br><span class="hljs-comment">// //经过第二次erase(),可以看出来begin(),end()的范围的话，是全部删除</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 使用vector定义邻接表</li></ul></blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 使用完vector后，是不是不用释放空间？</li></ul></blockquote><h5 id="2｜list（列表）"><a href="#2｜list（列表）" class="headerlink" title="2｜list（列表）"></a>2｜list（列表）</h5><h5 id="3｜queue（队列）"><a href="#3｜queue（队列）" class="headerlink" title="3｜queue（队列）"></a>3｜queue（队列）</h5><h5 id="4｜deque（双端队列）"><a href="#4｜deque（双端队列）" class="headerlink" title="4｜deque（双端队列）"></a>4｜deque（双端队列）</h5><h5 id="5｜set（集合）"><a href="#5｜set（集合）" class="headerlink" title="5｜set（集合）"></a>5｜set（集合）</h5><h5 id="6｜multiset（多种集合）"><a href="#6｜multiset（多种集合）" class="headerlink" title="6｜multiset（多种集合）"></a>6｜multiset（多种集合）</h5><h5 id="7｜map（映射）"><a href="#7｜map（映射）" class="headerlink" title="7｜map（映射）"></a>7｜map（映射）</h5><h5 id="8｜multimap（多重映射）"><a href="#8｜multimap（多重映射）" class="headerlink" title="8｜multimap（多重映射）"></a>8｜multimap（多重映射）</h5><h4 id="2｜模版编程"><a href="#2｜模版编程" class="headerlink" title="2｜模版编程"></a>2｜模版编程</h4><p><code>基本语法｜模版函数｜类模版｜成员模版｜模版中的静态成员｜typename与class｜迭代器</code></p><h5 id="1｜函数模版化"><a href="#1｜函数模版化" class="headerlink" title="1｜函数模版化"></a>1｜函数模版化</h5><blockquote><p>为什么要使用模版编程的思想？</p><p>因为C++中对于数据类型区分比较明确，所以使用模版编程的话会简化工作，也就是使用模版来定义数据类型。</p><p>向 <code>add</code> 函数提供参数时，编译器会自动分析参数的类型，然后将所有用到 T 定义的换成相对性的类型。其实主要的作用在于自动分析参数的类型。这样定义的函数可以多次重复调用，而不用多次编辑。</p><p>其实也就是使用<code>template &lt;typename T&gt;</code>替换类型，再由编译器自动分析参数类型</p><p>定义：<code>template</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T lva,<span class="hljs-keyword">const</span> T rva)</span></span><br><span class="hljs-function"></span>&#123;<br>  T a;<br>  a = lva + rva;<br>  <span class="hljs-keyword">return</span> a;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">cout</span> &lt;&lt; add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br> <span class="hljs-built_in">cout</span> &lt;&lt; add(<span class="hljs-number">1.0</span>,<span class="hljs-number">2.2</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="2｜类模版化"><a href="#2｜类模版化" class="headerlink" title="2｜类模版化"></a>2｜类模版化</h5><blockquote><p>使用类模版化的前提是对类的操作要熟悉</p><p>在定义类模板的时候，常常使用 class 作为关键字，增加代码可读性。其它则用 typename，上面的代码大都遵循这样的标准，但是并无强制规定。</p></blockquote><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Myclass</span></span><br><span class="hljs-class">&#123;</span><br>  T a;<br>  <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">T <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T lva,<span class="hljs-keyword">const</span> T rva)</span></span>;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br>T Myclass &lt;T&gt;::add(<span class="hljs-keyword">const</span> T lva,<span class="hljs-keyword">const</span> T rva)<br>&#123;<br>  a = lva + rva;<br>  <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="3-迭代器"><a href="#3-迭代器" class="headerlink" title="3|迭代器"></a>3|迭代器</h5><blockquote><p>迭代器（iterator）是一种对象，它能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址。迭代器修改了常规指针的接口，所谓迭代器是一种概念上的抽象：那些行为上像迭代器的东西都可以叫做迭代器。然而迭代器有很多不同的能力，它可以把抽象容器和通用算法有机的统一起来。迭代器基本分为五种，输入输出迭代器，前向逆向迭代器，双向迭代器和随机迭代器。</p><p>迭代是重复反馈过程的活动，其目的通常是为了接近并到达所需的目标或结果。 每一次对过程的重复被称为一次“迭代”，而每一次迭代得到的结果会被用来作为下一次迭代的初始值。</p></blockquote><blockquote><p>理解：</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Base</category>
      
      <category>Grammar</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
