<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>3-Rust-Prime-ProgrammingLanguage-5-OwnerShip</title>
    <link href="/2021/04/24/3-Rust-Prime-ProgrammingLanguage-5-OwnerShip/"/>
    <url>/2021/04/24/3-Rust-Prime-ProgrammingLanguage-5-OwnerShip/</url>
    
    <content type="html"><![CDATA[<h4 id="5｜所有权、引用和借用"><a href="#5｜所有权、引用和借用" class="headerlink" title="5｜所有权、引用和借用"></a>5｜所有权、引用和借用</h4><p><code>day 4</code></p><blockquote><p>所有权建议阅读官方文档，和c++中的new和delete功能类似，但是不需要自己手动调用，编译器根据所有权规则，自动实现。</p><blockquote><ol><li>Rust 中的每一个值都有一个被称为其 <strong>所有者</strong>（<em>owner</em>）的变量。</li><li>值在任一时刻有且只有一个所有者。</li><li>当所有者（变量）离开作用域，这个值将被丢弃。</li></ol></blockquote></blockquote><blockquote><p>堆：</p><p>1、未知大小或者是大小发生变化的数据存放在堆区</p><p>2、通过指针进行访问，指针会请求足够大的内存空间用于存放数据。</p><p>栈：</p><p>1、已知大小且大小固定的数据存放在栈区</p><p>2、传递给函数的值、函数的局部变量都会压入栈中，数据的入栈和出栈遵循栈的数据结构特性，后近先出。</p><p>3、栈的数据运行相比堆要快一些。</p></blockquote><blockquote><p>内存分配</p><p>1、字面量（常量）：存放在栈区，通过硬编码方式写入程序代码中。</p><p>2、类型（String、Vector等）:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;hello,world&quot;</span>；<span class="hljs-comment">//&quot;hello,world&quot;为字面量即常量</span><br><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);<span class="hljs-comment">// 因为是定义类型是String类型，所以分配在堆上</span><br></code></pre></td></tr></table></figure><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-04-22-054303.png" alt="image-20210422134303879" style="zoom:50%;" /></blockquote><h5 id="1｜作用域和所有权"><a href="#1｜作用域和所有权" class="headerlink" title="1｜作用域和所有权"></a>1｜作用域和所有权</h5><blockquote><p>分清楚值和变量，谁有值，谁有所有权。</p><p>关键就在于弄清楚什么类型的变量会发生drop，什么类型的变量不会发生drop，以及什么时候回发生drop;</p></blockquote><blockquote><p>Rust 中的每一个值都有一个被称为其 <strong>所有者</strong>（<em>owner</em>）的变量，值在任一时刻有且只有一个所有者。</p><p>变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 <code>drop</code> 被清理掉，除非数据被移动为另一个变量所有。</p></blockquote><blockquote><p>还有就是弄清楚copy的作用，任何简单标量值的组合可以是 <code>Copy</code> 的，不需要分配内存或某种形式资源的类型是 <code>Copy</code> 的。如下是一些 <code>Copy</code> 的类型：</p><ul><li>所有整数类型，比如 <code>u32</code>。</li><li>布尔类型，<code>bool</code>，它的值是 <code>true</code> 和 <code>false</code>。</li><li>所有浮点数类型，比如 <code>f64</code>。</li><li>字符类型，<code>char</code>。</li><li>元组，当且仅当其包含的类型也都是 <code>Copy</code> 的时候。比如，<code>(i32, i32)</code> 是 <code>Copy</code> 的，但 <code>(i32, String)</code> 就不是。</li></ul></blockquote><blockquote><p>变量的作用域：</p><p>1、{    }表示一个作用域</p><p>2、基本类型的变量作为参数传给函数后，也算是进入一个新的作用域</p><p>所有权：</p><p>1、将值传递给函数在语义上与给变量赋值相似。向函数传递值可能会移动或者复制，就像赋值语句一样。任何简单标量值的组合进行复制的，不是简单标量的组合发生移动。</p><p>2、简单标量的组合</p><p>3、返回值也可以转移所有权，以及drop所有权</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-comment">// Assign ownership</span><br><br>    <span class="hljs-comment">// hello定义在栈区，但是s1是开辟在堆区的</span><br>    <span class="hljs-comment">// s1 的类型是String类型，String 类型不具有copy特征 </span><br>    <span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-comment">// s1作为变量存储值，使用赋值即发生值的所有者转移，但是标量值发生的事copy。</span><br>    <span class="hljs-keyword">let</span> s2 = s1;<br>    <span class="hljs-comment">// ## Rust 默认s1已经移动到s2中，s1已经无效；也就是说如果没用引用，在s1后进行了drop    </span><br>    <span class="hljs-comment">// let s3 = s1.clone(); Error:s1的作用域结束</span><br>    <span class="hljs-comment">// println!(&quot;&#123;&#125;&quot;,s1);   Error:s2的定义属于浅拷贝</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,s2);<br>    <span class="hljs-comment">// 使用深拷贝</span><br>    <span class="hljs-keyword">let</span> s3 = s2.clone();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,s3);<br><br>    <span class="hljs-comment">// func owership</span><br>    <span class="hljs-keyword">let</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);<br>    takes_owner_ship(s);<br>    <span class="hljs-comment">// println!(&quot;&#123;&#125;&quot;,s);    Error:s的所有权在调用完函数后已经释放，即调用了drop</span><br>    <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;<br>    makes_copy(x);<br>    <span class="hljs-comment">// 基本的数据类型：整数、浮点数、布尔值、字符、元组（由基本组成）不妨释放所有权。</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,x);   <br>    <span class="hljs-comment">// Test</span><br>    <span class="hljs-keyword">let</span> y = <span class="hljs-literal">true</span>;<br>    makes_copy2(y);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,y);<br><br><br>    <span class="hljs-comment">// return val ownership</span><br>    <span class="hljs-comment">// str1 gets ownership from return val some_string</span><br>    <span class="hljs-keyword">let</span> str1 = gives_owenership();<br>    <span class="hljs-comment">// use Macro can&#x27;t remove ownership </span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,str1);<br>    <span class="hljs-comment">// str2 get str1&#x27;s ownership</span><br>    <span class="hljs-keyword">let</span> str2 = takes_and_gives_back(str1);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,str2);<br>    <span class="hljs-comment">// println!(&quot;&#123;&#125;&quot;,str1); Error:所有权发生转换,str1 已经发生drop</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">takes_owner_ship</span></span>(some_string : <span class="hljs-built_in">String</span>)&#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,some_string);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">makes_copy</span></span>(some_integer : <span class="hljs-built_in">i32</span>)&#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,some_integer);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">makes_copy2</span></span>(some_bool : <span class="hljs-built_in">bool</span>)&#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,some_bool);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">gives_owenership</span></span>() -&gt; <span class="hljs-built_in">String</span> &#123;<br>    <span class="hljs-keyword">let</span> some_string = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;Rust&quot;</span>);<br>    some_string<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">takes_and_gives_back</span></span>(a_string : <span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">String</span>&#123;<br>    a_string<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> Rust 有一个叫做 <code>Copy</code> trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上（第十章详细讲解 trait）。如果一个类型拥有 <code>Copy</code> trait，一个旧的变量在将其赋值给其他变量后仍然可用。Rust 不允许自身或其任何部分实现了 <code>Drop</code> trait 的类型使用 <code>Copy</code> trait。如果我们对其值离开作用域时需要特殊处理的类型使用 <code>Copy</code> 注解，将会出现一个编译时错误。要学习如何为你的类型增加 <code>Copy</code> 注解，请阅读附录 C 中的 <a href="https://kaisery.github.io/trpl-zh-cn/appendix-03-derivable-traits.html">“可派生的 trait”</a>。</li></ul><h5 id="2｜引用、可变引用、借用"><a href="#2｜引用、可变引用、借用" class="headerlink" title="2｜引用、可变引用、借用"></a>2｜引用、可变引用、借用</h5><blockquote><p>在编译器中更多的使用的是借用的概念。</p></blockquote><blockquote><p>将引用和可变引用也当作是数据类型考虑，引用和可变引用不是相同的数据类型，类比u32和i32。</p></blockquote><blockquote><p>在每一个函数中都获取所有权并接着返回所有权有些啰嗦。如果我们想要函数使用一个值但不获取所有权该怎么办呢？</p><p>如果我们还要接着使用它的话，每次都传进去再返回来就有点烦人了，除此之外，我们也可能想返回函数体中产生的一些数据。</p><p>引用的精髓如下所示：</p><ul><li><input disabled="" type="checkbox"> 对比C++，C++引用</li></ul></blockquote><blockquote><p>引用只是使用值，但是不对数据享有所有权，抓住数据和所有者的关系，没有所有权就不能对数据进行修改。</p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-04-22-064751.png" alt="image-20210422144736726" style="zoom:50%;" /></blockquote><blockquote><p>可变引用：</p><p>1｜用于修改引用的值，首先要保证值的主人的类型是可变的，所以用mut类型；如果说不是准备对数据修改，那么就没有必要定义为可变（编译器会提示warning）；</p><p>2｜可变引用的局限性：在特定作用域中的特定数据只能有一个可变引用；还是从并发的角度出发，数据相当于临界变量，如果多个引用，程序进度不同的话，会出现bug。尽管说所有权未发生变化，但是因为数据的类型从<code>inmutable</code>变为<code>mutable</code>，那么就要保证临界资源（也即数据）在同一时刻</p><p>如下错误示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);<br><br><span class="hljs-keyword">let</span> r1 = &amp;<span class="hljs-keyword">mut</span> s;<br><span class="hljs-keyword">let</span> r2 = &amp;<span class="hljs-keyword">mut</span> s;<span class="hljs-comment">// Error</span><br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, r1, r2);<br><br><span class="hljs-comment">// 修改r1 的作用域，r1使用完后释放，也就是说r1和r2不会发生同时对数据修改的可能。</span><br>&#123;<br><span class="hljs-keyword">let</span> r1 = &amp;<span class="hljs-keyword">mut</span> s;<br>&#125;<br><span class="hljs-keyword">let</span> r2 = &amp;<span class="hljs-keyword">mut</span> s;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,r2);<br></code></pre></td></tr></table></figure><p>这个限制允许可变性，不过是以一种受限制的方式允许。新 Rustacean 们经常难以适应这一点，因为大部分语言中变量任何时候都是可变的。</p><p>3｜这个限制的好处是 Rust 可以在编译时就避免数据竞争。<strong>数据竞争</strong>（<em>data race</em>）类似于竞态条件，它可由这三个行为造成：</p><ul><li>两个或更多指针同时访问同一数据。</li><li>至少有一个指针被用来写入数据。</li><li>没有同步数据访问的机制。</li></ul><p>4 | 可变引用和引用同时存在</p><ul><li>注意一个引用的作用域从声明的地方开始一直持续到最后一次使用为止，可变引用和不可变引作用域不能重叠。</li><li>不可变引用的用户可不希望在他们的眼皮底下值就被意外的改变了！</li><li>多个不可变引用是可以的，因为没有哪个只能读取数据的人有能力影响其他人读取到的数据。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);<br><br><span class="hljs-keyword">let</span> r1 = &amp;s; <br><span class="hljs-keyword">let</span> r2 = &amp;s; <br><span class="hljs-comment">//cannot borrow `s` as mutable because it is also borrowed as immutable</span><br><span class="hljs-comment">//  </span><br><span class="hljs-keyword">let</span> r3 = &amp;<span class="hljs-keyword">mut</span> s; <span class="hljs-comment">// 大问题</span><br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;</span>, r1, r2, r3);<br><br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello world&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> word = first_word(&amp;s);<span class="hljs-comment">// 可变引用和不可变引用作用域有交叉</span><br><br>    s.clear(); <span class="hljs-comment">// 错误!</span><br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;the first word is: &#123;&#125;&quot;</span>, word);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="3｜悬垂引用"><a href="#3｜悬垂引用" class="headerlink" title="3｜悬垂引用"></a>3｜悬垂引用</h5><blockquote><p>在具有指针的语言中，很容易<code>通过释放内存时保留指向它的指针</code>而错误地生成一个 <strong>悬垂指针</strong>（<em>dangling pointer</em>），所谓悬垂指针是其指向的内存可能已经被分配给其它持有者。相比之下，在 Rust 中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">dangle</span></span>() -&gt; &amp;<span class="hljs-built_in">String</span> &#123; <span class="hljs-comment">// dangle 返回一个字符串的引用</span><br><br> <span class="hljs-keyword">let</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// s 是一个新字符串</span><br><br> &amp;s <span class="hljs-comment">// 返回字符串 s 的引用</span><br>&#125; <span class="hljs-comment">// 这里 s 离开作用域并被丢弃。其内存被释放，危险⚠️</span><br><br><span class="hljs-comment">// 修改</span><br><span class="hljs-comment">// #1 所有权转移，值就不会被释放</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">no_dangle</span></span>() -&gt; <span class="hljs-built_in">String</span> &#123;<br> <span class="hljs-keyword">let</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);<br> s<br>&#125;<br><br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3-Rust-Prime-ProgrammingLanguage-4-Control_Flow</title>
    <link href="/2021/04/24/3-Rust-Prime-ProgrammingLanguage-4-Control-Flow/"/>
    <url>/2021/04/24/3-Rust-Prime-ProgrammingLanguage-4-Control-Flow/</url>
    
    <content type="html"><![CDATA[<h4 id="4｜控制流"><a href="#4｜控制流" class="headerlink" title="4｜控制流"></a>4｜控制流</h4><blockquote><p>if else 条件判断，条件判断大多的优化，是通过逻辑优化</p><p>loop：一直执行知道你要求停止</p><p><code>loop</code> 的一个用例是重试可能会失败的操作，比如检查线程是否完成了任务。然而你可能会需要将操作的结果传递给其它的代码。如果将返回值加入你用来停止循环的 <code>break</code> 表达式，它会被停止的循环返回。</p><p><code>loop</code>可以有返回值？</p><p>for</p><p>while</p><p>当条件为真时，使用 <code>while</code> 循环运行代码</p><p>这种结构消除了很多使用 <code>loop</code>、<code>if</code>、<code>else</code> 和 <code>break</code> 时所必须的嵌套，这样更加清晰。当条件为真就执行，否则退出循环。</p></blockquote><blockquote><p>Rust 并不会尝试自动地将非布尔值转换为布尔值。必须总是显式地使用布尔值作为 <code>if</code> 的条件。</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-comment">// loop end med : ctrl+c or use keyword:break</span><br>    <span class="hljs-comment">// loop can have a return val</span><br>    <span class="hljs-comment">// loop ： do while</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> counter = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">loop</span>&#123;<br>        counter += <span class="hljs-number">1</span>;           <span class="hljs-comment">// rust没有自增运算符</span><br>        <span class="hljs-keyword">if</span> counter == <span class="hljs-number">10</span>&#123;<br>            <span class="hljs-keyword">break</span> counter * <span class="hljs-number">2</span>;  <span class="hljs-comment">// 不需要return就可以实现</span><br>        &#125;<br>    &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;result = &#123;&#125;&quot;</span>,result);<br><br>    <span class="hljs-comment">// while</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> number = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">while</span> number != <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,number);<br>        number = number - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;LIFTOFF!!!&quot;</span>);<br><br>    <span class="hljs-comment">// for</span><br>    <span class="hljs-keyword">let</span> a = [<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>];<br><br>    <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> a.iter()&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;the value is &#123;&#125;&quot;</span>,element);<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-comment">// (0..5)是标准库中的range类型</span><br>    <span class="hljs-keyword">for</span> number <span class="hljs-keyword">in</span> (<span class="hljs-number">0</span>..<span class="hljs-number">5</span>).rev()&#123;         <span class="hljs-comment">// （0..5)左闭右开</span><br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;the value is &#123;&#125;&quot;</span>,a[number]);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3-Rust-Prime-ProgrammingLanguage-3-Function</title>
    <link href="/2021/04/24/3-Rust-Prime-ProgrammingLanguage-3-Function/"/>
    <url>/2021/04/24/3-Rust-Prime-ProgrammingLanguage-3-Function/</url>
    
    <content type="html"><![CDATA[<h4 id="3｜函数、方法"><a href="#3｜函数、方法" class="headerlink" title="3｜函数、方法"></a>3｜函数、方法</h4><blockquote><p>函数定义的要素：</p><p>Rust 函数关键字 <code>fn</code></p><p>函数名称：使用的是snack case 命名规范，也就是字母都是小写，使用<code>__</code>分割单词。</p><p>函数参数（操作数/操作数地址）</p><p>函数体（实现的功能）</p><p>函数返回值：注意返回值的定义方式以及返回值一定是从表达式返回的，不是从语句返回的</p></blockquote><h5 id="1｜函数的定义"><a href="#1｜函数的定义" class="headerlink" title="1｜函数的定义"></a>1｜函数的定义</h5><blockquote><p>Rust 中的函数定义以 <code>fn</code> 开始并在函数名后跟一对圆括号。大括号告诉编译器哪里是函数体的开始和结尾。<code>Rust 不关心函数定义于何处，只要定义了就行。</code></p></blockquote><h5 id="2｜函数的参数"><a href="#2｜函数的参数" class="headerlink" title="2｜函数的参数"></a>2｜函数的参数</h5><blockquote><p>在函数签名中，<strong>必须声明每个参数的类型</strong>。这是 Rust 设计中一个经过慎重考虑的决定：要求在函数定义中提供类型注解，意味着编译器不需要你在代码的其他地方注明类型来指出你的意图。</p></blockquote><h5 id="3｜函数的功能"><a href="#3｜函数的功能" class="headerlink" title="3｜函数的功能"></a>3｜函数的功能</h5><blockquote><p>包含语句和表达式的函数体，语句是执行一些操作但是不返回值的指令，表达式计算产生一个值。</p><p>我们用来创建新作用域的大括号（代码块），<code>&#123;&#125;</code>，也是一个表达式。</p><p>表达式和语句的区别：表达式不用<code>;</code>作为结尾，而语句是要用<code>;</code>作为结尾的。</p></blockquote><h5 id="4｜函数的返回值"><a href="#4｜函数的返回值" class="headerlink" title="4｜函数的返回值"></a>4｜函数的返回值</h5><blockquote><p>要考虑清楚语句是不是有返回值<code>let y = 6;</code>就没有返回值，对于没有返回值的语句不能进行赋值操作，也就是不能作为右值。</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> y = plus_one(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;5 + 1 = &#123;&#125;&quot;</span>, y);<br>    <span class="hljs-keyword">let</span> z = fib(<span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;fib(8) = &#123;&#125;&quot;</span>,z);<br>&#125;<br><span class="hljs-comment">// 但表达式是不需要返回值的，如果是符合语句是需要返回值的</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">plus_one</span></span>(x:<span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">i32</span>&#123;<br>    x+<span class="hljs-number">1</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">fib</span></span>(i: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">i32</span> &#123;<br>    <span class="hljs-keyword">if</span> i &lt;= <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;索引要大于0&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> i &lt;= <span class="hljs-number">2</span> &#123; <span class="hljs-number">1</span> &#125; <span class="hljs-keyword">else</span> &#123; fib(i - <span class="hljs-number">1</span>) + fib(i - <span class="hljs-number">2</span>) &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5｜方法语法"><a href="#5｜方法语法" class="headerlink" title="5｜方法语法"></a>5｜方法语法</h5><blockquote><p>它们使用 <code>fn</code> 关键字和名称声明，可以拥有参数和返回值，同时包含在某处调用该方法时会执行的代码。不过方法与函数是不同的，因为它们在结构体的上下文中被定义（或者是枚举或 trait 对象的上下文，将分别在第六章和第十七章讲解），并且它们第一个参数总是 <code>self</code>，它代表调用该方法的结构体实例。</p></blockquote><blockquote><p>方法语法的实现:</p><ul><li><p>我们将某个类型实例能做的所有事情都一起放入 <code>impl</code> 块中，而不是让将来的用户在我们的库中到处寻找 <code>Rectangle</code> 的功能。如果是针对某一个实例的操作，那么放在方法中会更好一点。</p></li><li><p>和函数一样都需要有参数、返回值类型、函数实现什么功能。但是参数的输入有所不同。</p></li><li><p>参数：使用 <code>&amp;self</code> 来替代 <code>rectangle: &amp;Rectangle</code>该方法位于 <code>impl Rectangle</code> 上下文中所以 Rust 知道 <code>self</code> 的类型是 <code>Rectangle</code>。</p></li><li><p>方法可以选择获取 <code>self</code> 的所有权，或者像我们这里一样不可变地借用 <code>self</code>，或者可变地借用 <code>self</code>，就跟其他参数一样。不变的借用那么就是 <code>&amp;self</code>，可变的借用就是<code>&amp; mut self</code>;</p></li><li><p><strong>Rust 可以明确地计算出方法是仅仅读取（<code>&amp;self</code>），做出修改（<code>&amp;mut self</code>）或者是获取所有权（<code>self</code>）。事实上，Rust 对方法接收者的隐式借用让所有权在实践中更友好。</strong></p></li><li><ul><li><input disabled="" type="checkbox"> TODO：获取所有权和做出修改有什么区别？</li></ul></li></ul></blockquote><blockquote><p>方法的调用<code>.</code>:Rust 有一个叫 <strong>自动引用和解引用</strong>（<em>automatic referencing and dereferencing</em>）的功能。方法调用是 Rust 中少数几个拥有这种行为的地方。在 C/C++ 语言中，有两个不同的运算符来调用方法：<code>.</code> 直接在对象上调用方法，而 <code>-&gt;</code> 在一个对象的指针上调用方法，这时需要先解引用（dereference）指针。换句话说，如果 <code>object</code> 是一个指针，那么 <code>object-&gt;something()</code> 就像 <code>(*object).something()</code> 一样。</p><p>他是这样工作的：当使用 <code>object.something()</code> 调用方法时，Rust 会自动为 <code>object</code> 添加 <code>&amp;</code>、<code>&amp;mut</code> 或 <code>*</code> 以便使 <code>object</code> 与方法签名匹配。也就是说，这些代码是等价的：</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Rectangle</span></span> &#123;<br>    width: <span class="hljs-built_in">u32</span>,<br>    height: <span class="hljs-built_in">u32</span>,<br>&#125;<br><span class="hljs-keyword">impl</span> Rectangle &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">area</span></span>(&amp; <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u32</span>&#123;<br>        <span class="hljs-keyword">self</span>.width * <span class="hljs-keyword">self</span>.height<br>    &#125;<br>    <span class="hljs-comment">// fn answer(&amp;mut self)&#123;</span><br>    <span class="hljs-comment">//     self.height+= 5;</span><br>    <span class="hljs-comment">// &#125;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>()&#123;<br>    <span class="hljs-keyword">let</span> rect1  = Rectangle&#123; width:<span class="hljs-number">30</span>,height:<span class="hljs-number">50</span>&#125;;<br>    <span class="hljs-built_in">println!</span>(<br>        <span class="hljs-string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,<br>        rect1.area()<br>    );<br>    <span class="hljs-comment">// let x = rect1.answer();  Error</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Rectangle</span></span> &#123;<br>    width: <span class="hljs-built_in">u32</span>,<br>    height: <span class="hljs-built_in">u32</span>,<br>&#125;<br><span class="hljs-keyword">impl</span> Rectangle &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">area</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u32</span>&#123;<br>        <span class="hljs-keyword">self</span>.width * <span class="hljs-keyword">self</span>.height<br>    &#125;<br><span class="hljs-comment">// 因为我们只需要读取 rect2（而不是写入，这意味着我们需要一个不可变借用）</span><br><span class="hljs-comment">// 而且希望 main 保持 rect2 的所有权，这样就可以在调用这个方法后继续使用它。</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">can_hold</span></span>(&amp;<span class="hljs-keyword">self</span>, other : &amp;Rectangle) -&gt; <span class="hljs-built_in">bool</span>&#123;<br>        <span class="hljs-keyword">self</span>.width &gt; other.width &amp;&amp; <span class="hljs-keyword">self</span>.height &gt; other.height<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>()&#123;<br>    <span class="hljs-keyword">let</span> rect1 = Rectangle&#123; width:<span class="hljs-number">30</span>,height:<span class="hljs-number">50</span>&#125;;<br>    <span class="hljs-keyword">let</span> rect2 = Rectangle&#123; width:<span class="hljs-number">35</span>,height:<span class="hljs-number">55</span>&#125;;<br>    <span class="hljs-keyword">let</span> rect3 = Rectangle&#123; width:<span class="hljs-number">20</span>,height:<span class="hljs-number">50</span>&#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Can rect1 hold rect2? &#123;&#125;&quot;</span>,rect1.can_hold(&amp;rect2));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Can rect3 hold rect2? &#123;&#125;&quot;</span>,rect2.can_hold(&amp;rect3));<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,rect2.area());<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="6｜关联函数"><a href="#6｜关联函数" class="headerlink" title="6｜关联函数"></a>6｜关联函数</h5><blockquote><p>关联函数经常被用作返回一个结构体新实例的构造函数。</p><p><code>impl</code> 块的另一个有用的功能是：允许在 <code>impl</code> 块中定义 <strong>不</strong> 以 <code>self</code> 作为参数的函数。这被称为 <strong>关联函数</strong>（<em>associated functions</em>），因为它们与结构体相关联。它们仍是函数而不是方法，因为它们并不作用于一个结构体的实例。</p><p>关联函数和方法的区别在于：方法只能做用于结构体实例，但是关联函数仍是函数不是方法，并不是作用于结构体的实例。</p></blockquote><blockquote><p>关联函数经常被用作返回一个结构体新实例的构造函数。例如我们可以提供一个关联函数，它接受一个维度参数并且同时作为宽和高，这样可以更轻松的创建一个正方形 <code>Rectangle</code> 而不必指定两次同样的值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> Rectangle &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">square</span></span>(size: <span class="hljs-built_in">u32</span>) -&gt; Rectangle &#123;<br>        Rectangle &#123; width: size, height: size &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3-Rust-Prime-ProgrammingLanguage-2-DataType</title>
    <link href="/2021/04/24/3-Rust-Prime-ProgrammingLanguage-2-DataType/"/>
    <url>/2021/04/24/3-Rust-Prime-ProgrammingLanguage-2-DataType/</url>
    
    <content type="html"><![CDATA[<h4 id="1｜变量"><a href="#1｜变量" class="headerlink" title="1｜变量"></a>1｜变量</h4><p><code>day2</code></p><h5 id="1｜变量、常量、可变性"><a href="#1｜变量、常量、可变性" class="headerlink" title="1｜变量、常量、可变性"></a>1｜变量、常量、可变性</h5><blockquote><p>变量：Rust中变量默认为不可改变的，这样有利于安全性和简单的并发性。</p><p>定义不可改变的变量：<code>let + 变量名</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;<span class="hljs-comment">// 变量不可改变</span><br>x = <span class="hljs-number">6</span>;<span class="hljs-comment">// Err</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x = <span class="hljs-number">5</span>;<span class="hljs-comment">// 变量可以改变</span><br>x = <span class="hljs-number">6</span>;<span class="hljs-comment">// Ok</span><br></code></pre></td></tr></table></figure><p>定义可改变的变量：<code>let + mut + 变量名</code></p></blockquote><blockquote><p>shadowing机制：Rust中提供了Shadowing机制，定义重名的不可改变的变量，第二个变量会将第一个变量隐藏。Shadowing机制主要是用于如果变量属于<code>use one time</code>，则可以使用Shadowing。</p><p>使用shadowing：</p><p>1、shadowing可以改变变量的类型，如下所示</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> x = <span class="hljs-string">&quot;helloworld&quot;</span><span class="hljs-comment">// x type is string</span><br><span class="hljs-keyword">let</span> x = x.len();<span class="hljs-comment">// x type is int</span><br></code></pre></td></tr></table></figure><p>2、shadowing与可变变量的区别：</p><p>shadowing需要多次使用let，实际上shadowing是创建了新的变量，服用了变量名，进过计算后变量仍是不变的。</p></blockquote><blockquote><p>常量与变量的区别：</p><p>Rust 常量的命名规范是使用下划线分隔的大写字母单词，并且可以在数字字面值中插入下划线来提升可读性。</p><p>常量的定义：</p><p>1、常量的定义必须标注清楚值的类型：u32</p><p>2、使用keyword：<code>const</code></p><p>3、变量名：尽量使用大写（和C命名相同）</p><p>4、声明的作用域：常量在整个程序生命周期中都有效，量可以作为多处代码使用的全局范围的值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">const</span> MAX_POINTS: <span class="hljs-built_in">u32</span> = <span class="hljs-number">100_000</span>; <br></code></pre></td></tr></table></figure></blockquote><h4 id="2｜基本类型"><a href="#2｜基本类型" class="headerlink" title="2｜基本类型"></a>2｜基本类型</h4><h5 id="1｜整形"><a href="#1｜整形" class="headerlink" title="1｜整形"></a>1｜整形</h5><blockquote><p>有符号和无符号类型</p><p>有符号数为补码形式存储。</p><h5 id="整型溢出：按照-2-n-进行计算"><a href="#整型溢出：按照-2-n-进行计算" class="headerlink" title="整型溢出：按照$2^n$进行计算"></a><a href="https://kaisery.github.io/trpl-zh-cn/ch03-02-data-types.html#%E6%95%B4%E5%9E%8B%E6%BA%A2%E5%87%BA">整型溢出</a>：按照$2^n$进行计算</h5><p>比方说有一个 <code>u8</code> ，它可以存放从零到 <code>255</code> 的值。那么当你将其修改为 <code>256</code> 时会发生什么呢？这被称为 “整型溢出”（“integer overflow” ），关于这一行为 Rust 有一些有趣的规则。当在 debug 模式编译时，Rust 检查这类问题并使程序 <em>panic</em>，这个术语被 Rust 用来表明程序因错误而退出。第九章 <a href="https://kaisery.github.io/trpl-zh-cn/ch09-01-unrecoverable-errors-with-panic.html">“<code>panic!</code> 与不可恢复的错误”</a> 部分会详细介绍 panic。</p><p>在 release 构建中，Rust 不检测溢出，相反会进行一种被称为二进制补码包装（<em>two’s complement wrapping</em>）的操作。简而言之，<code>256</code> 变成 <code>0</code>，<code>257</code> 变成 <code>1</code>，依此类推。依赖整型溢出被认为是一种错误，即便可能出现这种行为。如果你确实需要这种行为，标准库中有一个类型显式提供此功能，<a href="https://kaisery.github.io/std/num/struct.Wrapping.html"><code>Wrapping</code></a>。</p></blockquote><table><thead><tr><th>长度</th><th>有符号</th><th>无符号</th></tr></thead><tbody><tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr><tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr><tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr><tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr><tr><td>128-bit</td><td><code>i128</code></td><td><code>u128</code></td></tr><tr><td>arch</td><td><code>isize</code></td><td><code>usize</code></td></tr></tbody></table><blockquote><p>整形的声明与定义：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 隐式声明，没有在声明和定义的时候说明类型的type</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x = <span class="hljs-number">98_222</span>;<span class="hljs-comment">//十进制无序前缀，按照每三位使用 _ 作为分隔符分割，增加可读性</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> y = <span class="hljs-number">0xff</span>;<span class="hljs-comment">//十六进制需要增加前缀0x</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> z = <span class="hljs-number">0o77</span>;<span class="hljs-comment">//八进制使用前缀0o</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> w = <span class="hljs-number">0b_1111_1111</span><span class="hljs-comment">//二进制使用前缀0b，没四位按照 _ 作为分隔符分割</span><br><span class="hljs-comment">// 显示声明</span><br><span class="hljs-keyword">let</span> x:<span class="hljs-built_in">i64</span> = <span class="hljs-number">1000_1000</span>;  <span class="hljs-comment">//显示声明</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;i32 MAX = &#123;&#125;&quot;</span>,std::<span class="hljs-built_in">i32</span>::MAX);<span class="hljs-comment">//调用std库，输出i32能表示的最大的数，可以用于检查是否溢出</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;i32 pow(2,n) n =&#123;&#125;&quot;</span>,MAX_EXP);<span class="hljs-comment">// i32能支持的最大的2的次方数n是128,如果是2^129那么就会发生溢出的现象。</span><br></code></pre></td></tr></table></figure></blockquote><table><thead><tr><th>Decimal (十进制)</th><th><code>98_222</code></th></tr></thead><tbody><tr><td>Hex (十六进制)</td><td><code>0xff</code></td></tr><tr><td>Octal (八进制)</td><td><code>0o77</code></td></tr><tr><td>Binary (二进制)</td><td><code>0b1111_0000</code></td></tr><tr><td>Byte (单字节字符)(仅限于<code>u8</code>)</td><td><code>b&#39;A&#39;</code></td></tr></tbody></table><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// pub : Make an item visible to others.</span><br><span class="hljs-keyword">use</span> std::<span class="hljs-built_in">i32</span>;<br><span class="hljs-keyword">use</span> std::<span class="hljs-built_in">i64</span>;<br><span class="hljs-keyword">use</span> std::mem::size_of;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">const</span> MAX_EXP: <span class="hljs-built_in">i32</span> = <span class="hljs-built_in">f32</span>::MAX_EXP;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>()&#123;<br>    <span class="hljs-comment">// Integer define</span><br>    <span class="hljs-keyword">let</span> x = <span class="hljs-number">100_100</span>;    <span class="hljs-comment">//编译器推测处x的类型为i32</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,x);   <span class="hljs-comment">// println!()参数为string类型</span><br>    <span class="hljs-comment">// 输出i32的位数 bites</span><br>    <span class="hljs-comment">// size_of类型是函数</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;i32 bite = &#123;&#125;&quot;</span>,size_of::&lt;<span class="hljs-built_in">i32</span>&gt;());<br>    <span class="hljs-keyword">let</span> x:<span class="hljs-built_in">i64</span> = <span class="hljs-number">1000_1000</span>;  <span class="hljs-comment">//显示声明</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,x);<br>    <span class="hljs-comment">// Integers can, alternatively, be expressed using </span><br>  <span class="hljs-comment">// hexadecimal, octal or binary notation using these prefixes respectively: `0x`, `0o` or `0b`.</span><br>    <span class="hljs-keyword">let</span> y:<span class="hljs-built_in">i32</span> = <span class="hljs-number">0xff</span>;<br>    <span class="hljs-comment">// 如何输出十六进制的y</span><br>    <span class="hljs-comment">// println! 默认输出是十进制</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;十六进制表示y = 0xff : &#123;&#125;&quot;</span>,y);<br>    <span class="hljs-comment">// MAX  在std标准库中有定义，调用方式如下所示：</span><br>    <span class="hljs-comment">// 为什么不会语法提示？</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;i32 MAX = &#123;&#125;&quot;</span>,<span class="hljs-built_in">i32</span>::MAX);<br>    <span class="hljs-comment">// i32 和 i64 的 MAX MIN EXP 系列只能自己定义常量</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;i32 pow(2,n) n =&#123;&#125;&quot;</span>,MAX_EXP);<br>    <span class="hljs-comment">// addition and subtraction</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;1 + 2 = &#123;&#125;&quot;</span>,<span class="hljs-number">1u32</span>+<span class="hljs-number">2</span>);  <span class="hljs-comment">//此时系统推测2为u32类型</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;1 + 2 = &#123;&#125;&quot;</span>,<span class="hljs-number">1i32</span>+<span class="hljs-number">2</span>);  <span class="hljs-comment">// 2 ==&gt; i32</span><br>    <span class="hljs-comment">// 计算机是怎么懂加减法的？</span><br>    <span class="hljs-comment">//println!(&quot;1 + 2 = &#123;&#125;&quot;,1i32-2u32);     Error</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;1 + 2 = &#123;&#125;&quot;</span>,<span class="hljs-number">1i32</span>-<span class="hljs-number">2i32</span>);<br>    <span class="hljs-comment">// Bitwise operations</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;0011 AND 0101 is &#123;:04b&#125;&quot;</span>,<span class="hljs-number">0b0011i32</span> &amp; <span class="hljs-number">0b0101</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;1 &lt;&lt; 5 is &#123;&#125;&quot;</span>, <span class="hljs-number">1i32</span> &lt;&lt; <span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;0x80 &gt;&gt; 2 is 0x&#123;:x&#125;&quot;</span>, <span class="hljs-number">0x80u32</span> &gt;&gt; <span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// test rust integer 进行 ｜｜ &amp;&amp; </span><br>    <span class="hljs-comment">// println!(&quot;true OR flase is &#123;&#125;&quot;,1 || 0);  Error</span><br>&#125;   <br></code></pre></td></tr></table></figure><h5 id="2｜浮点型"><a href="#2｜浮点型" class="headerlink" title="2｜浮点型"></a>2｜浮点型</h5><blockquote><p>Rust 也有两个原生的 <strong>浮点数</strong>（<em>floating-point numbers</em>）类型，它们是带小数点的数字。Rust 的浮点数类型是 <code>f32</code> 和 <code>f64</code>，分别占 32 位和 64 位。默认类型是 <code>f64</code>，因为在现代 CPU 中，它与 <code>f32</code> 速度几乎一样，不过精度更高。</p><p><code>注意的就是默认的类型是f64</code></p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::mem::size_of;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-comment">// float define</span><br>    <span class="hljs-keyword">let</span> x: <span class="hljs-built_in">f32</span> = <span class="hljs-number">0.001</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,x);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;f32 &#123;&#125;&quot;</span>,size_of::&lt;<span class="hljs-built_in">f32</span>&gt;());<br>    <span class="hljs-keyword">let</span> y = <span class="hljs-number">0.001f64</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;f32 &#123;&#125;&quot;</span>,size_of::&lt;<span class="hljs-built_in">f64</span>&gt;());<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,y);<br>    <span class="hljs-keyword">let</span> z = <span class="hljs-number">0.001</span>; <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,z);<br><br>    <span class="hljs-comment">// + - * /</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;0.01 - 0.001 = &#123;:.20&#125;&quot;</span>, <span class="hljs-number">0.01</span> - <span class="hljs-number">0.001</span>);    <span class="hljs-comment">//  default</span><br>    <span class="hljs-comment">//0.01 - 0.1 = -0.09000000000000001     有精度问题，数字较大采用其他方法进行计算</span><br><br>    <span class="hljs-comment">// diff type cannot + - * /</span><br>    <span class="hljs-comment">//println!(&quot;0.01 - 0.001 = &#123;&#125;&quot;,0.01f32 - 0.001f64); Error</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;0.01 - 0.001 = &#123;:.20&#125;&quot;</span>,<span class="hljs-number">0.01f32</span> - <span class="hljs-number">0.001f32</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;0.01 / 0.001 = &#123;&#125;&quot;</span>,<span class="hljs-number">0.01f64</span> / <span class="hljs-number">0.001f64</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;0.01 * 0.001 = &#123;&#125;&quot;</span>,<span class="hljs-number">0.01f64</span> * <span class="hljs-number">0.001f64</span>);<br><br>    <span class="hljs-comment">// c++</span><br>    <span class="hljs-comment">// 0.010000 - 0.001000 = 0.00899999961256980896</span><br>    <span class="hljs-comment">// 0.010000 - 0.001000 = 0.00900000000000000105</span><br>    <span class="hljs-comment">// rust</span><br>    <span class="hljs-comment">// 0.01 - 0.001 = 0.00900000000000000105</span><br>    <span class="hljs-comment">// 0.01 - 0.001 = 0.00899999961256980896</span><br>    <span class="hljs-comment">// python</span><br>    <span class="hljs-comment">// 0.01 - 0.001 = 0.009000000000000001</span><br>    <span class="hljs-comment">// 猜测和语言没有关系？   </span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3｜布尔类型（具体用法控制流细化）"><a href="#3｜布尔类型（具体用法控制流细化）" class="headerlink" title="3｜布尔类型（具体用法控制流细化）"></a>3｜布尔类型（具体用法控制流细化）</h5><blockquote><p>Rust 中整数并不能代表true和false</p><p>运算就是与、或、非</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> t = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">let</span> f: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 显式指定类型注解</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;true AND false is &#123;&#125;&quot;</span>, <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;true OR false is &#123;&#125;&quot;</span>, <span class="hljs-literal">true</span> || <span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;NOT true is &#123;&#125;&quot;</span>, !<span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4｜字符类型"><a href="#4｜字符类型" class="headerlink" title="4｜字符类型"></a>4｜字符类型</h5><blockquote><p>目前为止只使用到了数字，不过 Rust 也支持字母。Rust 的 <code>char</code> 类型是语言中最原生的字母类型，如下代码展示了如何使用它。（注意 <code>char</code> 由单引号指定，不同于字符串使用双引号。）</p></blockquote><blockquote><p>Rust 的 <code>char</code> 类型的大小为<code>四个字节(four bytes)</code>，并代表了一个  <code>Unicode 标量值（Unicode Scalar Value）</code>。</p><p>这意味着它可以比 ASCII 表示更多内容。在 Rust  中，拼音字母（Accented letters），中文、日文、韩文等字符，emoji（绘文字）以及零长度的空白字符都是有效的 <code>char</code> 值。</p><p>Unicode 标量值包含从 <code>U+0000</code> 到 <code>U+D7FF</code> 和 <code>U+E000</code> 到 <code>U+10FFFF</code> 在内的值。不过，“字符” 并不是一个 Unicode 中的概念，所以人直觉上的 “字符” 可能与 Rust 中的 <code>char</code> 并不符合。第八章的 <a href="https://kaisery.github.io/trpl-zh-cn/ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">“使用字符串存储 UTF-8 编码的文本”</a> 中将详细讨论这个主题。</p></blockquote><h5 id="5｜元组"><a href="#5｜元组" class="headerlink" title="5｜元组"></a>5｜元组</h5><p><code>day 3</code></p><blockquote><p><code>day 3 要点：</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 1｜函数</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">fib</span></span>(i: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">i32</span> &#123; <span class="hljs-comment">//返回值 </span><br> <span class="hljs-keyword">if</span> i &lt;= <span class="hljs-number">0</span> &#123;<br>   <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;索引要大于0&quot;</span>);  <span class="hljs-comment">// panic！的使用 </span><br> &#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> i &lt;= <span class="hljs-number">2</span> &#123; <span class="hljs-number">1</span> &#125; <span class="hljs-keyword">else</span> &#123; fib(i - <span class="hljs-number">1</span>) + fib(i - <span class="hljs-number">2</span>) &#125;; <span class="hljs-comment">// 函数的返回值是表达式，不是语句</span><br><span class="hljs-comment">// 2｜数组</span><br><span class="hljs-keyword">let</span> x: [<span class="hljs-built_in">i32</span>; <span class="hljs-number">5</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> y = [<span class="hljs-number">3</span>; <span class="hljs-number">5</span>];<br><span class="hljs-comment">// 3｜for循环</span><br><span class="hljs-keyword">let</span> a = [<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>];<br><span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> a.iter()&#123;<br> <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;the value is &#123;&#125;&quot;</span>,element);<br>&#125;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">// (0..5)是标准库中的range类型</span><br><span class="hljs-keyword">for</span> number <span class="hljs-keyword">in</span> (<span class="hljs-number">0</span>..<span class="hljs-number">5</span>).rev()&#123;         <span class="hljs-comment">// （0..5)左闭右开</span><br> <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;the value is &#123;&#125;&quot;</span>,a[number]);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>元组是一个将多个其他类型的值组合进一个复合类型的主要方式。元组长度固定：一旦声明，其长度不会增大或缩小。<code>Note:元组定义之后不会改变，所以定义空的元组没有意义。</code></p><p>我们使用包含在圆括号中的逗号分隔的值列表来创建一个元组。元组中的每一个位置都有一个类型，而且这些不同值的类型也不必是相同的。</p></blockquote><blockquote><p>元组的声明、赋值、解构、成员访问</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//元组的使用</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-comment">//元组的定义：variablename:(type1,type2,...) = (val1,val2,...)</span><br>    <span class="hljs-comment">// M1</span><br>    <span class="hljs-keyword">let</span> my_tup:(<span class="hljs-built_in">i32</span>,<span class="hljs-built_in">f64</span>,<span class="hljs-built_in">u8</span>) = (<span class="hljs-number">500</span>,<span class="hljs-number">0.001</span>,<span class="hljs-number">3</span>);<br>    <span class="hljs-comment">// M2:variable binds to the entire tuple</span><br>    <span class="hljs-comment">// (1,24919191919199191919191919i128,&#x27;A&#x27;,0.001,true,&quot;helloworld&quot;) is one elem</span><br>    <span class="hljs-keyword">let</span> my_tup2 = (<span class="hljs-number">1</span>,<span class="hljs-number">24919191919199191919191919i128</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-number">0.001</span>,<span class="hljs-literal">true</span>,<span class="hljs-string">&quot;helloworld&quot;</span>);<br>    <span class="hljs-comment">// 元组的成员访问 use pattern matching </span><br>    <span class="hljs-keyword">let</span> (_x,_y,_z,_w,_q,_p) = my_tup2;<br>    <span class="hljs-comment">// 元组的成员访问 name.i 的方式进行访问</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,my_tup.<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; , &#123;&#125;&quot;</span>,my_tup2.<span class="hljs-number">0</span>,my_tup2.<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,_x);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,_p);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="6｜数组"><a href="#6｜数组" class="headerlink" title="6｜数组"></a>6｜数组</h5><blockquote><p>与元组不同，数组中的每个元素的类型必须相同。Rust 中的数组与一些其他语言中的数组不同，因为 Rust 中的数组是固定长度的：一旦声明，它们的长度不能增长或缩小。或者是想要确保总是有固定数量的元素时，数组非常有用。但是数组并不如 vector 类型灵活。vector 类型是标准库提供的一个 <strong>允许</strong> 增长和缩小长度的类似数组的集合类型。当不确定是应该使用数组还是 vector 的时候，你可能应该使用 vector。第八章会详细讨论 vector。</p></blockquote><blockquote><p>数组越界问题<code>Rust 安全原则</code></p><p>数组越界的时候，编译不会产生任何错误，程序会出现一个 <strong>运行时</strong>（<em>runtime</em>）错误并且不会成功退出。当尝试用索引访问一个元素时，Rust 会检查指定的索引是否小于数组的长度。如果索引超出了数组长度，Rust 会 <em>panic</em>，这是 Rust 术语，它用于程序因为错误而退出的情况。这样当提供了一个不正确的索引时，就会访问无效的内存。通过<code>立即退出</code>而不是允许内存访问并继续执行，Rust 让你避开此类错误。</p></blockquote><blockquote><p>数组的定义、复制、成员访问</p><p>数组是一整块分配在栈上的内存,通过索引进行成员访问,数组如何定义在堆上面？</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// array 定义、成员访问</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-comment">// array define through bind</span><br>    <span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">let</span> months = [<span class="hljs-string">&quot;January&quot;</span>, <span class="hljs-string">&quot;February&quot;</span>, <span class="hljs-string">&quot;March&quot;</span>, <span class="hljs-string">&quot;April&quot;</span>, <span class="hljs-string">&quot;May&quot;</span>, <span class="hljs-string">&quot;June&quot;</span>, <span class="hljs-string">&quot;July&quot;</span>,<br>              <span class="hljs-string">&quot;August&quot;</span>, <span class="hljs-string">&quot;September&quot;</span>, <span class="hljs-string">&quot;October&quot;</span>, <span class="hljs-string">&quot;November&quot;</span>, <span class="hljs-string">&quot;December&quot;</span>];<br>    <span class="hljs-comment">// 定义类型和数量</span><br>    <span class="hljs-keyword">let</span> x: [<span class="hljs-built_in">i32</span>; <span class="hljs-number">5</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">let</span> z = [<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>];<br>    <span class="hljs-comment">//变量名为 y 的数组将包含 5 个元素，这些元素的值最初都将被设置为 3。这种写法与 let a = [3, 3, 3, 3, 3]; 效果相同，但更简洁。</span><br>    <span class="hljs-keyword">let</span> y = [<span class="hljs-number">3</span>; <span class="hljs-number">5</span>];<br>    <span class="hljs-comment">// array 成员访问:通过索引进行访问，所以也是从[0,n-1];</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a[0] = &#123;&#125;&quot;</span>,a[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;months[11] = &#123;&#125;&quot;</span>,months[<span class="hljs-number">11</span>]);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x[0] = &#123;&#125;&quot;</span>,x[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;y[3] = &#123;&#125;&quot;</span>,y[<span class="hljs-number">3</span>]);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;z[0] = &#123;&#125;&quot;</span>,z[<span class="hljs-number">0</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="7｜结构体-自定义数据类型"><a href="#7｜结构体-自定义数据类型" class="headerlink" title="7｜结构体:自定义数据类型"></a>7｜结构体:自定义数据类型</h5><p><code>day 5</code></p><blockquote><p>是一个自定义数据类型，允许你命名和包装多个相关的值，从而形成一个有意义的组合。首先结构体是数据类型，我们需要对结构体实例的数据进行操作。</p></blockquote><blockquote><p>定义结构体：</p><ul><li>定义每一部分数据的名字和类型，我们称为 <strong>字段</strong>（<em>field</em>），也就是定义每一个字段</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">struct_name</span></span>&#123;<br>  <span class="hljs-comment">//field 字段</span><br>  key1_name:type1;<br>  key2_name:type2;<br>  key3_name:type3;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">User</span></span> &#123;<br>    username: <span class="hljs-built_in">String</span>,<br>    email: <span class="hljs-built_in">String</span>,<br>    sign_in_count: <span class="hljs-built_in">u64</span>,<br>    active: <span class="hljs-built_in">bool</span>,<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>结构体实例化：</p><ul><li>大括号中使用 <code>key: value</code> 键-值对的形式提供字段，其中 key 是字段的名字，value 是需要存储在字段中的数据值；</li><li>实例中字段的顺序不需要和它们在结构体中声明的顺序一致。换句话说，结构体的定义就像一个类型的通用模板，而实例则会在这个模板中放入特定数据来创建这个类型的值</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//就和定义变量相同，不可变的结构体</span><br><span class="hljs-keyword">let</span> var_name = struct_name&#123;<br>  key1_name:type1_val;<br>  key2_name:type2_val;<br>  key3_name:type3_val;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> user1 = User &#123;<br>    email: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;someone@example.com&quot;</span>),<br>    username: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;someusername123&quot;</span>),<br>    active: <span class="hljs-literal">true</span>,<br>    sign_in_count: <span class="hljs-number">1</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//可变值的结构体</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> var_name = struce_name&#123;<br>  key1_name:type1_val;<br>  key2_name:type2_val;<br>  key3_name:type3_val;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>结构体的数据访问：</p><ul><li>为了从结构体中获取某个特定的值，可以使用点号。</li><li>针对可变值的结构体：要更改结构体中的值，如果结构体的实例是可变的，我们可以使用点号并为对应的字段赋值。</li><li>整个实例必须是可变的；Rust 并不允许只将某个字段标记为可变。另外需要注意同其他任何表达式一样</li></ul></blockquote><blockquote><p>结构体数据的初始化：</p><ul><li>不可变结构体：在实例化的时候初始化，为每一个值赋值</li><li>可变结构体<ul><li>实例化的时候进行赋值，后续进行修改</li><li>后续进行修改</li><li>使用函数进行初始化</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 函数名--&gt;函数参数--&gt;函数返回值--&gt;函数实现</span><br><span class="hljs-comment">// init就是赋值操作</span><br><span class="hljs-comment">// init需要保证结构体类型是可变的</span><br><span class="hljs-comment">// 初始化结构体：将函数的参数赋值给结构体中的成员</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">build_user</span></span>(email: <span class="hljs-built_in">String</span>, username: <span class="hljs-built_in">String</span>) -&gt; User &#123;<br>    User &#123;<br>        email: email,<br>        username: username,<br>        active: <span class="hljs-literal">true</span>,<br>        sign_in_count: <span class="hljs-number">1</span>,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>结构体更新语法：使用旧实例的大部分值但改变其部分值来创建一个新的结构体实例</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 定义变量的方法 --&gt; 变量赋值--&gt;使用旧实例的值(此处要考虑所有权问题)</span><br><span class="hljs-keyword">let</span> user2 = User &#123;<br> email: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;another@example.com&quot;</span>),<br> username: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;anotherusername567&quot;</span>),<br> active: user1.active,<br> sign_in_count: user1.sign_in_count,<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 使用..语法：.. 语法指定了剩余未显式设置值的字段应有与给定实例对应字段相同的值。</span><br><span class="hljs-keyword">let</span> user2 = User &#123;<br> email: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;another@example.com&quot;</span>),<br> username: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;anotherusername567&quot;</span>),<br> ..user1<br>&#125;;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>结构体所有权：抓住值在任一时刻都只有一个主人这个观点，引用的话主人不是自己。</p><p>我们使用了自身拥有所有权的 <code>String</code> 类型而不是 <code>&amp;str</code> 字符串 slice 类型。这是一个有意而为之的选择，因为我们想要这个<code>结构体拥有它所有的数据，为此只要整个结构体是有效的话其数据也是有效的。</code></p><p>可以使结构体存储被其他对象拥有的数据的引用，不过这么做的话需要用上 <strong>生命周期</strong>（<em>lifetimes</em>），这是一个第十章会讨论的 Rust 功能。生命周期确保结构体引用的数据有效性跟结构体本身保持一致。</p></blockquote><h5 id="8｜元组结构体"><a href="#8｜元组结构体" class="headerlink" title="8｜元组结构体"></a>8｜元组结构体</h5><blockquote><p>元组结构体有着结构体名称提供的含义，但没有具体的字段名，只有字段的类型。</p><p>当你想给整个元组取一个名字，并使元组成为与其他元组不同的类型时，元组结构体是很有用的，这时像常规结构体那样为每个字段命名就显得多余和形式化了。</p><ul><li>注意 <code>black</code> 和 <code>origin</code> 值的类型不同，因为它们是不同的元组结构体的实例。</li><li>你定义的每一个结构体有其自己的类型，即使结构体中的字段有着相同的类型。例如，一个获取 <code>Color</code> 类型参数的函数不能接受 <code>Point</code> 作为参数，即便这两个类型都由三个 <code>i32</code> 值组成。</li><li>在其他方面，元组结构体实例类似于元组：可以将其解构为单独的部分，也可以使用 <code>.</code> 后跟索引来访问单独的值，等等。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 定义</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Color</span></span>(<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">i32</span>, <span class="hljs-built_in">i32</span>);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span>(<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">i32</span>, <span class="hljs-built_in">i32</span>);<br><span class="hljs-comment">// 赋值就相当于是初始化了</span><br><span class="hljs-keyword">let</span> black = Color(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">let</span> origin = Point(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 访问值：通过索引来进行访问</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Rectangle</span></span>&#123;<br>    width: <span class="hljs-built_in">u32</span>,<br>    height: <span class="hljs-built_in">u32</span>,<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>()&#123;<br>  <span class="hljs-comment">// println! 输出结构体</span><br>  <span class="hljs-comment">// 增加注解来派生 Debug trait，并使用调试格式打印 Rectangle 实例</span><br>  <span class="hljs-comment">// 结构体的输出 -- use debug trait &#123;:?&#125; </span><br>  <span class="hljs-comment">// Rust 确实 包含了打印出调试信息的功能，不过我们必须为结构体显式选择这个功能。</span><br>  <span class="hljs-comment">// 为此，在结构体定义之前加上 #[derive(Debug)] 注解</span><br>    <span class="hljs-keyword">let</span> rect2 = Rectangle&#123;width:<span class="hljs-number">30</span>,height:<span class="hljs-number">50</span>&#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;rect2 is &#123;:?&#125;&quot;</span>,rect2);<br><br><br>    <span class="hljs-comment">// var func</span><br>    <span class="hljs-keyword">let</span> width1 = <span class="hljs-number">30</span>;<br>    <span class="hljs-keyword">let</span> height1 = <span class="hljs-number">50</span>;<br>    <span class="hljs-built_in">println!</span>(<br>        <span class="hljs-string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,<br>        area1(width1, height1)<br>    );<br><br>    <span class="hljs-comment">// tuple struct func</span><br>    <span class="hljs-keyword">let</span> rect1 = (<span class="hljs-number">30</span>,<span class="hljs-number">50</span>);<br>    <span class="hljs-built_in">println!</span>(<br>        <span class="hljs-string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,<br>        area2(rect1)<br>    );<br>    <br>    <span class="hljs-comment">// struct func</span><br>    <span class="hljs-built_in">println!</span>(<br>        <span class="hljs-string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,<br>        <span class="hljs-comment">// 分析所有权</span><br>        <span class="hljs-comment">// 因为是使用了引用，所以在area3调用后所有权并没有转移或者是remove</span><br>        area3(&amp;rect2)<br>    );<br><br>    <span class="hljs-comment">//test ownership</span><br>    <span class="hljs-comment">// 调用area4以后由于rect2的作用域结束，rect2被释放，也就是被drop</span><br>    <span class="hljs-comment">// 伴随这rect2被drop,那么rect2中的数据也被drop</span><br>    <span class="hljs-keyword">let</span> x = area4(rect2);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,x);<br>    <span class="hljs-comment">// println!(&quot;&#123;&#125;&quot;,rect2.height);  Error：borrow of moved value: `rect2`</span><br>&#125;<br><span class="hljs-comment">// M1 : use var cal</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">area1</span></span>(width:<span class="hljs-built_in">u32</span>,height:<span class="hljs-built_in">u32</span>) -&gt; <span class="hljs-built_in">u32</span>&#123;<br>    width * height<br>&#125;<br><span class="hljs-comment">// M2 : use tuple</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">area2</span></span>(dimensions:(<span class="hljs-built_in">u32</span>,<span class="hljs-built_in">u32</span>)) -&gt; <span class="hljs-built_in">u32</span>&#123;<br>    dimensions.<span class="hljs-number">0</span> * dimensions.<span class="hljs-number">1</span><br>&#125;<br><span class="hljs-comment">// M3 : use struct</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">area3</span></span>(rectangle:&amp;Rectangle) -&gt; <span class="hljs-built_in">u32</span>&#123;<br>    rectangle.width * rectangle.height<br>&#125;<br><span class="hljs-comment">// M4 : test</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">area4</span></span>(rect:Rectangle) -&gt; <span class="hljs-built_in">u32</span>&#123;<br>    rect.height * rect.width<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="8｜枚举"><a href="#8｜枚举" class="headerlink" title="8｜枚举"></a>8｜枚举</h5><h5 id="9｜切片-slice引用"><a href="#9｜切片-slice引用" class="headerlink" title="9｜切片-slice引用"></a>9｜切片-slice引用</h5><blockquote><p>另一个没有所有权的数据类型是 <em>slice</em>。slice 允许你引用集合中一段连续的元素序列，而不用引用整个集合。</p><p>首先slice是一种数据类型，其次它是<code>使用了引用的数据类型</code>,切片所以的range[a..b]范围是包含a与b与（0..5)不同,但是字符串 slice range 的索引必须位于有效的 UTF-8 字符边界内，也就是说超出 UTF-8 字符边界的数量的字符串不适合用slice。</p><p>str 和String的区别：</p><ul><li>str：The str type, also called a ‘string slice’，是字符串的切片，不属于标量类型。</li></ul><p>&amp;str和&amp;String的区别</p><ul><li>如果有一个字符串 slice，可以直接传递它。如果有一个 String，则可以传递整个 String 的 slice。</li><li>只想要一个字符串的只读视图、或者 &amp;str 作为入参，那就首选 &amp;str；如果想拥有所有权、修改字符串那就用 String</li></ul></blockquote><blockquote><p>这里有一个编程小习题：</p><p>编写一个函数，该函数接收一个字符串，并返回在该字符串中找到的第一个单词。如果函数在该字符串中并未找到空格，则整个字符串就是一个单词，所以应该返回整个字符串。</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    <span class="hljs-keyword">let</span> bytes = first_words(&amp;s);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,bytes);<br>    <span class="hljs-keyword">let</span> x = s.as_bytes().iter();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,x);<br>    <span class="hljs-comment">// keyword:enumrate()怎么包装的iter()的结果</span><br>    <span class="hljs-keyword">let</span> y = s.as_bytes().iter().enumerate();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,y);<br><br><br>    <span class="hljs-comment">//slice：slice是一种使用引用的数据类型，所以使用&amp;str表示切片类型</span><br>    <span class="hljs-comment">//[0..7] 是左闭右闭</span><br>    <span class="hljs-keyword">let</span> m = &amp;s[<span class="hljs-number">0</span>..<span class="hljs-number">7</span>];<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,m);<br>    <span class="hljs-keyword">let</span> n = &amp;s[<span class="hljs-number">0</span>..<span class="hljs-number">5</span>];<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,n);<br>    <span class="hljs-comment">// 对比（0..5)循环</span><br>    <span class="hljs-comment">// (0..5)循环是左闭右开</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span>  <span class="hljs-number">0</span>..<span class="hljs-number">5</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,i);<br>    &#125;<br>    <span class="hljs-comment">//slice:数组也可以切片</span><br>    <span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">let</span> slice = &amp;a[<span class="hljs-number">1</span>..<span class="hljs-number">3</span>];           <span class="hljs-comment">// 数组切片的类型为&amp;[i32]</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,slice);<br><br>    <span class="hljs-comment">//切片作为返回值以及参数</span><br>    <span class="hljs-keyword">let</span> l = silice_word(&amp;s);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,l);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">first_words</span></span>(s:&amp;<span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">usize</span> &#123;<br>    <span class="hljs-keyword">let</span> bytes = s.as_bytes();<br>    <span class="hljs-keyword">for</span> (i,&amp;item) <span class="hljs-keyword">in</span> bytes.iter().enumerate()&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;-&#123;&#125;&quot;</span>,i,item);<br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">b&#x27; &#x27;</span>&#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    s.len()<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">silice_word</span></span>(s:&amp;<span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-built_in">str</span>&#123;<br>    <span class="hljs-keyword">let</span> bytes = s.as_bytes();<br>    <span class="hljs-keyword">for</span> (i,&amp;item) <span class="hljs-keyword">in</span> bytes.iter().enumerate()&#123;<br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">b&#x27; &#x27;</span>&#123;<br>            <span class="hljs-keyword">return</span> &amp;s[..i];<br>        &#125;<br>    &#125;<br>    &amp;s[..]<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3-Rust-Prime-ProgrammingLanguage-ToolsandConcept</title>
    <link href="/2021/04/24/3-Rust-Prime-ProgrammingLanguage-1-ToolsandConcept/"/>
    <url>/2021/04/24/3-Rust-Prime-ProgrammingLanguage-1-ToolsandConcept/</url>
    
    <content type="html"><![CDATA[<h4 id="1｜Rust的基本工具及概念"><a href="#1｜Rust的基本工具及概念" class="headerlink" title="1｜Rust的基本工具及概念"></a>1｜Rust的基本工具及概念</h4><h5 id="0｜语言类型"><a href="#0｜语言类型" class="headerlink" title="0｜语言类型"></a>0｜语言类型</h5><blockquote><p>如果你更熟悉动态语言，如 Ruby、Python 或 JavaScript，则可能不习惯将编译和运行分为两个单独的步骤。Rust 是一种 <strong>预编译静态类型</strong>（<em>ahead-of-time compiled</em>）语言，这意味着你可以编译程序，并将可执行文件送给其他人，他们甚至不需要安装 Rust 就可以运行。如果你给他人一个 <em>.rb</em>、*.py* 或 <em>.js</em> 文件，他们需要先分别安装 Ruby，Python，JavaScript 实现（运行时环境，VM）。不过在这些语言中，只需要一句命令就可以编译和运行程序。这一切都是语言设计上的权衡取舍。</p></blockquote><h5 id="1｜cargo"><a href="#1｜cargo" class="headerlink" title="1｜cargo"></a>1｜cargo</h5><h5 id="2｜rustc"><a href="#2｜rustc" class="headerlink" title="2｜rustc"></a>2｜rustc</h5><h5 id="3｜rustup"><a href="#3｜rustup" class="headerlink" title="3｜rustup"></a>3｜rustup</h5><h5 id="4｜Rustfmt"><a href="#4｜Rustfmt" class="headerlink" title="4｜Rustfmt"></a>4｜Rustfmt</h5><h5 id="5｜库"><a href="#5｜库" class="headerlink" title="5｜库"></a>5｜库</h5><h5 id="6｜crate"><a href="#6｜crate" class="headerlink" title="6｜crate"></a>6｜crate</h5><h5 id="6｜函数"><a href="#6｜函数" class="headerlink" title="6｜函数"></a>6｜函数</h5><h5 id="7｜方法"><a href="#7｜方法" class="headerlink" title="7｜方法"></a>7｜方法</h5><blockquote><p>调用 <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a> 方法从标准输入句柄获取用户输入</p></blockquote><h5 id="8｜参数"><a href="#8｜参数" class="headerlink" title="8｜参数"></a>8｜参数</h5><h5 id="9｜返回值"><a href="#9｜返回值" class="headerlink" title="9｜返回值"></a>9｜返回值</h5><h5 id="10｜类型"><a href="#10｜类型" class="headerlink" title="10｜类型"></a>10｜类型</h5><h5 id="11｜成员"><a href="#11｜成员" class="headerlink" title="11｜成员"></a>11｜成员</h5><h5 id="12｜trait"><a href="#12｜trait" class="headerlink" title="12｜trait"></a>12｜trait</h5><h4 id="2｜code期间的问题汇总"><a href="#2｜code期间的问题汇总" class="headerlink" title="2｜code期间的问题汇总"></a>2｜code期间的问题汇总</h4><h5 id="1｜Blocking-waiting-for-file-lock-on-package-cache"><a href="#1｜Blocking-waiting-for-file-lock-on-package-cache" class="headerlink" title="1｜Blocking waiting for file lock on package cache"></a>1｜Blocking waiting for file lock on package cache</h5>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0-CPP-HOW_GCC_BUG_BUD</title>
    <link href="/2021/04/16/0-CPP-HOW-GCC-BUG-BUD/"/>
    <url>/2021/04/16/0-CPP-HOW-GCC-BUG-BUD/</url>
    
    <content type="html"><![CDATA[<h3 id="1｜程序执行的过程"><a href="#1｜程序执行的过程" class="headerlink" title="1｜程序执行的过程"></a>1｜程序执行的过程</h3><blockquote><p>学习一门语言首先要弄清楚他的执行过程，c++执行过程如下所示：</p><p>预处理-&gt;编译-&gt;汇编-&gt;链接</p></blockquote><h4 id="1｜预处理阶段"><a href="#1｜预处理阶段" class="headerlink" title="1｜预处理阶段"></a>1｜预处理阶段</h4><blockquote><p>预处理就是本文要详细说的宏替换、头文件包含等；</p><p>需要强调的是，<strong>预处理是在编译前已经完成的</strong>，也就是说编译时的输入文件里已经不含有任何预处理语句了， 这包括，<strong>条件编译的测试不通过部分被删去</strong>、<strong>宏被替换</strong>、<strong>头文件被插入</strong>等。</p><p><strong>预处理是以 translation unit 为单位进行的</strong>，一个 translation unit 就是一个源文件连同由#include包含（或间接包含）的所有文本文件的全体（参见C++标准）。一般的，编译器对一个 translation unit 生成一个二进制文件（VS是.obj，GCC是.o）。</p></blockquote><h5 id="1｜预处理指令"><a href="#1｜预处理指令" class="headerlink" title="1｜预处理指令"></a>1｜预处理指令</h5><ol><li><strong>Null</strong>，一个 # 后跟 newline ，不产生任何影响，类似于空语句；</li><li><strong>条件编译</strong>，由 #if, #ifdef, #ifndef, #else, #elif, #endif 定义；</li><li><strong>源文件包含</strong>，由 #include 定义；</li><li><strong>宏替换</strong>，由 #define, #undef, #, ## 定义；</li><li><strong>重定义行号和文件名</strong>，由 #line 定义；</li><li><strong>错误信息</strong>，由 #error 定义；</li><li><strong>编译器预留指令</strong>，由 #pragma 定义。</li></ol><h5 id="2-｜预处理实践"><a href="#2-｜预处理实践" class="headerlink" title="2 ｜预处理实践"></a>2 ｜预处理实践</h5><h6 id="1｜源文件包含"><a href="#1｜源文件包含" class="headerlink" title="1｜源文件包含"></a>1｜源文件包含</h6><blockquote><p>将原文件中的内容全部复制</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// name:preprocessed.cpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;helloworld&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -E Stop after the preprocessing stage; do not run the compiler proper. </span><br><span class="hljs-comment"># -o Place output in filefile. </span><br><span class="hljs-comment"># ‘-o’ is not specified, the default is to put an executable file in ‘a.out’</span><br>gcc -E preprocessed.cpp -o helloworld.ii<br>tree .<br><br></code></pre></td></tr></table></figure><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-04-16-043844.png" alt="image-20210416123844586"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim helloworld.ii<br></code></pre></td></tr></table></figure><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-04-16-043935.png" alt="image-20210416123935459"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">wc -l helloworld.ii<br><span class="hljs-comment"># 预处理完成后的文件行数位44013行，比源文件大很多</span><br></code></pre></td></tr></table></figure><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-04-16-044011.png" alt="image-20210416124010396"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;  // 在标准包含目录查找</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;b.cpp&quot;</span>     <span class="hljs-comment">// 在该源文件所在目录查找，找不到再到标准包含目录查找</span></span><br><span class="hljs-comment">// 目录：人话就是&quot;b.cpp&quot;所在的文件夹</span><br></code></pre></td></tr></table></figure><h6 id="2｜宏替换"><a href="#2｜宏替换" class="headerlink" title="2｜宏替换"></a>2｜宏替换</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//name : define.cpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> roses std</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> are </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> red ::</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> violets string</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> are </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> blue greet</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> this ()</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> poem &#123;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> makes return</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> no <span class="hljs-meta-string">&quot;hello world!&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> sense ;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> microwave &#125;</span><br><br><span class="hljs-comment">// Write a function &quot;greet&quot; that returns &quot;hello world!&quot; of type std::string</span><br>roses are red<br>violets are blue<br><span class="hljs-keyword">this</span> poem makes no sense<br>microwave<br><span class="hljs-comment">//相当于：</span><br>  <span class="hljs-built_in">std</span> ::<br><span class="hljs-built_in">string</span> greet<br>() &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world!&quot;</span> ;<br>&#125;：<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//低级用法</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">greet</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; greet();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//高级用法，简化自己的代码，刷题的时候使用，使用熟练了比较方便</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fr(a,b) for(int i = a; i &lt; b; i++)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,b) for(int i = a; i &lt; b; i++)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mod 1000000007</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inf (1LL&lt;&lt;60)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> prDouble(x) cout &lt;&lt; fixed &lt;&lt; setprecision(10) &lt;&lt; x</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> triplet pair<span class="hljs-meta-string">&lt;ll,pair&lt;ll,ll&gt;&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> goog(tno) cout &lt;&lt; <span class="hljs-meta-string">&quot;Case #&quot;</span> &lt;&lt; tno &lt;&lt;<span class="hljs-meta-string">&quot;: &quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fast_io ios_base::sync_with_stdio(false);cin.tie(NULL)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> read(x) int x; cin &gt;&gt; x</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init_code</span><span class="hljs-params">()</span></span>&#123;<br>    fast_io;<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> ONLINE_JUDGE</span><br>    freopen(<span class="hljs-string">&quot;input.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, <span class="hljs-built_in">stdin</span>);<br>    freopen(<span class="hljs-string">&quot;output.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-built_in">stdout</span>);<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> </span><br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   init_code();<br>   <span class="hljs-keyword">int</span> t = <span class="hljs-number">1</span>; <span class="hljs-built_in">cin</span> &gt;&gt; t;<br>   <span class="hljs-keyword">while</span>(t--)&#123;<br>       read(n); <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">prefixMax</span><span class="hljs-params">(n)</span></span>; fr(<span class="hljs-number">0</span>, n) <span class="hljs-built_in">cin</span> &gt;&gt; prefixMax[i];<br>       <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; minimal, maximal; <span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; nums;<br>       <br>       <span class="hljs-keyword">int</span> curr_max = <span class="hljs-number">0</span>;<br>       fr(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>) nums.insert(i);<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>          <span class="hljs-keyword">int</span> chosenNumber;<br>          <span class="hljs-keyword">if</span>(curr_max &lt; prefixMax[i])chosenNumber = prefixMax[i];<br>          <span class="hljs-keyword">else</span> chosenNumber = *nums.begin();<br>          nums.erase(chosenNumber);<br>          minimal.push_back(chosenNumber);<br>          curr_max = max(curr_max, minimal.back());<br>       &#125;<br> <br>       curr_max = <span class="hljs-number">0</span>;<br>       fr(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>) nums.insert(i);<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>          <span class="hljs-keyword">int</span> chosenNumber;<br>          <span class="hljs-keyword">if</span>(curr_max &lt; prefixMax[i])chosenNumber = prefixMax[i];<br>          <span class="hljs-keyword">else</span> chosenNumber = *(--(nums.lower_bound(prefixMax[i])));<br>          nums.erase(chosenNumber);<br>          maximal.push_back(chosenNumber);<br>          curr_max = max(curr_max, maximal.back());<br>       &#125;<br> <br>       fr(<span class="hljs-number">0</span>,n) <span class="hljs-built_in">cout</span> &lt;&lt; minimal[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>       fr(<span class="hljs-number">0</span>,n) <span class="hljs-built_in">cout</span> &lt;&lt; maximal[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br> <br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//以for循环为例进行测试</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fr(a,b) for(int i = a; i &lt; b; i++)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,b) for(int i = a; i &lt; b; i++)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mod 1000000007</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inf (1LL&lt;&lt;60)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) (x).begin(), (x).end()</span><br></code></pre></td></tr></table></figure><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-04-16-073717.png" alt="image-20210416153514356"></p><h6 id="3｜条件编译"><a href="#3｜条件编译" class="headerlink" title="3｜条件编译"></a>3｜条件编译</h6><blockquote><h6 id="ifndef"><a href="#ifndef" class="headerlink" title="ifndef"></a>ifndef</h6><h2 id="这是一种防止头文件被多次包含的预处理技术，由于各种原因可能是有问题的。在编译项目时，编译每个-cpp文件（通常）。简单来说，这意味着编译器会把你的-cpp文件，打开任何文件-included，将它们全部连接成一个海量文本文件，然后执行语法分析，最后将它转换成一些中间代码，优化-执行其他任务，最后生成目标架构的汇编输出。因此，如果-included一个-cpp文件下的文件多次，则编译器将附加文件内容两次，因此如果该文件中有定义，你会收到一个编译器错误，告诉你重新定义了一个变量。FILE-H当编译过程中的预处理器步骤处理文件时，首次到达其内容时，前两行将检查是否已为预处理器定义。如果没有，它将定义FILE-H并继续处理它和指令之间的代码-endif。下一次该文件的内容被预处理器看到时，检查FILE-H将是假的，所以它将立即扫描-endif并继续。这样可以防止重新定义错误。它将定义并继续处理它和指令之间的代码。"><a href="#这是一种防止头文件被多次包含的预处理技术，由于各种原因可能是有问题的。在编译项目时，编译每个-cpp文件（通常）。简单来说，这意味着编译器会把你的-cpp文件，打开任何文件-included，将它们全部连接成一个海量文本文件，然后执行语法分析，最后将它转换成一些中间代码，优化-执行其他任务，最后生成目标架构的汇编输出。因此，如果-included一个-cpp文件下的文件多次，则编译器将附加文件内容两次，因此如果该文件中有定义，你会收到一个编译器错误，告诉你重新定义了一个变量。FILE-H当编译过程中的预处理器步骤处理文件时，首次到达其内容时，前两行将检查是否已为预处理器定义。如果没有，它将定义FILE-H并继续处理它和指令之间的代码-endif。下一次该文件的内容被预处理器看到时，检查FILE-H将是假的，所以它将立即扫描-endif并继续。这样可以防止重新定义错误。它将定义并继续处理它和指令之间的代码。" class="headerlink" title="这是一种防止头文件被多次包含的预处理技术，由于各种原因可能是有问题的。在编译项目时，编译每个.cpp文件（通常）。简单来说，这意味着编译器会把你的.cpp文件，打开任何文件#included，将它们全部连接成一个海量文本文件，然后执行语法分析，最后将它转换成一些中间代码，优化/执行其他任务，最后生成目标架构的汇编输出。因此，如果#included一个.cpp文件下的文件多次，则编译器将附加文件内容两次，因此如果该文件中有定义，你会收到一个编译器错误，告诉你重新定义了一个变量。FILE_H当编译过程中的预处理器步骤处理文件时，首次到达其内容时，前两行将检查是否已为预处理器定义。如果没有，它将定义FILE_H并继续处理它和指令之间的代码#endif。下一次该文件的内容被预处理器看到时，检查FILE_H将是假的，所以它将立即扫描#endif并继续。这样可以防止重新定义错误。它将定义并继续处理它和指令之间的代码。"></a>这是一种防止头文件被多次包含的预处理技术，由于各种原因可能是有问题的。在编译项目时，编译每个.cpp文件（通常）。简单来说，这意味着编译器会把你的.cpp文件，打开任何文件#included，将它们全部连接成一个海量文本文件，然后执行语法分析，最后将它转换成一些中间代码，优化/执行其他任务，最后生成目标架构的汇编输出。因此，如果#included一个.cpp文件下的文件多次，则编译器将附加文件内容两次，因此如果该文件中有定义，你会收到一个编译器错误，告诉你重新定义了一个变量。FILE_H当编译过程中的预处理器步骤处理文件时，首次到达其内容时，前两行将检查是否已为预处理器定义。如果没有，它将定义FILE_H并继续处理它和指令之间的代码#endif。下一次该文件的内容被预处理器看到时，检查FILE_H将是假的，所以它将立即扫描#endif并继续。这样可以防止重新定义错误。它将定义并继续处理它和指令之间的代码。</h2><p>版权声明：本文为CSDN博主「SYL0303」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/yanli33/article/details/68947050">https://blog.csdn.net/yanli33/article/details/68947050</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> GOOGLETEST_SAMPLES_SAMPLE1_H_</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GOOGLETEST_SAMPLES_SAMPLE1_H_</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// GOOGLETEST_SAMPLES_SAMPLE1_H_</span></span><br><span class="hljs-comment">// 执行流程</span><br><span class="hljs-comment">// sample1.cpp -&gt; 预处理#include &quot;define_1.h&quot; </span><br><span class="hljs-comment">// 预处理讲&#x27;_&#x27;替换为&#x27;.&#x27;，以&#x27;_&#x27;开头的话则替换为&#x27;./&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-04-16-084817.png" alt="image-20210416164533608"></p><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-04-16-084826.png" alt="image-20210416164444809"></p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-04-16-084404.png" alt="image-20210416164404080" style="zoom:100%;" />]]></content>
    
    
    
    <tags>
      
      <tag>C++,grammar</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0-CPP-Grammar-Constant</title>
    <link href="/2021/04/16/0-CPP-Grammar-Constant/"/>
    <url>/2021/04/16/0-CPP-Grammar-Constant/</url>
    
    <content type="html"><![CDATA[<h3 id="1｜Constant-expressions"><a href="#1｜Constant-expressions" class="headerlink" title="1｜Constant expressions"></a>1｜Constant expressions</h3><blockquote><p>Defines an [expression](dfile:///Users/uoruichi/Library/Application Support/Dash/DocSets/C++/C++.docset/Contents/Resources/Documents/en.cppreference.com/w/cpp/language/expressions.html) that can be evaluated at compile time. ## </p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++,grammar</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3-Codewars-2021-4-12</title>
    <link href="/2021/04/12/7-Codewars-2021-4-12/"/>
    <url>/2021/04/12/7-Codewars-2021-4-12/</url>
    
    <content type="html"><![CDATA[<h4 id="1｜题目1-Directions-Reduction"><a href="#1｜题目1-Directions-Reduction" class="headerlink" title="1｜题目1:Directions Reduction"></a>1｜题目1:<a href="https://www.codewars.com/kata/550f22f4d758534c1100025a/python">Directions Reduction</a></h4><h5 id="1｜My-Solution"><a href="#1｜My-Solution" class="headerlink" title="1｜My Solution"></a>1｜My Solution</h5><blockquote><p>解题思路：利用栈的思想，相反出栈，不相反入栈</p><p>坑：列表没有empty的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dirReduc</span>(<span class="hljs-params">arr</span>):</span><br>    res=[]<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> arr:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> res:<br>            res.append(item)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> res[-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;NORTH&#x27;</span> <span class="hljs-keyword">and</span> item ==<span class="hljs-string">&#x27;SOUTH&#x27;</span>:<br>                res.pop()<br>            <span class="hljs-keyword">elif</span> res[-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;SOUTH&#x27;</span> <span class="hljs-keyword">and</span> item ==<span class="hljs-string">&#x27;NORTH&#x27;</span>:<br>                res.pop()<br>            <span class="hljs-keyword">elif</span> res[-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;EAST&#x27;</span> <span class="hljs-keyword">and</span> item ==<span class="hljs-string">&#x27;WEST&#x27;</span>:<br>                res.pop()<br>            <span class="hljs-keyword">elif</span> res[-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;WEST&#x27;</span> <span class="hljs-keyword">and</span> item ==<span class="hljs-string">&#x27;EAST&#x27;</span>:<br>                res.pop()<br>            <span class="hljs-keyword">else</span>:<br>                res.append(item)<br>    <span class="hljs-keyword">return</span> res<br>            <br></code></pre></td></tr></table></figure></blockquote><h5 id="2｜Good-Solution"><a href="#2｜Good-Solution" class="headerlink" title="2｜Good Solution"></a>2｜Good Solution</h5><blockquote><p>解题思路：利用字典形成配对，就不用写这么多的<code>if……else</code>了</p><p>坑：</p><p>1、字典中键值对的配对是<code>opposite[d]</code>不是<code>opposite(d)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">opposite = &#123;<span class="hljs-string">&#x27;NORTH&#x27;</span>: <span class="hljs-string">&#x27;SOUTH&#x27;</span>, <span class="hljs-string">&#x27;EAST&#x27;</span>: <span class="hljs-string">&#x27;WEST&#x27;</span>, <span class="hljs-string">&#x27;SOUTH&#x27;</span>: <span class="hljs-string">&#x27;NORTH&#x27;</span>, <span class="hljs-string">&#x27;WEST&#x27;</span>: <span class="hljs-string">&#x27;EAST&#x27;</span>&#125;<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dirReduc</span>(<span class="hljs-params">plan</span>):</span><br> new_plan = []<br> <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> plan:<br>     <span class="hljs-keyword">if</span> new_plan <span class="hljs-keyword">and</span> new_plan[-<span class="hljs-number">1</span>] == opposite[d]:<br>         new_plan.pop()<br>     <span class="hljs-keyword">else</span>:<br>         new_plan.append(d)<br> <span class="hljs-keyword">return</span> new_plan<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>字典的配对用于通过key可以找到value，对value进行操作，其实字典和hashmap就是下标为key的数组罢了。</p></blockquote><h4 id="2｜"><a href="#2｜" class="headerlink" title="2｜"></a>2｜</h4>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Codewars</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3-Codewars-2021-4-11</title>
    <link href="/2021/04/11/7-Codewars-2021-4-11/"/>
    <url>/2021/04/11/7-Codewars-2021-4-11/</url>
    
    <content type="html"><![CDATA[<h4 id="1｜题目1：Sum-of-all-the-multiples-of-3-or-5"><a href="#1｜题目1：Sum-of-all-the-multiples-of-3-or-5" class="headerlink" title="1｜题目1：Sum of all the multiples of 3 or 5"></a>1｜题目1：<a href="https://www.codewars.com/kata/57f36495c0bb25ecf50000e7/solutions/python">Sum of all the multiples of 3 or 5</a></h4><h6 id="1｜My-Solution"><a href="#1｜My-Solution" class="headerlink" title="1｜My Solution"></a>1｜My Solution</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># step1:find all multiples of 3 and 5 except n % 15 == 0</span><br><span class="hljs-comment"># step2: sum</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span>(<span class="hljs-params">n</span>):</span><br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">int</span>(n/<span class="hljs-number">3</span>)+<span class="hljs-number">1</span>):<br>        <span class="hljs-built_in">sum</span> += <span class="hljs-number">3</span>*item<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">int</span>(n/<span class="hljs-number">5</span>)+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">5</span> * item % <span class="hljs-number">3</span>) != <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">sum</span> += <span class="hljs-number">5</span> *item<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span><br></code></pre></td></tr></table></figure><h6 id="2｜GoodSolution"><a href="#2｜GoodSolution" class="headerlink" title="2｜GoodSolution"></a>2｜GoodSolution</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span>(<span class="hljs-params">n</span>):</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,n+<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h4 id="2｜题目2-Regex-Password-Validation"><a href="#2｜题目2-Regex-Password-Validation" class="headerlink" title="2｜题目2:Regex Password Validation"></a>2｜题目2:<a href="https://www.codewars.com/kata/52e1476c8147a7547a000811/train/python">Regex Password Validation</a></h4><p><code>正则表达式</code></p><h4 id="3｜Multiplication-Tables"><a href="#3｜Multiplication-Tables" class="headerlink" title="3｜Multiplication Tables"></a>3｜<a href="https://www.codewars.com/kata/5432fd1c913a65b28f000342/train/python">Multiplication Tables</a></h4><p><code>List</code></p><h6 id="1｜My-Solution-1"><a href="#1｜My-Solution-1" class="headerlink" title="1｜My Solution"></a>1｜My Solution</h6><h6 id="2｜Good-Solution"><a href="#2｜Good-Solution" class="headerlink" title="2｜Good Solution"></a>2｜Good Solution</h6><blockquote><p>解题思路很简单</p><p>语法：生成器列表中元素为列表的表达方式</p></blockquote><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">multiplication_table</span>(<span class="hljs-params">row,col</span>):</span><br>    <span class="hljs-keyword">return</span> [[(i+<span class="hljs-number">1</span>)*(j+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(col)] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(row)]<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Codewars</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3-Codewars-2021-4-10</title>
    <link href="/2021/04/10/7-Codewars-2021-4-10/"/>
    <url>/2021/04/10/7-Codewars-2021-4-10/</url>
    
    <content type="html"><![CDATA[<h4 id="1｜题目1-The-gap-Prime-number"><a href="#1｜题目1-The-gap-Prime-number" class="headerlink" title="1｜题目1:The gap Prime number"></a>1｜题目1:The gap Prime number</h4><h5 id="1｜My-Solution"><a href="#1｜My-Solution" class="headerlink" title="1｜My Solution"></a>1｜My Solution</h5><blockquote><p>坑：</p><p>1、素数的判断</p><p>2、时间复杂度过高，代码不简洁，逻辑混乱</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-comment"># 素数判断</span><br><span class="hljs-comment"># step1:挨个判断m～n中的素数x,y,z</span><br><span class="hljs-comment"># step2:y-x 是不是等于 g</span><br><span class="hljs-comment"># step3:返回list</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ifPrime</span>(<span class="hljs-params">x</span>):</span><br>    <span class="hljs-keyword">if</span>(x == <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> x == <span class="hljs-number">3</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">if</span>(x % <span class="hljs-number">6</span> != <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> x % <span class="hljs-number">6</span> != <span class="hljs-number">5</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    y = <span class="hljs-built_in">int</span>(math.sqrt(x))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>,y+<span class="hljs-number">1</span>,<span class="hljs-number">6</span>):<br>        <span class="hljs-keyword">if</span>(x % i == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> x %(i+<span class="hljs-number">2</span>) == <span class="hljs-number">0</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gap</span>(<span class="hljs-params">g, m, n</span>):</span><br>    res = []<br>    ans = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m,n+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span>(ifPrime(i)):<br>            res.append(i)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">len</span>(res) == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(res) == <span class="hljs-number">0</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(res)-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span>(res[i+<span class="hljs-number">1</span>] - res[i] == g):<br>                ans.append(res[i])<br>                ans.append(res[i+<span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">len</span>(ans) == <span class="hljs-number">0</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h5 id="2｜Good-Solution"><a href="#2｜Good-Solution" class="headerlink" title="2｜Good Solution"></a>2｜Good Solution</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gap</span>(<span class="hljs-params">g, m, n</span>):</span><br>    previous_prime = n<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> is_prime(i):<br>            <span class="hljs-keyword">if</span> i - previous_prime == g: <br>                <span class="hljs-keyword">return</span> [previous_prime, i]<br>            previous_prime = i<span class="hljs-comment"># 这步很关键</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_prime</span>(<span class="hljs-params">n</span>):</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">int</span>(n**<span class="hljs-number">.5</span> + <span class="hljs-number">1</span>)):<br>        <span class="hljs-keyword">if</span> n % i == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>sieve = np.ones(<span class="hljs-number">12_000_000</span>, dtype=<span class="hljs-built_in">bool</span>)<br>sieve[<span class="hljs-number">0</span>] = sieve[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br>sieve[<span class="hljs-number">2</span>*<span class="hljs-number">2</span>::<span class="hljs-number">2</span>] = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>, <span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(sieve)**<span class="hljs-number">0.5</span>)+<span class="hljs-number">1</span>, <span class="hljs-number">2</span>):<br>    <span class="hljs-keyword">if</span> sieve[i]:<br>        sieve[i*i::i] = <span class="hljs-number">0</span><br>primes = np.array([i <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(sieve) <span class="hljs-keyword">if</span> x], dtype=<span class="hljs-built_in">int</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gap</span>(<span class="hljs-params">g, m, n</span>):</span><br>    i = primes.searchsorted(m)<br>    j = primes.searchsorted(n)<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, j+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> primes[k+<span class="hljs-number">1</span>] - primes[k] == g:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(primes[k:k+<span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Codewars</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1-AL-MATH-BigNumber</title>
    <link href="/2021/04/10/1-AL-MATH/"/>
    <url>/2021/04/10/1-AL-MATH/</url>
    
    <content type="html"><![CDATA[<h3 id="1｜大整数的加法"><a href="#1｜大整数的加法" class="headerlink" title="1｜大整数的加法"></a>1｜大整数的加法</h3><h4 id="2｜例题"><a href="#2｜例题" class="headerlink" title="2｜例题"></a>2｜例题</h4><h5 id="1｜2-两数相加"><a href="#1｜2-两数相加" class="headerlink" title="1｜2. 两数相加"></a>1｜<a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a></h5><h6 id="6｜My-Solution"><a href="#6｜My-Solution" class="headerlink" title="6｜My Solution"></a>6｜My Solution</h6><blockquote><p>解题思路：</p><p>坑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode *head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);   <span class="hljs-comment">//创建头结点指针</span><br>        ListNode *tail = <span class="hljs-literal">nullptr</span>;           <span class="hljs-comment">//创建尾结点指针</span><br>        ListNode *p = head;                 <span class="hljs-comment">//创建移动结点指针</span><br>        <span class="hljs-keyword">int</span> crr=<span class="hljs-number">0</span>,sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l1 || l2)                     <span class="hljs-comment">//坑2:遍历两个链表，此处为或运算，那么就要分别判断l1和l2,这个地方是坑</span><br>        &#123;<br><span class="hljs-comment">// step1:进行求值运算</span><br><span class="hljs-comment">// ##########################################################################################</span><br>            <span class="hljs-keyword">int</span> sum = crr;                  <span class="hljs-comment">// 每一轮循环都初始化sum               </span><br>            <span class="hljs-keyword">if</span>(l1)                          <span class="hljs-comment">// 如果l1非空，遍历l1</span><br>            &#123;<br>                sum += l1-&gt;val;             <span class="hljs-comment">// 累计和        </span><br>                l1 = l1-&gt;next;              <span class="hljs-comment">// 坑1:l1 向后移动，要不然会死循环        </span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(l2)                          <span class="hljs-comment">// 同l2</span><br>            &#123;<br>                sum += l2-&gt;val;<br>                l2 = l2-&gt;next;<br>            &#125;<br>            crr = sum /<span class="hljs-number">10</span>;       <br><span class="hljs-comment">// step2:答案链表的结点创建以及成链</span><br><span class="hljs-comment">// ##########################################################################################          </span><br>            <span class="hljs-comment">//逻辑问题：创建插入的尾结点，因为限制条件是l1或者l2非空，所以只要进入循环一定要创建一个结点</span><br>            tail = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>);  <br>            p -&gt; next = tail;               <span class="hljs-comment">//成链的过程</span><br>            p = p-&gt;next; <br>        &#125;     <br><span class="hljs-comment">//step3:判断最后还是否要进位</span><br><span class="hljs-comment">// ########################################################################################## </span><br>        <span class="hljs-keyword">if</span>(crr &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            tail = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);<br>            p-&gt;next = tail;<br>        &#125;     <br><span class="hljs-comment">//step4:因为是从head-&gt;next开始计算的，所以返回head-&gt;next</span><br><span class="hljs-comment">// ########################################################################################## </span><br>        <span class="hljs-keyword">return</span> head-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></blockquote><h6 id="2｜Good-Solution"><a href="#2｜Good-Solution" class="headerlink" title="2｜Good Solution"></a>2｜Good Solution</h6><blockquote><p>解题思路：思路都相同只不过是对代码的逻辑进行了优化了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>        ListNode pre = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        ListNode cur = pre;<br>        <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-keyword">null</span> || l2 != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">int</span> x = l1 == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : l1.val;<br>            <span class="hljs-keyword">int</span> y = l2 == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : l2.val;<br>            <span class="hljs-keyword">int</span> sum = x + y + carry;<br>            <br>            carry = sum / <span class="hljs-number">10</span>;<br>            sum = sum % <span class="hljs-number">10</span>;<br>            cur.next = <span class="hljs-keyword">new</span> ListNode(sum);<br><br>            cur = cur.next;<br>            <span class="hljs-keyword">if</span>(l1 != <span class="hljs-keyword">null</span>)<br>                l1 = l1.next;<br>            <span class="hljs-keyword">if</span>(l2 != <span class="hljs-keyword">null</span>)<br>                l2 = l2.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(carry == <span class="hljs-number">1</span>) &#123;<br>            cur.next = <span class="hljs-keyword">new</span> ListNode(carry);<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre.next;<br>    &#125;<br>&#125;<br><br>作者：guanpengchn<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/add-two-numbers/solution/hua-jie-suan-fa-2-liang-shu-xiang-jia-by-guanpengc/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="2｜大整数的减法"><a href="#2｜大整数的减法" class="headerlink" title="2｜大整数的减法"></a>2｜大整数的减法</h4><h4 id="3｜大整数的乘法"><a href="#3｜大整数的乘法" class="headerlink" title="3｜大整数的乘法"></a>3｜大整数的乘法</h4><h4 id="4｜大整数的除法"><a href="#4｜大整数的除法" class="headerlink" title="4｜大整数的除法"></a>4｜大整数的除法</h4><h4 id="5｜初余定理"><a href="#5｜初余定理" class="headerlink" title="5｜初余定理"></a>5｜初余定理</h4><blockquote><h4 id="1680-连接连续二进制数字"><a href="#1680-连接连续二进制数字" class="headerlink" title="1680. 连接连续二进制数字"></a><a href="https://leetcode-cn.com/problems/concatenation-of-consecutive-binary-numbers/">1680. 连接连续二进制数字</a></h4></blockquote><h4 id="5｜例题"><a href="#5｜例题" class="headerlink" title="5｜例题"></a>5｜例题</h4>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>algorithm,math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3-Codewars-2021-4-9</title>
    <link href="/2021/04/09/7-Codewars-2021-4-9/"/>
    <url>/2021/04/09/7-Codewars-2021-4-9/</url>
    
    <content type="html"><![CDATA[<h4 id="1｜题目1-Test1-2-3"><a href="#1｜题目1-Test1-2-3" class="headerlink" title="1｜题目1:Test1-2-3"></a>1｜题目1:<a href="">Test1-2-3</a></h4><h5 id="1｜My-Solution"><a href="#1｜My-Solution" class="headerlink" title="1｜My Solution"></a>1｜My Solution</h5><blockquote><p>解题思路：</p><p>坑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">number</span>(<span class="hljs-params">lines</span>):</span><br>    s = <span class="hljs-string">&quot;&quot;</span><br>    mlist = []<br>    mdir =&#123;&#125;<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(lines)+<span class="hljs-number">1</span>):<br>        mdir[i] = lines[i-<span class="hljs-number">1</span>]<br>        s = <span class="hljs-string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i,mdir[i])<br>        mlist.append(s)<br>    <span class="hljs-keyword">return</span> mlist<br></code></pre></td></tr></table></figure></blockquote><h5 id="2｜Good-Solution"><a href="#2｜Good-Solution" class="headerlink" title="2｜Good Solution"></a>2｜Good Solution</h5><blockquote><p>解题思路：</p><p>坑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">number</span>(<span class="hljs-params">lines</span>):</span><br>  <span class="hljs-keyword">return</span> [<span class="hljs-string">&#x27;%d: %s&#x27;</span> % v <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(lines, <span class="hljs-number">1</span>)]<br></code></pre></td></tr></table></figure><p>语法：</p><p>1、enumerate、list、set类型的双值for循环</p><p>2、为什么dir类型不可以双值for循环？</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>CodeWars</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3-Codewars-2021-4-8</title>
    <link href="/2021/04/08/7-Codewars-2021-4-8/"/>
    <url>/2021/04/08/7-Codewars-2021-4-8/</url>
    
    <content type="html"><![CDATA[<h4 id="题目1-Break-camelCase"><a href="#题目1-Break-camelCase" class="headerlink" title="题目1:    Break camelCase"></a>题目1:    <a href="https://www.codewars.com/kata/5208f99aee097e6552000148/solutions/python">Break camelCase</a></h4><p><code>string</code></p><h5 id="1｜My-Solution"><a href="#1｜My-Solution" class="headerlink" title="1｜My Solution"></a>1｜My Solution</h5><blockquote><p>解题思路：</p><p>遍历string，查找出大写字母，在大写字母前加入’(space)’，然后在加入s[i];</p><p>坑：</p><p>range[左闭右开，所以下标取不到max)</p></blockquote><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">solution</span>(<span class="hljs-params">s</span>):</span><br>    res = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>        <span class="hljs-keyword">if</span> s[i] &lt; <span class="hljs-string">&#x27;a&#x27;</span>:<br>            res += <span class="hljs-string">&#x27; &#x27;</span><br>            res +=s[i]<br>        <span class="hljs-keyword">else</span>:<br>            res += s[i]<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure></blockquote><h5 id="2｜Good-Solution"><a href="#2｜Good-Solution" class="headerlink" title="2｜Good Solution"></a>2｜Good Solution</h5><blockquote><p>解题思路:同上，但是代码更加简洁</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">solution</span>(<span class="hljs-params">s</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(<span class="hljs-string">&#x27; &#x27;</span> + c <span class="hljs-keyword">if</span> c.isupper() <span class="hljs-keyword">else</span> c <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s)<br></code></pre></td></tr></table></figure><p>语法：</p><p>str.join(iterable):</p><p>iterable相当于对象，如果<code>c.isupper()== True</code>的话，对象变为<code>‘ ’+c</code>,否则的话是加入<code>c</code></p></blockquote><blockquote><p>解题思路：利用正则表达式[没掌握]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">solution</span>(<span class="hljs-params">s</span>):</span><br>    <span class="hljs-keyword">return</span> re.sub(<span class="hljs-string">&#x27;([A-Z])&#x27;</span>, <span class="hljs-string">r&#x27; \1&#x27;</span>, s)<br></code></pre></td></tr></table></figure><p>语法：正则表达式<code>re.sub（）</code></p><p><code>re.sub(*pattern*, *repl*, *string*, *count=0*, *flags=0*)</code></p><p><code>pattern</code>：匹配规则</p><p><code>repl</code>：</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>CodeWars</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1-AL-位运算</title>
    <link href="/2021/04/08/1-AL-%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2021/04/08/1-AL-%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h4 id="1｜位运算"><a href="#1｜位运算" class="headerlink" title="1｜位运算"></a>1｜位运算</h4><h4 id="2｜例题"><a href="#2｜例题" class="headerlink" title="2｜例题"></a>2｜例题</h4><h5 id="1｜191-位1的个数"><a href="#1｜191-位1的个数" class="headerlink" title="1｜191. 位1的个数"></a>1｜<a href="https://leetcode-cn.com/problems/number-of-1-bits/">191. 位1的个数</a></h5><h6 id="1｜解题思路"><a href="#1｜解题思路" class="headerlink" title="1｜解题思路"></a>1｜解题思路</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ones = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n!=<span class="hljs-number">0</span>)&#123;<br>            ones += (<span class="hljs-number">1</span>&amp;n);<br>            n &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ones;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="2｜1470-重新排列数组"><a href="#2｜1470-重新排列数组" class="headerlink" title="2｜1470. 重新排列数组"></a>2｜<a href="https://leetcode-cn.com/problems/shuffle-the-array/">1470. 重新排列数组</a></h5><h6 id="1｜My-Solution"><a href="#1｜My-Solution" class="headerlink" title="1｜My Solution"></a>1｜My Solution</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">shuffle</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        &#123;<br>            res.push_back(nums[i]);<br>            res.push_back(nums[i+n]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h6 id="2｜Good-Solution"><a href="#2｜Good-Solution" class="headerlink" title="2｜Good Solution"></a>2｜Good Solution</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">shuffle</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * n; i ++)&#123;<br>            <span class="hljs-keyword">int</span> j = i &lt; n ? <span class="hljs-number">2</span> * i : <span class="hljs-number">2</span> * (i - n) + <span class="hljs-number">1</span>;<br>            nums[j] |= (nums[i] &amp; <span class="hljs-number">1023</span>) &lt;&lt; <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>&amp; e: nums) e &gt;&gt;= <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br><br>作者：liuyubobobo<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/shuffle-the-array/solution/kong-jian-fu-za-du-wei-o1-de-liang-chong-jie-fa-by/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">shuffle</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * n; i ++)<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span>)&#123;<br>                <br>                <span class="hljs-comment">// j 描述当前的 nums[i] 对应的索引，初始为 i</span><br>                <span class="hljs-keyword">int</span> j = i; <br><br>                <span class="hljs-keyword">while</span>(nums[i] &gt; <span class="hljs-number">0</span>)&#123;<br><br>                    <span class="hljs-comment">// 计算 j 索引的元素，也就是现在的 nums[i]，应该放置的索引</span><br>                    j = j &lt; n ? <span class="hljs-number">2</span> * j : <span class="hljs-number">2</span> * (j - n) + <span class="hljs-number">1</span>; <br><br>                    <span class="hljs-comment">// 把 nums[i] 放置到 j 的位置，</span><br>                    <span class="hljs-comment">// 同时，把 nums[j] 放到 i 的位置，在下一轮循环继续处理</span><br>                    swap(nums[i], nums[j]); <br><br>                    <span class="hljs-comment">// 使用负号标记上，现在 j 位置存储的元素已经是正确的元素了 </span><br>                    nums[j] = -nums[j]; <br>                &#125;<br>            &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>&amp; e: nums) e = -e;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br><br>作者：liuyubobobo<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/shuffle-the-array/solution/kong-jian-fu-za-du-wei-o1-de-liang-chong-jie-fa-by/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>algorithm</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1-AL-Array</title>
    <link href="/2021/04/05/1-AL-Array/"/>
    <url>/2021/04/05/1-AL-Array/</url>
    
    <content type="html"><![CDATA[<h4 id="1｜Array"><a href="#1｜Array" class="headerlink" title="1｜Array"></a>1｜Array</h4><h4 id="2｜Vector"><a href="#2｜Vector" class="headerlink" title="2｜Vector"></a>2｜Vector</h4><h4 id="3｜例题"><a href="#3｜例题" class="headerlink" title="3｜例题"></a>3｜例题</h4><h5 id="1｜例1-66-加一"><a href="#1｜例1-66-加一" class="headerlink" title="1｜例1:66. 加一"></a>1｜例1:<a href="https://leetcode-cn.com/problems/plus-one/">66. 加一</a></h5><h6 id="1｜My-Solution"><a href="#1｜My-Solution" class="headerlink" title="1｜My Solution"></a>1｜My Solution</h6><blockquote><p>解题思路：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">plusOne</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; digits)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = digits.size()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> n = <span class="hljs-number">1</span>,m;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=len;i&gt;<span class="hljs-number">-1</span>;i--)<br>        &#123;<br>            m = (digits[i]+n)/<span class="hljs-number">10</span>;<br>            digits[i] = (digits[i]+n) % <span class="hljs-number">10</span>;<br>            n = m;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(digits[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(!digits.empty())  digits.pop_back();<br>            digits.push_back(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=len;i++) digits.push_back(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> digits;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="2｜67-二进制求和"><a href="#2｜67-二进制求和" class="headerlink" title="2｜67. 二进制求和"></a>2｜<a href="https://leetcode-cn.com/problems/add-binary/">67. 二进制求和</a></h5><h6 id="1｜My-Solution-1"><a href="#1｜My-Solution-1" class="headerlink" title="1｜My Solution"></a>1｜My Solution</h6><h5 id="3｜118-杨辉三角"><a href="#3｜118-杨辉三角" class="headerlink" title="3｜118. 杨辉三角"></a>3｜<a href="https://leetcode-cn.com/problems/pascals-triangle/">118. 杨辉三角</a></h5><h6 id="1｜My-Solution-2"><a href="#1｜My-Solution-2" class="headerlink" title="1｜My Solution"></a>1｜My Solution</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; generate(<span class="hljs-keyword">int</span> numRows) &#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(numRows == <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; init_1 = &#123;<span class="hljs-number">1</span>&#125;;<br>        res.push_back(init_1);<br>        <span class="hljs-keyword">if</span>(numRows == <span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; init_2 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;;<br>        res.push_back(init_2);<br>        <span class="hljs-keyword">if</span>(numRows == <span class="hljs-number">2</span>)    <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;numRows;i++)<br>        &#123;<br>            <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; temp;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=i;j++)   <br>            &#123;<br>                <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span> || j==i)   temp.push_back(<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">else</span>               temp.push_back(res[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + res[i<span class="hljs-number">-1</span>][j]);<br>            &#125;<br>            res.push_back(temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h6 id="2｜LeetCode-Solution"><a href="#2｜LeetCode-Solution" class="headerlink" title="2｜LeetCode Solution"></a>2｜LeetCode Solution</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; generate(<span class="hljs-keyword">int</span> numRows) &#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; ret(numRows);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numRows; ++i) &#123;<br>            ret[i].resize(i + <span class="hljs-number">1</span>);<br>            ret[i][<span class="hljs-number">0</span>] = ret[i][i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; i; ++j) &#123;<br>                ret[i][j] = ret[i - <span class="hljs-number">1</span>][j] + ret[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/pascals-triangle/solution/yang-hui-san-jiao-by-leetcode-solution-lew9/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h6 id="3｜Good-Solution"><a href="#3｜Good-Solution" class="headerlink" title="3｜Good Solution"></a>3｜Good Solution</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; generate(<span class="hljs-keyword">int</span> numRows) &#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numRows; ++i)<br>        &#123;<br>            <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(i+<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span></span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; i; ++j)<br>                temp[j] = ans[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+ans[i<span class="hljs-number">-1</span>][j];<br>            ans.push_back(temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br>作者：Xiaohu9527<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/pascals-triangle/solution/cdong-tai-gui-hua-you-mei-dai-ma-xiang-x-p1po/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h5 id="4｜121-买卖股票的最佳时机"><a href="#4｜121-买卖股票的最佳时机" class="headerlink" title="4｜121. 买卖股票的最佳时机"></a>4｜<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h5><h6 id="1｜My-Solution-3"><a href="#1｜My-Solution-3" class="headerlink" title="1｜My Solution"></a>1｜My Solution</h6><p><code>Stack</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">解题思路：</span><br><span class="hljs-comment">1、找到数组中差值最大的两个元素</span><br><span class="hljs-comment">2、暴力：双循环</span><br><span class="hljs-comment">3、线性：单调栈</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res[N] = &#123;<span class="hljs-number">0</span>&#125;,top = <span class="hljs-number">-1</span>,max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(prices.size() == <span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i &lt; prices.size();i++)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(top &gt;=<span class="hljs-number">0</span> &amp;&amp; prices[i] &lt; res[<span class="hljs-number">0</span>] &amp;&amp; i != prices.size()<span class="hljs-number">-1</span>)    top--;<br>            <span class="hljs-keyword">if</span>(top == <span class="hljs-number">-1</span>)   res[++top] = prices[i];<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(res[top] &lt; prices[i])    res[++top] = prices[i];<br>                <span class="hljs-keyword">else</span>    <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(res[top] - res[<span class="hljs-number">0</span>] &gt; max) max = res[top]- res[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h6 id="2｜Leetcode-Solution"><a href="#2｜Leetcode-Solution" class="headerlink" title="2｜Leetcode Solution"></a>2｜Leetcode Solution</h6><p><code>Array</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> inf = <span class="hljs-number">1e9</span>;<br>        <span class="hljs-keyword">int</span> minprice = inf, maxprofit = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> price: prices) &#123;<br>            maxprofit = max(maxprofit, price - minprice);<br>            minprice = min(price, minprice);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxprofit;<br>    &#125;<br>&#125;;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/121-mai-mai-gu-piao-de-zui-jia-shi-ji-by-leetcode-/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h6 id="3｜Good-Solution-1"><a href="#3｜Good-Solution-1" class="headerlink" title="3｜Good Solution"></a>3｜Good Solution</h6><p><code>DP</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProfit</span>(<span class="hljs-params">self, prices: List[<span class="hljs-built_in">int</span>]</span>) -&gt; int:</span><br>        dp0 = <span class="hljs-number">0</span>             <span class="hljs-comment"># 一直不买</span><br>        dp1 = - prices[<span class="hljs-number">0</span>]   <span class="hljs-comment"># 只买了一次</span><br>        dp2 = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;-inf&#x27;</span>) <span class="hljs-comment"># 买了一次，卖了一次</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(prices)):<br>            dp1 = <span class="hljs-built_in">max</span>(dp1, dp0 - prices[i])<br>            dp2 = <span class="hljs-built_in">max</span>(dp2, dp1 + prices[i])<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp0, dp2)<br><br>作者：edelweisskoko<br>链接：https://leetcode-cn.com/problems/best-time-to-buy-<span class="hljs-keyword">and</span>-sell-stock/solution/<span class="hljs-number">121</span>-mai-mai-gu-piao-de-zui-jia-shi-ji-zu-1v0i/<br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h5 id="5｜9-回文数"><a href="#5｜9-回文数" class="headerlink" title="5｜9. 回文数"></a>5｜<a href="https://leetcode-cn.com/problems/palindrome-number/">9. 回文数</a></h5><h6 id="1｜My-Solution-4"><a href="#1｜My-Solution-4" class="headerlink" title="1｜My Solution"></a>1｜My Solution</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>( x &lt; <span class="hljs-number">0</span> ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>( x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; <span class="hljs-number">10</span>)    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res = <span class="hljs-number">0</span>,count = <span class="hljs-number">-1</span>,n1 = x,n2 = x;<br>        <span class="hljs-keyword">while</span>( n1 != <span class="hljs-number">0</span>)<br>        &#123;<br>            n1 /= <span class="hljs-number">10</span>;<br>            count ++;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(n2 != <span class="hljs-number">0</span> &amp;&amp; count &gt;=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">int</span> temp = n2 % <span class="hljs-number">10</span>;<br>            res += temp * <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>,count--);<br>            n2 /= <span class="hljs-number">10</span>; <br>        &#125;<br>        <span class="hljs-keyword">if</span>(res == x)    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h6 id="2｜LeetCode"><a href="#2｜LeetCode" class="headerlink" title="2｜LeetCode"></a>2｜LeetCode</h6><blockquote><p>解题思路：</p><p>对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以 10 的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以 10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。</p><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/palindrome-number/solution/hui-wen-shu-by-leetcode-solution/">https://leetcode-cn.com/problems/palindrome-number/solution/hui-wen-shu-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-04-07-012133.png" alt="image-20210407092133531" style="zoom:50%;" /></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-comment">// 特殊情况：</span><br>        <span class="hljs-comment">// 如上所述，当 x &lt; 0 时，x 不是回文数。</span><br>        <span class="hljs-comment">// 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span><br>        <span class="hljs-comment">// 则其第一位数字也应该是 0</span><br>        <span class="hljs-comment">// 只有 0 满足这一属性</span><br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || (x % <span class="hljs-number">10</span> == <span class="hljs-number">0</span> &amp;&amp; x != <span class="hljs-number">0</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> revertedNumber = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (x &gt; revertedNumber) &#123;<br>            revertedNumber = revertedNumber * <span class="hljs-number">10</span> + x % <span class="hljs-number">10</span>;<br>            x /= <span class="hljs-number">10</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span><br>        <span class="hljs-comment">// 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span><br>        <span class="hljs-comment">// 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span><br>        <span class="hljs-keyword">return</span> x == revertedNumber || x == revertedNumber / <span class="hljs-number">10</span>;<br>    &#125;<br>&#125;;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/palindrome-number/solution/hui-wen-shu-by-leetcode-solution/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><blockquote><p>关键语句：</p><p><code>revertedNumber = revertedNumber * 10 + x % 10;</code></p></blockquote><h6 id="3｜Good-Solution-2"><a href="#3｜Good-Solution-2" class="headerlink" title="3｜Good Solution"></a>3｜Good Solution</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> ret=<span class="hljs-number">0</span>,max=<span class="hljs-number">0x7fffffff</span>,min=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">long</span> rs=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(;x;rs=rs*<span class="hljs-number">10</span>+x%<span class="hljs-number">10</span>,x/=<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">return</span> ret=rs&gt;max||rs&lt;min?<span class="hljs-number">0</span>:rs;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x==reverse(x);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="6｜7-整数反转"><a href="#6｜7-整数反转" class="headerlink" title="6｜7. 整数反转"></a>6｜<a href="https://leetcode-cn.com/problems/reverse-integer/">7. 整数反转</a></h5><h6 id="1｜My-Solution-5"><a href="#1｜My-Solution-5" class="headerlink" title="1｜My Solution"></a>1｜My Solution</h6><blockquote><p>解题思路</p></blockquote><blockquote><p>坑：</p><p>1、整数溢出的问题，因为x为int类型,如果说x反转后超出范围则发生溢出的情况，所以要考虑清楚。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>  n = x,res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(x &gt; <span class="hljs-number">2147483647</span> <span class="hljs-keyword">or</span> x &lt; <span class="hljs-number">-2147483647</span>)   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span>)   n = -x;<br>        <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>)<br>        &#123;<br>            res = res * <span class="hljs-number">10</span> + n % <span class="hljs-number">10</span>;<br>            n /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (res &gt; <span class="hljs-number">2147483647</span> <span class="hljs-keyword">or</span> res &lt; <span class="hljs-number">-2147483647</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> )    <span class="hljs-keyword">return</span> -res;<br>        <span class="hljs-keyword">else</span>           <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h6 id="2｜Leetcode-Solution-1"><a href="#2｜Leetcode-Solution-1" class="headerlink" title="2｜Leetcode Solution"></a>2｜Leetcode Solution</h6><blockquote><p>解题思路：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> rev = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span> pop = x % <span class="hljs-number">10</span>;<br>            x /= <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span> (rev &gt; INT_MAX/<span class="hljs-number">10</span> || (rev == INT_MAX / <span class="hljs-number">10</span> &amp;&amp; pop &gt; <span class="hljs-number">7</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (rev &lt; INT_MIN/<span class="hljs-number">10</span> || (rev == INT_MIN / <span class="hljs-number">10</span> &amp;&amp; pop &lt; <span class="hljs-number">-8</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            rev = rev * <span class="hljs-number">10</span> + pop;<br>        &#125;<br>        <span class="hljs-keyword">return</span> rev;<br>    &#125;<br>&#125;;<br><br>作者：LeetCode<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/reverse-integer/solution/zheng-shu-fan-zhuan-by-leetcode/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h5 id="7｜303-区域和检索-数组不可变"><a href="#7｜303-区域和检索-数组不可变" class="headerlink" title="7｜303. 区域和检索 - 数组不可变"></a>7｜<a href="https://leetcode-cn.com/problems/range-sum-query-immutable/">303. 区域和检索 - 数组不可变</a></h5><p><code>前缀和</code></p><h6 id="1｜My-Solution-6"><a href="#1｜My-Solution-6" class="headerlink" title="1｜My Solution"></a>1｜My Solution</h6><blockquote><p>解题思路：就是考察类的构造,</p><p>题目的坑：想的少了，没有进行优化，会发生TLE</p><p>最朴素的想法是存储数组 nums\textit{nums}nums 的值，每次调用 sumRange\text{sumRange}sumRange 时，通过循环的方法计算数组 nums\textit{nums}nums 从下标 iii 到下标 jjj 范围内的元素和，需要计算 j−i+1j-i+1j−i+1 个元素的和。由于每次检索的时间和检索的下标范围有关，因此检索的时间复杂度较高，如果检索次数较多，则会超出时间限制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumArray</span> &#123;</span><br> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<br><span class="hljs-keyword">public</span>:<br> NumArray(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it:nums)<br>         res.push_back(it);<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>     <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left;i&lt;=right;i++)    sum+=res[i];<br>     <span class="hljs-keyword">return</span> sum;<br> &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumArray* obj = new NumArray(nums);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;sumRange(left,right);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure></blockquote><h6 id="2｜LeetCode-1"><a href="#2｜LeetCode-1" class="headerlink" title="2｜LeetCode"></a>2｜LeetCode</h6><blockquote><p>解题思路：实现$O(1)$时间复杂度内，返回[left,right]的和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumArray</span> &#123;</span><br> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<br><span class="hljs-keyword">public</span>:<br> NumArray(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>     <span class="hljs-keyword">int</span> n = nums.size();<br>     res.resize(n+<span class="hljs-number">1</span>);<br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    res[i+<span class="hljs-number">1</span>] = res[i] + nums[i];<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>     <span class="hljs-keyword">return</span> res[right+<span class="hljs-number">1</span>] - res[left];<br> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></blockquote><h6 id="3｜Good-Solution-3"><a href="#3｜Good-Solution-3" class="headerlink" title="3｜Good Solution"></a>3｜Good Solution</h6><blockquote><p>链接：<a href="https://leetcode-cn.com/problems/range-sum-query-immutable/solution/ni-yong-yuan-ke-yi-xiang-xin-fen-kuai-su-ugou/">https://leetcode-cn.com/problems/range-sum-query-immutable/solution/ni-yong-yuan-ke-yi-xiang-xin-fen-kuai-su-ugou/</a></p></blockquote><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumArray</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br> <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> block_size = <span class="hljs-number">100</span>;<br> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums;<br> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; block_sum;<br><br><span class="hljs-keyword">public</span>:<br> NumArray(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>     <span class="hljs-keyword">this</span>-&gt;nums = nums;<br><br>     <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">while</span> (i + block_size &lt;= nums.size()) &#123;<br>         block_sum.push_back(accumulate(nums.begin() + i, nums.begin() + i + block_size, <span class="hljs-number">0</span>));<br>         i += block_size;<br>     &#125;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>     <span class="hljs-keyword">int</span> k = i, ans = <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">while</span> (k &lt;= j) &#123;<br>         <span class="hljs-keyword">if</span> (k % block_size == <span class="hljs-number">0</span> &amp;&amp; k + block_size - <span class="hljs-number">1</span> &lt;= j) &#123;<br>             ans += block_sum[k / block_size];<br>             k += block_size;<br>         &#125;<br>         <span class="hljs-keyword">else</span> &#123;<br>             ans += nums[k];<br>             ++k;<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> ans;<br> &#125;<br>&#125;;<br><br>作者：zerotrac2<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/range-sum-query-immutable/solution/ni-yong-yuan-ke-yi-xiang-xin-fen-kuai-su-ugou/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1-AL-Finding</title>
    <link href="/2021/04/05/1-AL-Search/"/>
    <url>/2021/04/05/1-AL-Search/</url>
    
    <content type="html"><![CDATA[<h3 id="1｜二分查找"><a href="#1｜二分查找" class="headerlink" title="1｜二分查找"></a>1｜二分查找</h3><h3 id="2｜例题"><a href="#2｜例题" class="headerlink" title="2｜例题"></a>2｜例题</h3><h4 id="1｜35-搜索插入位置"><a href="#1｜35-搜索插入位置" class="headerlink" title="1｜35. 搜索插入位置"></a>1｜<a href="https://leetcode-cn.com/problems/search-insert-position/">35. 搜索插入位置</a></h4><h5 id="1｜My-Solution"><a href="#1｜My-Solution" class="headerlink" title="1｜My Solution"></a>1｜My Solution</h5><blockquote><p>解题思路：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//返回时下标</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>,right = nums.size()<span class="hljs-number">-1</span>,mid,res;<br>        <span class="hljs-keyword">while</span>(left &lt; right)<br>        &#123;<br>            mid = (left+right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(target == nums[mid])             <span class="hljs-keyword">return</span> mid;<br>            (target &lt; nums[mid]) ? right = mid : left = mid +<span class="hljs-number">1</span>;<br>        &#125;                <br>        <span class="hljs-keyword">if</span>(nums[left] &lt; target)              <span class="hljs-keyword">return</span>  left+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span>                                 <span class="hljs-keyword">return</span>  left;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="1｜69-x-的平方根"><a href="#1｜69-x-的平方根" class="headerlink" title="1｜69. x 的平方根"></a>1｜<a href="https://leetcode-cn.com/problems/sqrtx/">69. x 的平方根</a></h4><h5 id="1｜My-Solution-1"><a href="#1｜My-Solution-1" class="headerlink" title="1｜My Solution"></a>1｜My Solution</h5><blockquote><p>解题思路：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(x == <span class="hljs-number">1</span> || x == <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> x;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>,r = x,mid,ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l &lt;= r)<br>        &#123;<br>            mid = l+(r-l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>((<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)mid * mid &lt;= x)      <br>            &#123;<br>                ans = mid;<br>                l = mid+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>        r = mid<span class="hljs-number">-1</span>;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2｜81-搜索旋转排序数组-II"><a href="#2｜81-搜索旋转排序数组-II" class="headerlink" title="2｜81. 搜索旋转排序数组 II"></a>2｜<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/">81. 搜索旋转排序数组 II</a></h4>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>0-CPP-Grammar-Class</title>
    <link href="/2021/04/04/0-CPP-Grammar-Class/"/>
    <url>/2021/04/04/0-CPP-Grammar-Class/</url>
    
    <content type="html"><![CDATA[<h4 id="1｜对象和类的概念"><a href="#1｜对象和类的概念" class="headerlink" title="1｜对象和类的概念"></a>1｜对象和类的概念</h4><blockquote><p>1、抽象：对问题进行分、设计提取出其中的本质，这个过程就是抽象的过程。也就是用语言程序来描述出现实生活中的某些特征。</p><p>2、ADT：abstract data types</p><p>The concept of abstraction can be applied to data as well. An <em>abstract data type (ADT)</em> separates the interface of a data type from its implementation, and it encompasses both the data itself as well as functionality on the data.</p><p>以三角形为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// A triangle ADT.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Triangle</span> &#123;</span><br>  <span class="hljs-keyword">double</span> a;<br>  <span class="hljs-keyword">double</span> b;<br>  <span class="hljs-keyword">double</span> c;<br>  <span class="hljs-comment">// INVARIANTS: a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; c &gt; 0 &amp;&amp;</span><br>  <span class="hljs-comment">//             a + b &gt; c &amp;&amp; a + c &gt; b &amp;&amp; b + c &gt; a</span><br>&#125;;<br><span class="hljs-comment">// REQUIRES: tri points to a Triangle object;</span><br><span class="hljs-comment">//           each side length is positive (a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; c &gt; 0);</span><br><span class="hljs-comment">//           the sides meet the triangle inequality</span><br><span class="hljs-comment">//           (a + b &gt; c &amp;&amp; a + c &gt; b &amp;&amp; b + c &gt; a)</span><br><span class="hljs-comment">// MODIFIES: *tri</span><br><span class="hljs-comment">// EFFECTS:  Initializes the triangle with the given side lengths.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Triangle_init</span><span class="hljs-params">(Triangle *tri, <span class="hljs-keyword">double</span> a, <span class="hljs-keyword">double</span> b, <span class="hljs-keyword">double</span> c)</span> </span>&#123;<br>  assert(a &gt; <span class="hljs-number">0</span> &amp;&amp; b &gt; <span class="hljs-number">0</span> &amp;&amp; c &gt; <span class="hljs-number">0</span>);              <span class="hljs-comment">// positive lengths</span><br>  assert(a + b &gt; c &amp;&amp; a + c &gt; b &amp;&amp; b + c &gt; a);  <span class="hljs-comment">// triangle inequality</span><br>  tri-&gt;a = a;<br>  tri-&gt;b = b;<br>  tri-&gt;c = c;<br>&#125;<br><br><span class="hljs-comment">// REQUIRES: tri points to a valid Triangle; s &gt; 0</span><br><span class="hljs-comment">// MODIFIES: *tri</span><br><span class="hljs-comment">// EFFECTS:  Scales the sides of the Triangle by the factor s.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Triangle_scale</span><span class="hljs-params">(Triangle *tri, <span class="hljs-keyword">double</span> s)</span> </span>&#123;<br>  assert(s &gt; <span class="hljs-number">0</span>);  <span class="hljs-comment">// positive lengths</span><br>  tri-&gt;a *= s;<br>  tri-&gt;b *= s;<br>  tri-&gt;c *= s;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// REQUIRES: tri points to a Triangle object;</span><br><span class="hljs-comment">//           each side length is positive (a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; c &gt; 0);</span><br><span class="hljs-comment">//           the sides meet the triangle inequality</span><br><span class="hljs-comment">//           (a + b &gt; c &amp;&amp; a + c &gt; b &amp;&amp; b + c &gt; a)</span><br><span class="hljs-comment">// MODIFIES: *tri</span><br><span class="hljs-comment">// EFFECTS:  Initializes the triangle with the given side lengths.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Triangle_init</span><span class="hljs-params">(Triangle *tri, <span class="hljs-keyword">double</span> a, <span class="hljs-keyword">double</span> b, <span class="hljs-keyword">double</span> c)</span> </span>&#123;<br>  assert(a &gt; <span class="hljs-number">0</span> &amp;&amp; b &gt; <span class="hljs-number">0</span> &amp;&amp; c &gt; <span class="hljs-number">0</span>);              <span class="hljs-comment">// positive lengths</span><br>  assert(a + b &gt; c &amp;&amp; a + c &gt; b &amp;&amp; b + c &gt; a);  <span class="hljs-comment">// triangle inequality</span><br>  tri-&gt;a = a;<br>  tri-&gt;b = b;<br>  tri-&gt;c = c;<br>&#125;<br><br><span class="hljs-comment">// REQUIRES: tri points to a valid Triangle; s &gt; 0</span><br><span class="hljs-comment">// MODIFIES: *tri</span><br><span class="hljs-comment">// EFFECTS:  Scales the sides of the Triangle by the factor s.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Triangle_scale</span><span class="hljs-params">(Triangle *tri, <span class="hljs-keyword">double</span> s)</span> </span>&#123;<br>  assert(s &gt; <span class="hljs-number">0</span>);  <span class="hljs-comment">// positive lengths</span><br>  tri-&gt;a *= s;<br>  tri-&gt;b *= s;<br>  tri-&gt;c *= s;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、接口：</p></blockquote><h4 id="1｜C-中的类"><a href="#1｜C-中的类" class="headerlink" title="1｜C++中的类"></a>1｜C++中的类</h4><h5 id="1｜类的定义"><a href="#1｜类的定义" class="headerlink" title="1｜类的定义"></a>1｜类的定义</h5><blockquote><p>类就是抽象的结果，类将数据表示和操作数据的方法组合成一个整洁的包。</p><p>下面是三角形类的一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">//数据表示</span><br>  <span class="hljs-keyword">double</span> a;<br>  <span class="hljs-keyword">double</span> b;<br>  <span class="hljs-keyword">double</span> c;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">//构造函数</span><br>  Triangle(<span class="hljs-keyword">double</span> a_in, <span class="hljs-keyword">double</span> b_in, <span class="hljs-keyword">double</span> c_in);<br><span class="hljs-comment">//操作数据的方法</span><br>  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">perimeter</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b + c;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">scale</span><span class="hljs-params">(<span class="hljs-keyword">double</span> s)</span> </span>&#123;<br>    a *= s;<br>    b *= s;<br>    c *= s;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></blockquote><h5 id="2｜控制成员的访问"><a href="#2｜控制成员的访问" class="headerlink" title="2｜控制成员的访问"></a>2｜控制成员的访问</h5><blockquote><ul><li><input disabled="" type="checkbox"> 补充完善</li></ul><p>1｜private：私有</p><p>放入的内容由自己确定，但是在private中的成员类外是无法访问的；一般数据项放在私有部分。类中的默认访问类型是private的，与c++中结构体的区别。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span> &#123;</span><br>  <span class="hljs-keyword">double</span> a;<br>  <span class="hljs-keyword">double</span> b;<br>  <span class="hljs-keyword">double</span> c;<br><br><span class="hljs-keyword">public</span>:<br>  Triangle(<span class="hljs-keyword">double</span> a_in, <span class="hljs-keyword">double</span> b_in, <span class="hljs-keyword">double</span> c_in);<br><br>  ...<br>&#125;;<br><br></code></pre></td></tr></table></figure></blockquote><h5 id="3｜构造函数（constructors）"><a href="#3｜构造函数（constructors）" class="headerlink" title="3｜构造函数（constructors）"></a>3｜构造函数（constructors）</h5><blockquote><p>1、构造函数的作用是初始化对象的，如例子所示，是初始化a、b、c的</p><p><code>c语言中还要写init的初始化函数，c++调用构造函数进行初始化</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 构造函数没有返回值类型，有参数的，需要声明参数的类型和参数的名称</span><br><span class="hljs-comment">// 为成员赋值，使用构造函数的参数对类的成员进行赋值</span><br><span class="hljs-comment">// 注意要有&#123;&#125;是干嘛的？</span><br>Triangle(<span class="hljs-keyword">double</span> a_in, <span class="hljs-keyword">double</span> b_in, <span class="hljs-keyword">double</span> c_in)<br> : a(a_in), b(b_in), c(c_in) &#123;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span> &#123;</span><br><span class="hljs-keyword">double</span> a;<br><span class="hljs-keyword">double</span> b;<br><span class="hljs-keyword">double</span> c;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// default constructor,默认构造函数</span><br>Triangle()<br> : a(<span class="hljs-number">1</span>), b(<span class="hljs-number">1</span>), c(<span class="hljs-number">1</span>) &#123;&#125;<br><br><span class="hljs-comment">// non-default constructor，自定义的构造函数</span><br>Triangle(<span class="hljs-keyword">double</span> a_in, <span class="hljs-keyword">double</span> b_in, <span class="hljs-keyword">double</span> c_in)<br> : a(a_in), b(b_in), c(c_in) &#123;&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span> &#123;</span><br><span class="hljs-keyword">double</span> a;<br><span class="hljs-keyword">double</span> b;<br><span class="hljs-keyword">double</span> c;<br><span class="hljs-comment">//In this case, if we want our type to have a default constructor, we have to explicitly write one:</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// explicit default constructor</span><br>Triangle()<br> : a(<span class="hljs-number">1</span>), b(<span class="hljs-number">1</span>), c(<span class="hljs-number">1</span>) &#123;&#125;<br><br><span class="hljs-comment">// non-default constructor</span><br>Triangle(<span class="hljs-keyword">double</span> a_in, <span class="hljs-keyword">double</span> b_in, <span class="hljs-keyword">double</span> c_in)<br> : a(a_in), b(b_in), c(c_in) &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">perimeter</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br> <span class="hljs-keyword">return</span> a + b + c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">scale</span><span class="hljs-params">(<span class="hljs-keyword">double</span> s)</span> </span>&#123;<br> a *= s;<br> b *= s;<br> c *= s;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>Triangle t1;  <span class="hljs-comment">// OK: explicit default constructor</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">Triangle t1;                      <span class="hljs-comment">// calls zero-argument (default) constructor,默认初始化</span><br><span class="hljs-function">Triangle <span class="hljs-title">t2</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)</span></span>;             <span class="hljs-comment">// calls three-argument constructor</span><br>Triangle t3 = Triangle(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);  <span class="hljs-comment">// calls three-argument constructor</span><br><span class="hljs-comment">// examples with &quot;uniform initialization syntax&quot;:</span><br>Triangle t4&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;             <span class="hljs-comment">// calls three-argument constructor</span><br>Triangle t5 = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;          <span class="hljs-comment">// calls three-argument constructor</span><br>Triangle t6 = Triangle&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;  <span class="hljs-comment">// calls three-argument constructor</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>2、系统默认的构造函数没有参数，如果自己定义的构造函数有参数，必须要对参数进行初始化。</p></blockquote><h5 id="3｜成员函数"><a href="#3｜成员函数" class="headerlink" title="3｜成员函数"></a>3｜成员函数</h5><blockquote><p>成员函数按照只读和读写进行分类</p></blockquote><h6 id="1｜只读函数"><a href="#1｜只读函数" class="headerlink" title="1｜只读函数"></a>1｜只读函数</h6><blockquote><p>1、在C++的类中存在一些只读函数，这些函数只访问类的性质，不会对类中的成员及数值进行修改</p><p>2、只读函数用const修饰，保证不会修改调用的对象或者是调用对象的成员</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//声明只读函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><span class="hljs-comment">//定义只读函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stock::show</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> _size;&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="2｜例题"><a href="#2｜例题" class="headerlink" title="2｜例题"></a>2｜例题</h4><blockquote></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>C++,Grammar</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3-Codewars-2021-4-4</title>
    <link href="/2021/04/04/7-Codewars-2021-4-4/"/>
    <url>/2021/04/04/7-Codewars-2021-4-4/</url>
    
    <content type="html"><![CDATA[<h4 id="题目1-Delete-occurrences-of-an-element-if-it-occurs-more-than-n-times"><a href="#题目1-Delete-occurrences-of-an-element-if-it-occurs-more-than-n-times" class="headerlink" title="题目1:Delete occurrences of an element if it occurs more than n times"></a>题目1:Delete occurrences of an element if it occurs more than n times</h4><p><code>哈希表</code> <code>STL</code></p><details><summary>题目要求</summary>  <img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-04-04-003237.png" /></details><h5 id="1｜解题思路："><a href="#1｜解题思路：" class="headerlink" title="1｜解题思路："></a>1｜解题思路：</h5><blockquote><p>相当于去重，可以用数组实现，但是空间复杂度很高</p></blockquote><h5 id="2｜Good-Solution"><a href="#2｜Good-Solution" class="headerlink" title="2｜Good Solution:"></a>2｜Good Solution:</h5><blockquote><p>语法：</p><p>1、使用unordered_map类型建立<code>关键字key = i</code> 与<code>value = 出现次数</code>的映射</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">deleteNth</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr, <span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;res;<br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; resMap;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:arr)<br>    &#123;<br>      <span class="hljs-keyword">if</span>(resMap[i]++ &lt; n)<br>        res.push_back(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2｜题目2-Count-the-Digit"><a href="#2｜题目2-Count-the-Digit" class="headerlink" title="2｜题目2:Count the Digit"></a>2｜题目2:Count the Digit</h4><details><summary>题目要求</summary>  <img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-04-04-013208.png" /></details><h5 id="1｜解题思路：-1"><a href="#1｜解题思路：-1" class="headerlink" title="1｜解题思路："></a>1｜解题思路：</h5><h5 id="2｜My-Solution"><a href="#2｜My-Solution" class="headerlink" title="2｜My Solution"></a>2｜My Solution</h5><h4 id="3｜Ones-and-Zeros"><a href="#3｜Ones-and-Zeros" class="headerlink" title="3｜Ones and Zeros"></a>3｜Ones and Zeros</h4><details><summary>题目要求</summary>  <img src="https://uoruichi.oss-cn-beijing.aliyuncs.com/2021-04-04-014325.png"/></details><h5 id="1｜My-Solution"><a href="#1｜My-Solution" class="headerlink" title="1｜My Solution"></a>1｜My Solution</h5><h6 id="1｜解题思路：-2"><a href="#1｜解题思路：-2" class="headerlink" title="1｜解题思路："></a>1｜解题思路：</h6><blockquote><p>考察二进制的转换过程：找到二进制中$2^n$中n与列表的index的关系</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_array_to_number</span>(<span class="hljs-params">arr</span>):</span><br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> arr[::-<span class="hljs-number">1</span>]:<br>        <span class="hljs-built_in">sum</span> += item*<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,i)<br>        i+=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span><br></code></pre></td></tr></table></figure><h5 id="2｜Good-Solution-1"><a href="#2｜Good-Solution-1" class="headerlink" title="2｜Good Solution"></a>2｜Good Solution</h5><h6 id="1｜解题思路：-3"><a href="#1｜解题思路：-3" class="headerlink" title="1｜解题思路："></a>1｜解题思路：</h6><blockquote><p>考察二进制的转换过程：找到二进制中$2^n$中n与列表的index的关系</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_array_to_number</span>(<span class="hljs-params">arr</span>):</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(<span class="hljs-string">&quot;&quot;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, arr)), <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h6 id="1｜语法："><a href="#1｜语法：" class="headerlink" title="1｜语法："></a>1｜语法：</h6><h4 id="4｜题目4-Highest-Scoring-Word"><a href="#4｜题目4-Highest-Scoring-Word" class="headerlink" title="4｜题目4:Highest Scoring Word"></a>4｜题目4:Highest Scoring Word</h4><details><summary>题目要求</summary>  <img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-04-04-023235.png"/></details><h5 id="1｜My-Solution-1"><a href="#1｜My-Solution-1" class="headerlink" title="1｜My Solution"></a>1｜My Solution</h5><h6 id="1｜解题思路"><a href="#1｜解题思路" class="headerlink" title="1｜解题思路"></a>1｜解题思路</h6><blockquote></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">high</span>(<span class="hljs-params">x</span>):</span><br>    <span class="hljs-built_in">max</span> = <span class="hljs-number">0</span><br>    dex = <span class="hljs-number">0</span><br>    res = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> x.split():<br>        <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> item:<br>            <span class="hljs-built_in">sum</span> += <span class="hljs-built_in">ord</span>(c)-<span class="hljs-number">96</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">max</span> &lt; <span class="hljs-built_in">sum</span>:<br>            <span class="hljs-built_in">max</span> = <span class="hljs-built_in">sum</span><br>            res = item<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h5 id="2｜Good-Solution-2"><a href="#2｜Good-Solution-2" class="headerlink" title="2｜Good Solution"></a>2｜Good Solution</h5><h6 id="1｜解题思路-1"><a href="#1｜解题思路-1" class="headerlink" title="1｜解题思路"></a>1｜解题思路</h6>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>python</tag>
      
      <tag>Coderwar</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3-Codewars-2021-4-3</title>
    <link href="/2021/04/03/7-Codewars-2021-4-3/"/>
    <url>/2021/04/03/7-Codewars-2021-4-3/</url>
    
    <content type="html"><![CDATA[<h4 id="1｜题目1-Give-me-a-Diamond"><a href="#1｜题目1-Give-me-a-Diamond" class="headerlink" title="1｜题目1:Give me a Diamond"></a>1｜题目1:Give me a Diamond</h4><p><code>string</code> </p><details><summary>题目要求</summary>  <img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-04-03-013929.png" /></details><h5 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h5><blockquote><p>解题思路：</p><p>1、就是找规律，但是要将规律标记清楚，不能就是一味的尝试，用变量标识清楚关系就很简单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">diamond</span>(<span class="hljs-params">n</span>):</span><br>    res = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> n&lt;=<span class="hljs-number">0</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">else</span>:<br>        i = (n+<span class="hljs-number">1</span>) // <span class="hljs-number">2</span>       <span class="hljs-comment"># 代表 &quot; * &quot;+&quot; &quot;</span><br>        j =  <span class="hljs-number">1</span>               <span class="hljs-comment"># 代表 “*”</span><br>        k = i-<span class="hljs-number">1</span>              <span class="hljs-comment"># 代表 “ ”</span><br>        <span class="hljs-keyword">while</span>(j &lt;= n):<br>            res += <span class="hljs-string">&#x27; &#x27;</span>*k<br>            res += <span class="hljs-string">&#x27;*&#x27;</span>*j<br>            res += <span class="hljs-string">&#x27;\n&#x27;</span><br>            j += <span class="hljs-number">2</span><br>            k -= <span class="hljs-number">1</span><br>        l = n-<span class="hljs-number">1</span>              <span class="hljs-comment"># 代表 &quot; * &quot;+&quot; &quot;</span><br>        m = <span class="hljs-number">1</span>               <span class="hljs-comment"># 代表 “ ”</span><br>        n = l - <span class="hljs-number">1</span>           <span class="hljs-comment"># 代表 “*”</span><br>        <span class="hljs-keyword">while</span>(n &gt;=<span class="hljs-number">1</span>):<br>            res += <span class="hljs-string">&#x27; &#x27;</span>*m<br>            res += <span class="hljs-string">&#x27;*&#x27;</span>*n<br>            res += <span class="hljs-string">&#x27;\n&#x27;</span><br>            n -= <span class="hljs-number">2</span><br>            m += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure></blockquote><h5 id="Good-Solution"><a href="#Good-Solution" class="headerlink" title="Good Solution"></a>Good Solution</h5><blockquote><p>解题思路：</p><p>1、之前尝试过绝对值，但是没有找出来后半部分的规律</p></blockquote><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">diamond</span>(<span class="hljs-params">n</span>):</span><br>    <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:<br>        diamond = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            diamond += <span class="hljs-string">&quot; &quot;</span> * <span class="hljs-built_in">abs</span>((n/<span class="hljs-number">2</span>) - i)<br>            diamond += <span class="hljs-string">&quot;*&quot;</span> * (n - <span class="hljs-built_in">abs</span>((n-<span class="hljs-number">1</span>) - <span class="hljs-number">2</span> * i))<br>            diamond += <span class="hljs-string">&quot;\n&quot;</span><br>        <span class="hljs-keyword">return</span> diamond<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="题目2-Two-fighters-one-winner"><a href="#题目2-Two-fighters-one-winner" class="headerlink" title="题目2:Two fighters, one winner."></a>题目2:Two fighters, one winner.</h4><p><code>Classes</code> <code>Object-oriented Programming</code></p><details><summary>题目要求</summary>  <img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-04-03-015325.png" /></details>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>Codewars</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1-AL-Recursion</title>
    <link href="/2021/04/02/1-AL-Recursion/"/>
    <url>/2021/04/02/1-AL-Recursion/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1-AL-DP</title>
    <link href="/2021/04/02/1-AL-DP/"/>
    <url>/2021/04/02/1-AL-DP/</url>
    
    <content type="html"><![CDATA[<h4 id="1｜动态规划"><a href="#1｜动态规划" class="headerlink" title="1｜动态规划"></a>1｜动态规划</h4><p><code>递归</code> <code>递推</code> <code>重叠子问题</code></p><blockquote><p>动态规划：最优化问题的算法思想，也就是说他是求最值之类的算法思想。</p><p>动态规划讲一个复杂的问题分解成为若干个子问题，通过综合子问题的最优解来得到原问题的最优解。关键在于动态规划会讲每个求过的子问题的解记录下来，碰到同样的子问题时，就可以直接使用之前记录的结果，避免了重复计算。（求前缀和是不是也是动态规划的一种思想）。</p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-04-09-011947.png" alt="image-20210409091947270" style="zoom:50%;" /><p>也就是说一个问题必须具有重叠子问题（如果一个问题可以被分解为若干个子问题，且这些子问题会重复出现，那么就称这个问题具有重叠子问题）。</p><p>人话：通过找规律以及记录，优化递归。空间换时间，通过定义变量和利用程序执行的有序性，减少递归中归的过程。</p><p>动态规划主要通过递归和递推来实现，貌似递推要比递归效率更高。</p></blockquote><h4 id="2｜例题"><a href="#2｜例题" class="headerlink" title="2｜例题"></a>2｜例题</h4><h5 id="1｜70-爬楼梯"><a href="#1｜70-爬楼梯" class="headerlink" title="1｜70. 爬楼梯"></a>1｜<a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a></h5><h5 id="2｜1539-第-k-个缺失的正整数"><a href="#2｜1539-第-k-个缺失的正整数" class="headerlink" title="2｜1539. 第 k 个缺失的正整数"></a>2｜<a href="https://leetcode-cn.com/problems/kth-missing-positive-number/">1539. 第 k 个缺失的正整数</a></h5><h6 id="1｜My-Solution"><a href="#1｜My-Solution" class="headerlink" title="1｜My Solution"></a>1｜My Solution</h6><blockquote><p>解题思路：DP问题</p><p>利用数组存储之前缺失数字的个数</p><p>坑：找好关系</p><p>优化：可以不创建数组进行优化的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthPositive</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-keyword">int</span> ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=arr.size();i++)  res.push_back(arr[i<span class="hljs-number">-1</span>] - i);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.size();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(k &lt;= res[i])         <br>            &#123;<br>                ans =  arr[i]-(res[i]-k+<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i == res.size()<span class="hljs-number">-1</span>)   ans = arr[arr.size()<span class="hljs-number">-1</span>]+k-res[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 优化</li></ul></blockquote><h6 id="2｜LeetCode"><a href="#2｜LeetCode" class="headerlink" title="2｜LeetCode"></a>2｜LeetCode</h6><blockquote><p>解题思路：二分查找，因为题目中的条件时严格递增的，所以使用二分也可以进行查找。</p></blockquote><h5 id="3｜53-最大子序和"><a href="#3｜53-最大子序和" class="headerlink" title="3｜53. 最大子序和"></a>3｜<a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和</a></h5>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1-AL-MergeSort</title>
    <link href="/2021/04/02/1-AL-MergeSort/"/>
    <url>/2021/04/02/1-AL-MergeSort/</url>
    
    <content type="html"><![CDATA[<h3 id="1｜归并排序"><a href="#1｜归并排序" class="headerlink" title="1｜归并排序"></a>1｜归并排序</h3><h3 id="2｜例题"><a href="#2｜例题" class="headerlink" title="2｜例题"></a>2｜例题</h3><h4 id="1｜面试题-10-01-合并排序的数组"><a href="#1｜面试题-10-01-合并排序的数组" class="headerlink" title="1｜面试题 10.01. 合并排序的数组"></a>1｜<a href="https://leetcode-cn.com/problems/sorted-merge-lcci/">面试题 10.01. 合并排序的数组</a></h4><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-04-02-074519.png" alt="image-20210402154517550"></p><blockquote><p>题目要素：</p><p>1、A、B数组已经有序</p><p>解题思想：</p><p>1、先将A和B合并，然后在利用sort（）排序【归并排序】，时间复杂度为$O(log(m+n)+O(n))$</p><p>2、双指针算法：空间换时间，时间复杂度为$O(n+m)$</p><p>My Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 先合并，后排序</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;A,<span class="hljs-keyword">int</span> m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;B,<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=m,j=<span class="hljs-number">0</span>;j&lt;n;i++,j++)A.push_back(B[j]);<br>    sort(A.begin(),A.end());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//双指针</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; A, <span class="hljs-keyword">int</span> m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; B, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res[m+n];<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>,p=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt;m &amp;&amp; j&lt;n)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(i &lt; m &amp;&amp; A[i] &lt;= B[j])<br>            &#123;<br>                res[p++] = A[i];<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(j &lt; n &amp;&amp; B[j] &lt; A[i])<br>            &#123;<br>                res[p++] = B[j];<br>                j++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>( i &lt; m)<br>        &#123;<br>            res[p++] = A[i];<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">while</span>( j &lt; n)<br>        &#123;<br>            res[p++] = B[j];<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;p;i++)    A[i] = res[i];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Good Solution:</p><p>解题思路：就地存入，以m和n作为指针进行操作，从大到小存入；</p><p>坑：</p><p>1、<code>A[--m]:B[--n]</code>只能使用<code>--m</code>不能使用<code>m--</code></p><p>2、<code>A[res] = A[m-1] &gt; B[n-1] ? A[--m]:B[--n];</code>精彩的表达</p><p>3、因为A[m]标识A数组中的元素，所以最后只需要判断<code>n&gt;0</code>无需判断<code>m&gt;0</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; A, <span class="hljs-keyword">int</span> m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; B, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(m &gt; <span class="hljs-number">0</span> &amp;&amp; n &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">//if bound</span><br>        &#123;<br>            <span class="hljs-keyword">int</span> res = m+n<span class="hljs-number">-1</span>;<span class="hljs-comment">//insert pointer</span><br>            A[res] = A[m<span class="hljs-number">-1</span>] &gt; B[n<span class="hljs-number">-1</span>] ? A[--m]:B[--n];<span class="hljs-comment">//insert value</span><br>        &#125;<br><span class="hljs-comment">// 如果 n &gt; 0的话，说明m已经全部插入完成了剩下n个元素未插入，下标就是从n-1开始</span><br>        <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">//insert undo B[n]</span><br>        &#123;<br>            A[n<span class="hljs-number">-1</span>] = B[n<span class="hljs-number">-1</span>];<br>            n--;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>algorithm</tag>
      
      <tag>Leetcode</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3-Codewars-2021-4-2</title>
    <link href="/2021/04/02/7-Codewars-2021-4-2/"/>
    <url>/2021/04/02/7-Codewars-2021-4-2/</url>
    
    <content type="html"><![CDATA[<h4 id="1-题目：String-ends-with"><a href="#1-题目：String-ends-with" class="headerlink" title="1|题目：String ends with?"></a>1|题目：String ends with?</h4><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-04-02-005602.png" alt="image-20210402085559350"></p><blockquote><p>My Solution:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">solution</span>(<span class="hljs-params">string, ending</span>):</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">len</span>(ending) == <span class="hljs-number">0</span>):<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<br>      <span class="hljs-keyword">return</span> string[-(<span class="hljs-built_in">len</span>(ending))::] == ending<br></code></pre></td></tr></table></figure><p>语法：</p><p>1、字符串也可以使用切片的方法,但是要注意切片的范围</p><ul><li><input disabled="" type="checkbox"> 切片的范围</li></ul><p>2、len()函数：计算字符串的长度</p><p>Good Solution</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">solution</span>(<span class="hljs-params">string,ending</span>):</span><br>  <span class="hljs-keyword">return</span> string.endswith(ending)<br></code></pre></td></tr></table></figure><p>语法：</p><p>1、<code>str.endswith(*suffix*[, *start*[, *end*]])</code></p><p>如果字符串以指定的 <em>suffix</em> 结束返回 <code>True</code>，否则返回 <code>False</code>。 <em>suffix</em> 也可以为由多个供查找的后缀构成的元组。 如果有可选项 <em>start</em>，将从所指定位置开始检查。 如果有可选项 <em>end</em>，将在所指定位置停止比较,也就是切片的形式。</p></blockquote><h4 id="题目2-Sort-array-by-string-length"><a href="#题目2-Sort-array-by-string-length" class="headerlink" title="题目2:Sort array by string length"></a>题目2:Sort array by string length</h4><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-04-02-010524.png" alt="image-20210402090521060"></p><blockquote><p>My Solution:</p><p>解题思路：使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sort_by_length</span>(<span class="hljs-params">arr</span>):</span><br>    res = <span class="hljs-built_in">sorted</span>(arr,key=<span class="hljs-keyword">lambda</span> i:<span class="hljs-built_in">len</span>(i))<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sort_by_length</span>(<span class="hljs-params">arr</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sorted</span>(arr, key=<span class="hljs-built_in">len</span>)<br></code></pre></td></tr></table></figure><p>语法：</p><ul><li><input disabled="" type="checkbox"> 1、sorted函数</li></ul><p>2、lambda函数：传入参数i的话，是不是默认i为遍历arr中的每一个元素？</p></blockquote><h4 id="题目3-Help-the-bookseller"><a href="#题目3-Help-the-bookseller" class="headerlink" title="题目3:Help the bookseller !"></a>题目3:Help the bookseller !</h4><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-04-02-111529.png" alt="image-20210402191524711"></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Python</tag>
      
      <tag>CodeWars</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1-AL-Heap</title>
    <link href="/2021/04/01/1-AL-Heap/"/>
    <url>/2021/04/01/1-AL-Heap/</url>
    
    <content type="html"><![CDATA[<h3 id="1｜优先级队列"><a href="#1｜优先级队列" class="headerlink" title="1｜优先级队列"></a>1｜优先级队列</h3><blockquote><p>树结构和字典结构支持的是覆盖数据全集的访问和操作，也就是其中存储的每一个对象都是查找和访问的目标。</p><p>树结构：所有的元素之间定义并维护一个显示的全序关系。</p><p>字典结构：从内部强制的在对象的数值与其对应的秩之间，建立起某种关联，主要是散列。</p></blockquote><blockquote><p>优先级、优先级队列</p><p>优先级队列：操作对象限定于当前的全局极值者。</p><p>循环优先级访问（call-by-priority)：根据数据之间相对优先级对其进行访问的方式。</p><p>全局极值：所有的元素可相互进行比比较，不需要维护全序，而是维护一个偏序。</p></blockquote><blockquote><p>关键码、比较器、偏序关系</p><p>1｜关键码：</p><p>仿照字典，优先级队列中的数据项作为词条，优先级对应的属性叫做关键码；</p><p>多数的关键码都去做词条内部的某一成员变量，有的关键码是根据实际需求创建的。为了确定词条优先级的依据，关键码之间必须可以比较大小。</p><p>2｜比较器：</p><p>优先级队列，以比较器的形式兑现对应的优先级关系。就比如说计算机操作系统中的优先级问题，要考虑的问题很多，所以就自己封装一个比较器，按照比较器的比较规则进行比较。</p><p>3｜偏序关系：</p><p>维护全序代价太大，而且有时候也不需要一定维护全序，所以引入偏序的概念；</p></blockquote><h4 id="1｜优先级队列的实现"><a href="#1｜优先级队列的实现" class="headerlink" title="1｜优先级队列的实现"></a>1｜优先级队列的实现</h4><h5 id="1｜操作接口"><a href="#1｜操作接口" class="headerlink" title="1｜操作接口"></a>1｜操作接口</h5><table><thead><tr><th align="center">操作接口</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">size()</td><td align="center"></td></tr><tr><td align="center">insert()</td><td align="center"></td></tr><tr><td align="center">getMax()</td><td align="center"></td></tr><tr><td align="center">delMax()</td><td align="center"></td></tr></tbody></table><h4 id="2｜示例代码"><a href="#2｜示例代码" class="headerlink" title="2｜示例代码"></a>2｜示例代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">print_queue</span><span class="hljs-params">(T&amp; q)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(!q.empty()) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; q.top() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        q.pop();<br>    &#125;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;<br> <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n : &#123;<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>&#125;)<br>        q.push(n);<br> <br>    print_queue(q);<br> <br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;, <span class="hljs-built_in">std</span>::greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; q2;<br> <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n : &#123;<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>&#125;)<br>        q2.push(n);<br> <br>    print_queue(q2);<br> <br>    <span class="hljs-comment">// 用 lambda 比较元素。</span><br>    <span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right) &#123; <span class="hljs-keyword">return</span> (left ^ <span class="hljs-number">1</span>) &lt; (right ^ <span class="hljs-number">1</span>); &#125;;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;, <span class="hljs-keyword">decltype</span>(cmp)&gt; q3(cmp);<br> <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n : &#123;<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>&#125;)<br>        q3.push(n);<br> <br>    print_queue(q3);<br> <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2｜堆"><a href="#2｜堆" class="headerlink" title="2｜堆"></a>2｜堆</h3><blockquote><p>在列表和向量等结构中,insert()和delMax()的效率无法同时保证，插入的时间复杂度为$O(n)$，删除的时间复杂度为$O(1)$</p><p>堆有很多种实现形式，完全二叉堆只是一种基本形式</p></blockquote><h4 id="1｜完全二叉堆"><a href="#1｜完全二叉堆" class="headerlink" title="1｜完全二叉堆"></a>1｜完全二叉堆</h4><blockquote><p>完全二叉堆的逻辑结构：</p><p>逻辑结构完全等同于完全二叉树，堆结点与词条一一对应，堆顶以外的每个结点都不大于或不高于（不小于/低于）其父结点，</p><p>（因为堆顶没有父结点），这就是所谓的堆序性。</p><p>大根堆：堆顶以外的每个结点都不大于或不高于其父结点。</p><p>小根堆：堆顶以外的每个结点都不小于或不低于其父结点。</p><p><code>算法技巧</code>:将权值取负的话，可以颠倒优先级</p></blockquote><blockquote><p>完全二叉堆按照结点的编号（秩）完全可以便捷的判别父子关系</p><p>若V有左孩子</p></blockquote><blockquote><p>时间复杂度分析：</p><p>因为是完全二叉堆，所以结构等同于完全二叉树</p><p>堆高h = $\lfloor{log_2n}\rfloor$ = $O(logn)$</p><p>所以插入和删除操作的时间线性正比于堆高h，所以时间复杂度为$O(logn)$</p></blockquote><h4 id="2｜完全二叉堆的实现"><a href="#2｜完全二叉堆的实现" class="headerlink" title="2｜完全二叉堆的实现"></a>2｜完全二叉堆的实现</h4><blockquote><p>简单实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>使用宏定义来简化后续算法的描述和实现（这是个好习惯）</p></blockquote><h3 id="3｜例题"><a href="#3｜例题" class="headerlink" title="3｜例题"></a>3｜例题</h3><h4 id="1｜题目1-703-数据流中的第-K-大元素"><a href="#1｜题目1-703-数据流中的第-K-大元素" class="headerlink" title="1｜题目1:703. 数据流中的第 K 大元素 "></a>1｜题目1:<a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/">703. 数据流中的第 K 大元素 </a></h4><details><summary>题目要求</summary>  <img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-04-03-020009.png" /></details><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 测试数据存在问题，没考虑负数的情况</span><br><span class="hljs-comment">// 构造函数出现了问题，初始化堆存在问题</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KthLargest</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> _elem[<span class="hljs-number">10001</span>];<br><span class="hljs-keyword">public</span>:<br>    KthLargest(<span class="hljs-keyword">int</span> k, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) <br>    &#123;<br>        _elem[<span class="hljs-number">0</span>] = k;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> u = i;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i  &lt;=_elem[<span class="hljs-number">0</span>] &amp;&amp; _elem[u] &gt; _elem[<span class="hljs-number">2</span>*i])     u = <span class="hljs-number">2</span>*i;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>&lt;=_elem[<span class="hljs-number">0</span>] &amp;&amp; _elem[u] &gt; _elem[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>])   u = <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(u != i)<br>        &#123;<br>            swap(_elem[u],_elem[i]);<br>            down(u);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(val &gt; _elem[<span class="hljs-number">1</span>])<br>        &#123;<br>            _elem[<span class="hljs-number">1</span>] = val;<br>            down(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> _elem[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your KthLargest object will be instantiated and called as such:</span><br><span class="hljs-comment"> * KthLargest* obj = new KthLargest(k, nums);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;add(val);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br></code></pre></td></tr></table></figure></blockquote><h4 id="2｜题目2-堆排序"><a href="#2｜题目2-堆排序" class="headerlink" title="2｜题目2:堆排序"></a>2｜题目2:堆排序</h4><details><summary>题目要求</summary>  <img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-04-03-074353.png"/></details><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> m,n,_elem[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> t = i;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i&lt;=_elem[<span class="hljs-number">0</span>] &amp;&amp; _elem[t] &gt; _elem[<span class="hljs-number">2</span>*i])t = <span class="hljs-number">2</span>*i;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>  &lt;= _elem[<span class="hljs-number">0</span>] &amp;&amp; _elem[t] &gt; _elem[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>]) t = <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span>(i != t)<br>  &#123;<br>    swap(_elem[i],_elem[t]);<br>    down(t);<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>  _elem[<span class="hljs-number">0</span>] = n;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;_elem[i]);<br>  <br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n/<span class="hljs-number">2</span>;i;i--)down(i);<br>  <span class="hljs-keyword">while</span>(m--)<br>  &#123;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; _elem[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    _elem[<span class="hljs-number">1</span>] = _elem[_elem[<span class="hljs-number">0</span>]--];<br>    down(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2｜题目2：模拟堆"><a href="#2｜题目2：模拟堆" class="headerlink" title="2｜题目2：模拟堆"></a>2｜题目2：模拟堆</h4><details><summary>题目要求</summary>  <img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-04-03-015920.png" /></details><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3-Codewars-2021-4-1</title>
    <link href="/2021/04/01/7-Codewars-2021-4-1/"/>
    <url>/2021/04/01/7-Codewars-2021-4-1/</url>
    
    <content type="html"><![CDATA[<h4 id="题目1-Detect-Pangram"><a href="#题目1-Detect-Pangram" class="headerlink" title="题目1:Detect Pangram"></a>题目1:Detect Pangram</h4><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-04-01-022306.png" alt="image-20210401080727114"></p><blockquote><p>My solution</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_pangram</span>(<span class="hljs-params">s</span>):</span><br>    s1  = s.upper()<br>    ans1 = string.ascii_uppercase<br>    ans2 = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> s1:<br>        <span class="hljs-keyword">if</span> item.upper() <span class="hljs-keyword">in</span> ans1:<br>            ans2 += item<br>    set1 = <span class="hljs-built_in">set</span>(ans1)<br>    set2 = <span class="hljs-built_in">set</span>(ans2)<br>    <span class="hljs-keyword">return</span> (set2 &gt;= set1)<br></code></pre></td></tr></table></figure><p>Good Solution</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> string<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_pangram</span>(<span class="hljs-params">s</span>):</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">set</span>(s.upper()) &gt;= (<span class="hljs-built_in">set</span>(string.ascii_uppercase)))<br></code></pre></td></tr></table></figure><p>语法：</p><p>1、<code>ans = string.ascii_uppercase</code></p><p>ans 字符串就是全部的大写字母，但是使用ascii_uppercase必须要<code>import string </code></p><p>2、<code>s.upper()</code>将字符串中的字母全部改为大写</p><p>3、set集合的判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">set</span> &gt;= other<span class="hljs-comment">#检测是否 other 中的每个元素都在集合之中。</span><br><span class="hljs-built_in">set</span> &gt; other<span class="hljs-comment">#检测集合是否为 other 的真超集，即 set &gt;= other and set != other。</span><br><span class="hljs-built_in">set</span> &lt;= other<span class="hljs-comment">#检测是否集合中的每个元素都在 other 之中。</span><br></code></pre></td></tr></table></figure><p>4、将字符串转换为集合（集合的创建方式）</p><p>​        集合可用多种方式来创建:</p><ul><li>使用花括号内以逗号分隔元素的方式: <code>&#123;&#39;jack&#39;, &#39;sjoerd&#39;&#125;</code></li><li>使用集合推导式: <code>&#123;c for c in &#39;abracadabra&#39; if c not in &#39;abc&#39;&#125;</code></li><li>使用类型构造器: <code>set()</code>, <code>set(&#39;foobar&#39;)</code>, <code>set([&#39;a&#39;, &#39;b&#39;, &#39;foo&#39;])</code></li></ul></blockquote><h4 id="题目2-Primes-in-numbers"><a href="#题目2-Primes-in-numbers" class="headerlink" title="题目2:Primes in numbers"></a>题目2:Primes in numbers</h4><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-04-01-022320.png" alt="image-20210401093007642"></p><blockquote><p>Good Solution</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">primeFactors</span>(<span class="hljs-params">n</span>):</span><br>    ret = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<br>        num = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span>(n % i == <span class="hljs-number">0</span>):<br>            num += <span class="hljs-number">1</span><br>            n /= i<br>        <span class="hljs-keyword">if</span> num &gt; <span class="hljs-number">0</span>:<br>            ret += <span class="hljs-string">&#x27;(&#123;&#125;&#123;&#125;)&#x27;</span>.<span class="hljs-built_in">format</span>(i, <span class="hljs-string">&#x27;**%d&#x27;</span> % num <span class="hljs-keyword">if</span> num &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PrimeDecomp</span> &#123;</span><br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">factors</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">PrimeDecomp::factors</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">ostringstream</span> res;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; n &gt; <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n % i == <span class="hljs-number">0</span>) &#123;<br>      n /= i;<br>      k++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>)<br>      res &lt;&lt; <span class="hljs-string">&#x27;(&#x27;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27;)&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">1</span>)<br>      res &lt;&lt; <span class="hljs-string">&#x27;(&#x27;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;**&quot;</span> &lt;&lt; k &lt;&lt; <span class="hljs-string">&#x27;)&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res.str();<br>&#125;<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>Codewars</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3-Codewars-2021-3-31</title>
    <link href="/2021/03/31/7-Codewars-2021-3-31/"/>
    <url>/2021/03/31/7-Codewars-2021-3-31/</url>
    
    <content type="html"><![CDATA[<h4 id="题目1-Bouncing-Balls"><a href="#题目1-Bouncing-Balls" class="headerlink" title="题目1:Bouncing Balls "></a>题目1:Bouncing Balls <img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-31-004100.png" alt="image-20210331084100178"></h4><blockquote><p>解题思路：</p><p>下降必然有一次，如果每次弹起高度 $&gt;$窗户的高度，那么可以看见两次</p><p>My Solution：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bouncingBall</span>(<span class="hljs-params">h, bounce, window</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-number">0</span> &lt; bounce &lt; <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> h &gt; window:<br>        count += <span class="hljs-number">1</span><br>        h *= bounce<br>        <span class="hljs-keyword">if</span> h &gt; window: count += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> count <span class="hljs-keyword">or</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>Good Solution:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bouncingBall</span>(<span class="hljs-params">h, bounce, window</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (h &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt; bounce &lt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> window &lt; h):<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-number">2</span>*<span class="hljs-built_in">int</span>(log(window/<span class="hljs-built_in">float</span>(h), bounce))<br></code></pre></td></tr></table></figure><p>语法：</p><p>1、if not 语句的使用：如果不满足if not(condition)    condition的话，那么就返回-1，python中可以使用<code>0 &lt; bounce &lt; 1</code>的结构</p><p>2、幂值的计算$log_{bounce}{window/float(h)}$，最后将值转换为int类型</p></blockquote><h4 id="题目2-Find-the-stray-number"><a href="#题目2-Find-the-stray-number" class="headerlink" title="题目2:Find the stray number"></a>题目2:Find the stray number</h4><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-31-005313.png" alt="image-20210331085312850"></p><blockquote><p>My Solution:</p><p>1、arr.count(item)函数的使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stray</span>(<span class="hljs-params">arr</span>):</span><br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr:<br>        <span class="hljs-keyword">if</span> arr.count(x) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> x<br></code></pre></td></tr></table></figure><p>Good Solution:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stray</span>(<span class="hljs-params">arr</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(arr, key=arr.count)<br></code></pre></td></tr></table></figure><p>语法：</p><p>1、min()函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stray</span>(<span class="hljs-params">seq</span>):</span><br>    <span class="hljs-keyword">return</span> reduce(<span class="hljs-keyword">lambda</span> acc, cur: acc ^ cur, seq)<br></code></pre></td></tr></table></figure><p>语法：</p><p>1、reduce()函数</p></blockquote><h4 id="题目3-Two-of-sum"><a href="#题目3-Two-of-sum" class="headerlink" title="题目3:Two of sum"></a>题目3:Two of sum</h4><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-31-021139.png" alt="image-20210331101139194" style="zoom:50%;" /><blockquote></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>Codewars</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1_AL_BinarySearch</title>
    <link href="/2021/03/30/1-AL-BinarySearch/"/>
    <url>/2021/03/30/1-AL-BinarySearch/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Codewars_2021_3_30</title>
    <link href="/2021/03/30/7-Codewars-2021-3-30/"/>
    <url>/2021/03/30/7-Codewars-2021-3-30/</url>
    
    <content type="html"><![CDATA[<h4 id="题目1-Array-diff"><a href="#题目1-Array-diff" class="headerlink" title="题目1:Array.diff"></a>题目1:Array.diff</h4><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-30-001912.png" alt="image-20210330081912138"></p><blockquote><p>My Solution:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">array_diff</span>(<span class="hljs-params">a, b</span>):</span><br>    ans = []<br>    <span class="hljs-keyword">for</span> it <span class="hljs-keyword">in</span> a:<br>        <span class="hljs-keyword">if</span> it <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> b:<br>            ans.append(it)<br>    <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><blockquote><p>语法：</p><p>list.append() 将元素添加到list中，不知道为什么不能使用list+=it的方法</p></blockquote><p>Good Solution:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">array_diff</span>(<span class="hljs-params">a, b</span>):</span><br>    <span class="hljs-keyword">return</span> [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> a <span class="hljs-keyword">if</span> x <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> b]<br></code></pre></td></tr></table></figure><p>语法：</p><p>1、使用[      ]定义一个列表，[参数]参数为聊表中的元素，<code>x for x in a if x not in b</code>等价与for x in a:if x not in b</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">array_diff</span>(<span class="hljs-params">a, b</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> i: i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> b, a)<br></code></pre></td></tr></table></figure><p>语法：</p><p>1、<code>filter</code>(<em>function</em>, <em>iterable</em>)</p><p>用 <em>iterable</em> 中函数 <em>function</em> 返回真的那些元素，构建一个新的迭代器。<em>iterable</em> 可以是一个序列，一个支持迭代的容器，或一个迭代器。</p><p>如果 <em>function</em> 是 <code>None</code> ，则会假设它是一个身份函数，即 <em>iterable</em> 中所有返回假的元素会被移除。</p><p>请注意， <code>filter(function, iterable)</code> 相当于一个<code>生成器表达式</code>，当 function 不是 None的时候为 <code>(item for item in iterable if function(item))</code>；function 是 <code>None</code> 的时候为 <code>(item for item in iterable if item)</code> 。</p><p>本题中的<code>fuction</code>是<code>lambda i: i not in b</code>,相当于筛选出满足条件的x并返回一个生成器。</p></blockquote><h4 id="题目2-IQ-Test"><a href="#题目2-IQ-Test" class="headerlink" title="题目2:IQ Test"></a>题目2:IQ Test</h4><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-30-014858.png" alt="image-20210330094858704"></p><blockquote><p>My Solution：</p><p>解题思路：注意传入的参数为字符串，字符串中间有’ ‘（空格）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">iq_test</span>(<span class="hljs-params">numbers</span>):</span><br>    count = <span class="hljs-number">0</span><br>    ans = <span class="hljs-number">0</span><br>    l = numbers.split(<span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> l:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">int</span>(item) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>            count += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            count -= <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">0</span>):<br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> l:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">int</span>(item) % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:<br>                ans = l.index(item)+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> l:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">int</span>(item) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>                ans = l.index(item)+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> ans <br></code></pre></td></tr></table></figure><p>Good Solution:</p><p><code>很好的找不同的思路</code>｜解题思路：找不同的话，将全部的元素统一为bool类型或者是满足要求的其他列表类型；比如这道题可以将元素统一为0或者1，如果0的数目为1，则偶数为不同；如果1的数目为1，则奇数为不同，最后结果返回不同值的下标+1；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">iq_test</span>(<span class="hljs-params">numbers</span>):</span><br>    e = [<span class="hljs-built_in">int</span>(i) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> numbers.split()]<br><br>    <span class="hljs-keyword">return</span> e.index(<span class="hljs-literal">True</span>) + <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> e.count(<span class="hljs-literal">True</span>) == <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> e.index(<span class="hljs-literal">False</span>) + <span class="hljs-number">1</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">if e.count(True) == 1:</span><br><span class="hljs-string">return e.index(True)+1</span><br><span class="hljs-string">else:</span><br><span class="hljs-string">return e.index(False)+1</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>语法：</p><p>1、将numbers转换为bool类型的列表</p><p>2、利用count()函数，对列表中的True和False的数目进行统计</p><p>list.count(x)：list中count的方法，统计x在list中出现的次数。</p></blockquote></blockquote><h4 id="题目3-搜索二维矩阵"><a href="#题目3-搜索二维矩阵" class="headerlink" title="题目3:搜索二维矩阵"></a>题目3:<a href="https://leetcode-cn.com/problems/search-a-2d-matrix/">搜索二维矩阵</a></h4><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-30-041617.png" alt="image-20210330121616961" style="zoom:50%;" /><blockquote><p>My Solution</p><blockquote><p>解题思路：</p><p>1、遍历数组的<code>matrix[i][max]</code>，如果是比target大的话，那么就说明，target的范围在i行。</p><p>2、然后用二分查找，遍历<code>matrix[i][0]～matrix[i][max]</code></p><p>3、优化：查找ans的时候也用二分进行查找</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//二分查找的模板，要写书，背会。</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binSearch</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">int</span> target,<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>,right = matrix[<span class="hljs-number">0</span>].size()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> mid;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)<br>        &#123;<br>            mid = left + (right - left &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(matrix[n][mid] == target)        <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[n][mid] &gt; target)    right = mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span>                                left = mid+<span class="hljs-number">1</span>;                           <br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">int</span> target)</span> </span><br><span class="hljs-function">    </span>&#123;<br>       <span class="hljs-keyword">int</span> n = matrix.size();<br>       <span class="hljs-keyword">int</span> m = matrix[<span class="hljs-number">0</span>].size();<br>       <span class="hljs-keyword">int</span> ans;<br><span class="hljs-comment">//注意此处的边界边界条件：</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1、因为在后续遍历的时候只考虑了matrix[i][m-1]&gt;=target的情况，所以就没有如果在数组中没有一个元素比target大的情况;</span><br><span class="hljs-comment">2、所以写if语句的时候要考虑，另外一种情况怎么办，是属于不需要处理的还是边界条件。</span><br><span class="hljs-comment">e.g:[[1,2,5]] target = 0;</span><br><span class="hljs-comment">*/</span><br>       <span class="hljs-keyword">if</span> (matrix[n<span class="hljs-number">-1</span>][m<span class="hljs-number">-1</span>] &lt; target)          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>       &#123;<br>            <span class="hljs-keyword">if</span>(matrix[i][m<span class="hljs-number">-1</span>]&gt;=target)<br>                &#123;<br>                    ans = i;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>       &#125;<br>       <span class="hljs-keyword">if</span>(binSearch(matrix,target,ans) == <span class="hljs-number">-1</span>)   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       <span class="hljs-keyword">else</span>                                     <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>语法：</p><p>1、二分查找的模版不是很熟悉。</p><p>2、边界条件判断有问题，还是没有理解到if语句的精髓。</p><p>Good Solution1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> row, col;<br>    pair&lt;int, int&gt; getIndex(int n) &#123;<br>        <span class="hljs-keyword">return</span> &#123;n/col, n%col&#125;;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        row = matrix.size(), col = matrix[<span class="hljs-number">0</span>].size();<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = row*col - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>            <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">auto</span> [i, j] = getIndex(mid);<br>            <span class="hljs-keyword">if</span>(matrix[i][j] == target)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[i][j] &gt; target)<br>                right = mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[i][j] &lt; target)<br>                left = mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br>作者：AC_OIer<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/search-a-2d-matrix/solution/gong-shui-san-xie-yi-ti-shuang-jie-er-fe-l0pq/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><blockquote><p>语法：将二维数组转换为一维数组，因为具有了单调性，所以可以使用二分进行查找</p><p>1、二维转换为一维：数组下标</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">pair&lt;int, int&gt; getIndex(int n) <br>&#123;<br>  <span class="hljs-keyword">return</span> &#123;n/col, n%col&#125;;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>Good Solution2:</p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-30-075732.png" alt="image-20210330155732320" style="zoom:50%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> row = matrix.size(), col = matrix[<span class="hljs-number">0</span>].size();<br>        <span class="hljs-comment">// 右上角开始查找</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = col<span class="hljs-number">-1</span>; i &lt; row &amp;&amp; j &gt;= <span class="hljs-number">0</span>;) &#123;<br>            <span class="hljs-keyword">if</span>(matrix[i][j] == target) <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[i][j] &gt; target) <br>                j--;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[i][j] &lt; target)<br>                i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br>作者：AC_OIer<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/search-a-2d-matrix/solution/gong-shui-san-xie-yi-ti-shuang-jie-er-fe-l0pq/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><p>语法：</p><ul><li><input disabled="" type="checkbox"> BST</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>Codewars</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Codewars</tag>
      
      <tag>Python Grammar</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codewars_2021_3_29</title>
    <link href="/2021/03/29/7-Codewars-2021-3-29/"/>
    <url>/2021/03/29/7-Codewars-2021-3-29/</url>
    
    <content type="html"><![CDATA[<h4 id="题目1-Money、Money、Money"><a href="#题目1-Money、Money、Money" class="headerlink" title="题目1:Money、Money、Money"></a>题目1:Money、Money、Money</h4><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-29-012145.png" alt="image-20210329083803446" style="zoom:40%;" /><blockquote><p>My Solution:</p><blockquote><p>解题思路：迭代</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculate_years</span>(<span class="hljs-params">principal, interest, tax, desired</span>):</span><br>    <span class="hljs-keyword">if</span> principal &gt;= desired:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span>:<br>        n = <span class="hljs-number">1</span><br>        <span class="hljs-built_in">sum</span>  = principal + principal*interest*(<span class="hljs-number">1</span> - tax)<br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">sum</span> &lt; desired):<br>                n += <span class="hljs-number">1</span><br>                ans = <span class="hljs-built_in">sum</span> <br>                <span class="hljs-built_in">sum</span> = ans + ans*interest*(<span class="hljs-number">1</span> - tax)<br>        <span class="hljs-keyword">return</span> n<br></code></pre></td></tr></table></figure><p>Good Solution：</p><blockquote><p>解题思路：递归</p><p>递归结束的条件是  p &gt;= d，每次对p进行赋值，递归调用函数calculate_years，最终结果是返回n的。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculate_years</span>(<span class="hljs-params">p, i, t, d, n=<span class="hljs-number">0</span></span>):</span><br>    <span class="hljs-keyword">if</span> p &gt;= d:<br>        <span class="hljs-keyword">return</span> n<br>    p = p + p * i * (<span class="hljs-number">1</span> - t)<br>    <span class="hljs-keyword">return</span> calculate_years(p, i, t, d, n+<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>Good Solution：</p><blockquote><p>解题思路：利用python库中的函数</p><p>$ p = p + p * i * (1 - t)$</p><p>第一年：$p = p *[1+i(1-t)]$</p><p>第n年：$p = p *{[1+i(1-t)]}^n$</p><p>$ n = log_{[1+i(1-t)]}{float(desired) / principal}$</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> ceil, log<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculate_years</span>(<span class="hljs-params">principal, interest, tax, desired</span>):</span><br>    <span class="hljs-keyword">return</span> ceil(log(<span class="hljs-built_in">float</span>(desired) / principal, <span class="hljs-number">1</span> + interest * (<span class="hljs-number">1</span> - tax)))<br></code></pre></td></tr></table></figure><blockquote><p>语法：</p><p>1、ceil()函数</p><p><code>math.ceil(*x*)</code></p><p>返回 <em>x</em> 的上限，即大于或者等于 <em>x</em> 的最小整数。如果 <em>x</em> 不是一个浮点数，则委托 <code>x.__ceil__()</code>, 返回一个 <a href="https://docs.python.org/zh-cn/3/library/numbers.html#numbers.Integral"><code>Integral</code></a> 类的值。</p><p>log得到的结果为n，所以返回n向上取整整数</p><p>2、log（）函数</p><p><code>math.log(x[, base])</code></p><p>使用一个参数，返回 <em>x</em> 的自然对数（底为 <em>e</em> ）。</p><p>使用两个参数，返回给定的 <em>base</em> 的对数 <em>x</em> ，计算为 $log_{base}x$ 。</p></blockquote></blockquote><h4 id="题目2-Two-to-One"><a href="#题目2-Two-to-One" class="headerlink" title="题目2:Two to One"></a>题目2:Two to One</h4><blockquote><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-29-011514.png" alt="image-20210329091511271"></p><blockquote><p>解题思路：</p><p>1、字符串合并、去重、排序</p><p>2、集合的完成去重工作，调用函数<code>sorted()</code>进行排序</p></blockquote><p>My Solution：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longest</span>(<span class="hljs-params">a1, a2</span>):</span><br>    ans = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> it <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>((<span class="hljs-built_in">set</span>(a1+a2))):<br>        ans += it<br>    <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><p>Good Solution:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longest</span>(<span class="hljs-params">a1, a2</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>.join(<span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">set</span>(a1 + a2)))<br></code></pre></td></tr></table></figure><blockquote><p>语法：</p><p>1、set()</p><p>不重复的话首先想到使用set()</p><p>2、sorted()</p><p>3、join()</p></blockquote></blockquote><h4 id="题目3-两数之和"><a href="#题目3-两数之和" class="headerlink" title="题目3:两数之和"></a>题目3:<a href="https://leetcode-cn.com/problems/two-sum/">两数之和</a></h4><blockquote><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-29-014245.png" alt="image-20210329094244570" style="zoom:50%;" /><p>My Solution:</p><blockquote><p>解题思路：暴力枚举，寻找数组中是否存在 <code>target - x</code>，时间复杂度为$O(n^2)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] + nums[j] == target) &#123;<br>                    <span class="hljs-keyword">return</span> &#123;i, j&#125;;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        <span class="hljs-keyword">int</span> i,j;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;nums.size()<span class="hljs-number">-1</span>;i++)<br>        &#123;<br>            j = i+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(j &lt; nums.size())<br>            &#123;<br>                <span class="hljs-keyword">if</span>(nums[i] + nums[j] != target) j++;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    ans.push_back(i);<br>                    ans.push_back(j);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(ans.size() == <span class="hljs-number">2</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></blockquote><p>Good Solution：</p><blockquote><p>解题思路：哈希表查找</p><p>注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。使用哈希表，可以将寻找 <code>target - x</code> 的时间复杂度降低到从 O(N) 降低到 O(1)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; hashtable;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); ++i) &#123;<br>            <span class="hljs-keyword">auto</span> it = hashtable.find(target - nums[i]);<br>            <span class="hljs-keyword">if</span> (it != hashtable.end()) &#123;<br>                <span class="hljs-keyword">return</span> &#123;it-&gt;second, i&#125;;<br>            &#125;<br>            hashtable[nums[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-solution/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><p>语法：</p><p>1、unordered_map</p></blockquote></blockquote><h4 id="题目4-两数相加"><a href="#题目4-两数相加" class="headerlink" title="题目4: 两数相加"></a>题目4:<a href="https://leetcode-cn.com/problems/add-two-numbers/"> 两数相加</a></h4><blockquote><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-29-022142.png" alt="image-20210329102142055" style="zoom:30%;" /><blockquote><p>解题思路：用链表实现大整数的加法</p></blockquote></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Codewars</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1_AL_HeapSort</title>
    <link href="/2021/03/28/1-AL-HeapSort/"/>
    <url>/2021/03/28/1-AL-HeapSort/</url>
    
    <content type="html"><![CDATA[<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h4 id="1｜堆排序"><a href="#1｜堆排序" class="headerlink" title="1｜堆排序"></a>1｜堆排序</h4><blockquote><p>优先级队列：数据结构能够支持插入操作，并能方便地从中取出具有最小或者最大关键码的记录，这样的数据结构即为优先级队列。</p><p>关键码：关键码，在数据结构中，指的是数据元素中能起标识作用的数据项，例如，书目信息中的登陆号和书名等。</p><p>最小堆：最小堆任一结点的关键码均小于或等于它的左右子女的关键码。</p><p>堆存储在下标从0开始计数的数组中，因此在堆中给定下标为i的结点中：</p><ul><li>i=0，结点i是根结点，没有父结点；否则结点i的父结点为结点$ \lceil \frac{i-1}{2} \rceil $</li><li>如果说$2i+1 &gt; n-1$，则结点i无左子女；否则结点i的左子女为结点$2i+1$</li><li>如果说$2i+2 &gt; n-1$，则结点i无右子女；否则结点i的右子女为结点$2i+2$</li></ul></blockquote><h3 id="2｜算法中的堆排序"><a href="#2｜算法中的堆排序" class="headerlink" title="2｜算法中的堆排序"></a>2｜算法中的堆排序</h3>]]></content>
    
    
    <categories>
      
      <category>Algotithm</category>
      
      <category>Sorting</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>HeapSort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1_AL_doublePointer</title>
    <link href="/2021/03/27/1-AL-doublePointer/"/>
    <url>/2021/03/27/1-AL-doublePointer/</url>
    
    <content type="html"><![CDATA[<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><h5 id="1｜剑指-Offer-58-I-翻转单词顺序"><a href="#1｜剑指-Offer-58-I-翻转单词顺序" class="headerlink" title="1｜剑指 Offer 58 - I. 翻转单词顺序"></a>1｜<a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/">剑指 Offer 58 - I. 翻转单词顺序</a></h5><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-04-01-154059.png" alt="image-20210401234045850" style="zoom:50%;" /><blockquote><p>Good Solution：</p><p>解题思路：</p><p>1、首先要从字符串中将每个单词筛选出来，因为不确定单词的长度，所以选用了双指针left和right，left标记单词的左边界，right标记单词的右边界。</p><p>2、第二考虑逆置，因为还要反转字符串所以要从后面往前面遍历；如果不是反转的话就从前往后遍历。</p><p>坑：</p><p>1、要在每个单词后面加一个’ ‘</p><p>2、卡在了while循环的条件判断上面，边界条件没有掌握好。边界条件的逻辑关系要梳理清楚，写循环的话和赋值的话要多加判断。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">reverseWords</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> r = s.size()<span class="hljs-number">-1</span>,l;<br>        <span class="hljs-built_in">string</span> res;<br>        <span class="hljs-keyword">while</span>(r&gt;=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(r&gt;=<span class="hljs-number">0</span> &amp;&amp; s[r] == <span class="hljs-string">&#x27; &#x27;</span>)  r--;    <span class="hljs-comment">//delete the word&#x27;s right space</span><br>            <span class="hljs-keyword">if</span>(r&lt;<span class="hljs-number">0</span>)                     <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//if bound</span><br>            l = r;                              <span class="hljs-comment">//set left start</span><br>            <span class="hljs-keyword">while</span>(l&gt;=<span class="hljs-number">0</span> &amp;&amp; s[l] != <span class="hljs-string">&#x27; &#x27;</span>)  l--;    <span class="hljs-comment">//find the word&#x27;s left bound</span><br>            res += (s.substr(l+<span class="hljs-number">1</span>,r-l)+<span class="hljs-string">&quot; &quot;</span>);     <span class="hljs-comment">//copy the word</span><br>            r = l;                              <span class="hljs-comment">//set another word&#x27;s right start</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(res.size())  res.pop_back();         <span class="hljs-comment">//delete tail space</span><br>        <span class="hljs-keyword">return</span> res;                             <span class="hljs-comment">//return answer</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseWords</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; str:</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot; &quot;</span>.join(s.strip().split()[::-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>语法：</p><p>1、<code>str.join(iterable)</code></p><p>join()方法的参数是可迭代对象</p><p>2、s.strip(）</p><p>strip()方法实现：将两侧的空格删除</p><p>3、s.split()</p><p>默认分割单词，返回值是列表，不是字符串了，所以可以用切片的方式[::-1]，逆序访问列表中的元素</p><ul><li><input disabled="" type="checkbox"> 4、切片</li></ul><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-04-02-003752.png" alt="image-20210402083749253"></p></blockquote><h4 id="2｜26-删除有序数组中的重复项"><a href="#2｜26-删除有序数组中的重复项" class="headerlink" title="2｜26. 删除有序数组中的重复项"></a>2｜<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></h4><details><summary>题目要求</summary>  <img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-04-05-022406.png" /></details><h5 id="1｜My-solution"><a href="#1｜My-solution" class="headerlink" title="1｜My solution"></a>1｜My solution</h5><blockquote><p>解题思路：</p><p>坑：</p><p>1、使用双while有很多边界条件的，不是特定情况，双while的效果适合if else达成的效果是一样的。</p></blockquote><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.size() == <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(j&lt;nums.size())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == nums[j])  j++;<br>            <span class="hljs-keyword">else</span>    nums[++i] = nums[j];<br>        &#125;<br>        <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//一维问题，避免使用双while，很容易有边界问题的</span><br><span class="hljs-comment">//字符串相当于是二维问题了，所以没办法的情况下使用双while循环</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = nums.size();<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(j &lt; len)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(nums[j] == nums[i])<br>            &#123;<br>                j++;<br>                <span class="hljs-keyword">if</span>( j == len)  <span class="hljs-keyword">break</span>;    <br>            &#125;<br>            <span class="hljs-keyword">if</span>(j &lt; len)   nums[++i] = nums[j];<br>            <span class="hljs-keyword">else</span>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.size() == <span class="hljs-number">0</span> || nums.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//左指针：数组头；右指针：数组尾</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.size() - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-comment">//循环右移左指针，直至等于指定值</span><br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] != val) left++;<br>            <span class="hljs-comment">//循环左移右指针，直至不等于指定值</span><br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == val) right--;<br>            <span class="hljs-comment">//交换元素</span><br>            swap(nums[left], nums[right]);<br>        &#125;<br>        <span class="hljs-comment">//while循环结束时，left &gt;= right，判断重合位置</span><br>        <span class="hljs-keyword">if</span> (nums[left] == val) <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> left + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>AL,双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codewars_2021_3_27</title>
    <link href="/2021/03/27/7-Codewars-2021-3-27/"/>
    <url>/2021/03/27/7-Codewars-2021-3-27/</url>
    
    <content type="html"><![CDATA[<h4 id="题目1-旋转链表"><a href="#题目1-旋转链表" class="headerlink" title="题目1:旋转链表"></a>题目1:旋转链表</h4><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-27-011656.png" alt="image-20210327091656425" style="zoom:50%;" /><blockquote><p>解题思路：先将链表成环，注意边界条件（k是可能大于链表的个数的）。</p><p>坑：链表向右移动k个位置，如果不用取模运算的话，输出结果是向左移动。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//My Solution</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">rotateRight</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        ListNode *tail;<br>        ListNode *p = head; <br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span> || head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-keyword">while</span>(p-&gt;next != <span class="hljs-literal">NULL</span>)     <br>        &#123;<br>            p = p -&gt; next;<br>            count++;<br>        &#125;<br>        tail = p;<br>        tail-&gt;next = head;<br><br>        <span class="hljs-keyword">int</span> s = count - k % count;  <span class="hljs-comment">//这步是关键</span><br>        <span class="hljs-keyword">while</span>(s--)<br>        &#123;<br>            head = head-&gt;next;<br>            tail = tail-&gt;next;<br>        &#125;<br>        tail-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></blockquote><blockquote></blockquote>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Grammar</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Leetcode</tag>
      
      <tag>Python</tag>
      
      <tag>CodeWars</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1_AL_greefyAlgorithm</title>
    <link href="/2021/03/27/1-AL-greedyAlgorithm/"/>
    <url>/2021/03/27/1-AL-greedyAlgorithm/</url>
    
    <content type="html"><![CDATA[<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><blockquote><p>贪心算法主要用于求最优解，也就是求最少/最大之类的问题，它总是考虑在当前状态下局部最优（较优）的策略；</p><p>其实就是列方程求最大最小值，什么时候取得最大值、什么时候取得最小值</p><p>贪心算法作为一种求解的策略，做题的时候考虑可不可以使用贪心的思想，也就是可不可以在局部最优的时候全局最优。</p><p>一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法。由于贪心法的高效性以及其所求得的答案比较接近最优结果，贪心法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。在不同情況，選擇最優的解，可能會導致辛普森悖論（Simpson’s Paradox），不一定出現最優的解。</p><p>最小生成樹的算法如<a href="https://zh.wikipedia.org/wiki/Prim%E7%AE%97%E6%B3%95">Prim算法</a>、<a href="https://zh.wikipedia.org/wiki/Kruskal%E7%AE%97%E6%B3%95">Kruskal算法</a>均为贪心算法，其中Prim算法是对图上的节点贪心，而Kruskal算法是对图上的边贪心。</p></blockquote><h4 id="1｜简单贪心"><a href="#1｜简单贪心" class="headerlink" title="1｜简单贪心"></a>1｜简单贪心</h4><blockquote><p>要求中间的每步的策略都是最优的，从而达到全局最优。</p></blockquote><h4 id="2｜例题："><a href="#2｜例题：" class="headerlink" title="2｜例题："></a>2｜例题：</h4><h5 id="1｜1725-可以形成最大正方形的矩形数目"><a href="#1｜1725-可以形成最大正方形的矩形数目" class="headerlink" title="1｜1725. 可以形成最大正方形的矩形数目"></a>1｜<a href="https://leetcode-cn.com/problems/number-of-rectangles-that-can-form-the-largest-square/">1725. 可以形成最大正方形的矩形数目</a></h5><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-31-091145.png" alt="image-20210331171145881" style="zoom:50%;" /><blockquote><p>My Solution</p><p>解题思路：</p><p>1、题目翻译：遍历二维数组，找出二维数组中[0,1]中最大的数的个数；</p><p>2、思路：时间复杂度为$O(n)$，遍历数组count作为当前的最优解，每一次遍历都要更新count的值。</p><p>3、坑：每一次更新maxLen都要对count重新统计。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countGoodRectangles</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; rectangles)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;ans;<br>        <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;rectangles.size();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(min(rectangles[i][<span class="hljs-number">0</span>],rectangles[i][<span class="hljs-number">1</span>]) == maxLen)    <br>                    count++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(min(rectangles[i][<span class="hljs-number">0</span>],rectangles[i][<span class="hljs-number">1</span>]) &gt; maxLen)<br>                &#123;   <br>                    maxLen = min(rectangles[i][<span class="hljs-number">0</span>],rectangles[i][<span class="hljs-number">1</span>]);<br>                    count = <span class="hljs-number">0</span>;<br>                    count++;<br>                &#125;<br>            <span class="hljs-keyword">else</span>    <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span>  count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></blockquote><h5 id="2｜605-种花问题"><a href="#2｜605-种花问题" class="headerlink" title="2｜605. 种花问题"></a>2｜<a href="https://leetcode-cn.com/problems/can-place-flowers/">605. 种花问题</a></h5><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-31-151130.png" alt="image-20210331231130191" style="zoom:50%;" /><blockquote><p>My Solution</p><p>解题方法：</p><p>1、贪心思想：都是种花，那么最多就是所有0的地方都种，只要不符合条件的在拔掉。</p><p>2、关键</p><p>1｜flowerbed[0] = 1; 不管第一块地是不是空地，先种了再说。</p><p>2｜      if(flowerbed[i] == 0 &amp;&amp; flowerbed[i+1] == 0)    flowerbed[i+1] = 1;    </p><p>​            因为第一块地已经种了，所以后续之要有两块空地，就后面那块地种花；<br>​            else if(flowerbed[i] == 1 &amp;&amp; flowerbed[i+1] == 1)  flowerbed[i] = 0;</p><p>​            如果说两块地连着种了花，那么就把前面种的花拔掉。</p><p>3｜两个数组进行对比，if(flowerbed[i] - ans[i] == 1)  那么就说明种花成功。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canPlaceFlowers</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; flowerbed, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;flowerbed.size();i++) ans.push_back(flowerbed[i]);<br>        flowerbed[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;flowerbed.size()<span class="hljs-number">-1</span>;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(flowerbed[i] == <span class="hljs-number">0</span> &amp;&amp; flowerbed[i+<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)    flowerbed[i+<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(flowerbed[i] == <span class="hljs-number">1</span> &amp;&amp; flowerbed[i+<span class="hljs-number">1</span>] == <span class="hljs-number">1</span>)  flowerbed[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;flowerbed.size();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(flowerbed[i] - ans[i] == <span class="hljs-number">1</span>)  count++;<br>        &#125;<br><span class="hljs-keyword">return</span> (count &gt;=n);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Good Solution:贪心</p><p>从左向右遍历花坛，在可以种花的地方就种一朵，能种就种（因为在任一种花时候，不种都不会得到更优解），就是一种贪心的思想<br>这里可以种花的条件是：</p><pre><code>自己为空左边为空 或者 自己是最左右边为空 或者 自己是最右</code></pre><p>最后判断n朵花是否有剩余，为了效率起见，可以在种花的过程中做判断，一旦花被种完就返回true</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">canPlaceFlowers</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] flowerbed, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;flowerbed.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(flowerbed[i] == <span class="hljs-number">0</span> &amp;&amp; (i == <span class="hljs-number">0</span> || flowerbed[i<span class="hljs-number">-1</span>] == <span class="hljs-number">0</span>) &amp;&amp; (i == flowerbed.length<span class="hljs-number">-1</span> || flowerbed[i+<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)) &#123;<br>                n--;<br>                <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                flowerbed[i] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> n &lt;= <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br>作者：pendygg<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/can-place-flowers/solution/1-chong-hua-wen-ti-jian-dan-de-tan-xin-b-h8xb/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure></blockquote><h4 id="2｜区间贪心"><a href="#2｜区间贪心" class="headerlink" title="2｜区间贪心"></a>2｜区间贪心</h4><h4 id="3｜例题"><a href="#3｜例题" class="headerlink" title="3｜例题"></a>3｜例题</h4><h5 id="1｜题目：分割平衡字符串"><a href="#1｜题目：分割平衡字符串" class="headerlink" title="1｜题目：分割平衡字符串"></a>1｜题目：<a href="https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/">分割平衡字符串</a></h5><blockquote><p>解题思路：尽可能多，那么就是求方案的最大值，那么就是要求每一种中RL的数量最少，且相等。</p><blockquote><p>My Solution：利用栈的思想做</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//My Solution</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">balancedStringSplit</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>,top = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;s.size();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;R&#x27;</span>) top++;<br>            <span class="hljs-keyword">else</span>            top --;<br>            <span class="hljs-keyword">if</span>(top == <span class="hljs-number">0</span>)    ans+=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans-top;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>Good Solution：</p><p>题目是对两个字符进行操作,那么自然会考虑到字符的asc码<br>L和R的中间字符O,即L-O=-3;R-O=3,<br>原串就可以转化为3和-3的序列,这么看思路就很清晰了,<br>题目要求子串中ΣL=ΣR,并未要求L和R结构对称,再加上所有分割出的子串都必须为平衡串<br>那么其实就是求±3序列的前缀和为0的次数</p><p>作者：RBlTtBSRCc<br>链接：<a href="https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/solution/cyi-ci-bian-li-shuang-bai-si-lu-by-rblttbsrcc/">https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/solution/cyi-ci-bian-li-shuang-bai-si-lu-by-rblttbsrcc/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">balancedStringSplit</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> nums=<span class="hljs-number">0</span>,ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:s)ans+=((nums+=(i-<span class="hljs-string">&#x27;O&#x27;</span>))==<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></blockquote><h5 id="2｜分发饼干"><a href="#2｜分发饼干" class="headerlink" title="2｜分发饼干"></a>2｜<a href="https://leetcode-cn.com/problems/assign-cookies/">分发饼干</a></h5><blockquote><p>My Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; g, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; s)</span> </span>&#123;<br>        sort(g.begin(),g.end());<br>        sort(s.begin(),s.end());<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> i = g.size()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> j = s.size()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> count= j;count&gt;=<span class="hljs-number">0</span> &amp;&amp; i&gt;=<span class="hljs-number">0</span>;count--)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[count] &gt;= g[i])    <br>            &#123;<br>                i--;<br>                ans++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>                    <br>            &#123;<br>                i--;<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>语法：</p></blockquote><h5 id="3｜908-最小差值-I"><a href="#3｜908-最小差值-I" class="headerlink" title="3｜908. 最小差值 I"></a>3｜<a href="https://leetcode-cn.com/problems/smallest-range-i/">908. 最小差值 I</a></h5><h6 id="1｜My-Solution"><a href="#1｜My-Solution" class="headerlink" title="1｜My Solution"></a>1｜My Solution</h6><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//step1:find min and max </span><br><span class="hljs-comment">//step2:res = (max-x)-(min+x) = max - min - 2*x</span><br><span class="hljs-comment">//step3:return res</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">smallestRangeI</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; A, <span class="hljs-keyword">int</span> K)</span> </span>&#123;<br>        sort(A.begin(),A.end());<br>        <span class="hljs-keyword">int</span> res = A[A.size()<span class="hljs-number">-1</span>]-A[<span class="hljs-number">0</span>]<span class="hljs-number">-2</span>*K;<br>        <span class="hljs-keyword">return</span> (res &gt;= <span class="hljs-number">0</span>) ? res : <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></blockquote><h5 id="4｜910-最小差值-II"><a href="#4｜910-最小差值-II" class="headerlink" title="4｜910. 最小差值 II"></a>4｜<a href="https://leetcode-cn.com/problems/smallest-range-ii/">910. 最小差值 II</a></h5><h6 id="1｜My-Solution-1"><a href="#1｜My-Solution-1" class="headerlink" title="1｜My Solution"></a>1｜My Solution</h6><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codewars_2021_3_26</title>
    <link href="/2021/03/26/7-Codewars-2021-3-26/"/>
    <url>/2021/03/26/7-Codewars-2021-3-26/</url>
    
    <content type="html"><![CDATA[<h4 id="1｜Beginner-Reduce-but-Grow"><a href="#1｜Beginner-Reduce-but-Grow" class="headerlink" title="1｜Beginner - Reduce but Grow"></a>1｜Beginner - Reduce but Grow</h4><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-26-101628.png" alt="image-20210326181625494"></p><blockquote><p>解题思路：遍历arr累计相乘</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># My Solution</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grow</span>(<span class="hljs-params">arr</span>):</span><br>    product = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> arr:<br>        product *= i<br>    <span class="hljs-keyword">return</span> product<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Good Solutions</span><br><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grow</span>(<span class="hljs-params">arr</span>):</span><br>    <span class="hljs-keyword">return</span> reduce(<span class="hljs-keyword">lambda</span> x, y: x * y, arr)<br></code></pre></td></tr></table></figure><blockquote><p>语法：</p><p><code>functools模块-reduce函数</code></p><p><code>functools.``reduce</code>$(function, iterable[, initializer])$</p><p>将两个参数的 <em>function</em> 从左至右积累地应用到 <em>iterable</em> 的条目，以便将该可迭代对象缩减为单一的值。 例如，<code>reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])</code> 是计算 <code>((((1+2)+3)+4)+5)</code> 的值。 左边的参数 <em>x</em> 是积累值而右边的参数 <em>y</em> 则是来自 <em>iterable</em> 的更新值。 如果存在可选项 <em>initializer</em>，它会被放在参与计算的可迭代对象的条目之前，并在可迭代对象为空时作为默认值。 如果没有给出 <em>initializer</em> 并且 <em>iterable</em> 仅包含一个条目，则将返回第一项。</p><p>function：要执行的操作</p><p>iterable：迭代器</p><p><code>lambda表达式</code></p><p>输入两个参数x、y，函数执行x*y</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> mul<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grow</span>(<span class="hljs-params">arr</span>):</span><br>    <span class="hljs-keyword">return</span> reduce(mul, arr, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><blockquote><p>语法：</p><p><code>operator模块</code>：标准运算符替代函数</p><p><a href="https://docs.python.org/zh-cn/3/library/operator.html?highlight=operator#module-operator"><code>operator</code></a> 模块提供了一套与Python的内置运算符对应的高效率函数。例如，<code>operator.add(x, y)</code> 与表达式 <code>x+y</code> 相同。 许多函数名与特殊方法名相同，只是没有双下划线。为了向后兼容性，也保留了许多包含双下划线的函数。为了表述清楚，建议使用没有双下划线的函数。</p></blockquote></blockquote><h4 id="2｜Reversed-sequence"><a href="#2｜Reversed-sequence" class="headerlink" title="2｜Reversed sequence"></a>2｜Reversed sequence</h4><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-26-103150.png" alt="image-20210326183150194" style="zoom:50%;" /><blockquote><p>解题思路：返回值是一个数组，而不是遍历输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># My Solution</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseseq</span>(<span class="hljs-params">n</span>):</span><br>    li_st[x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)]<span class="hljs-comment"># 在list中添加元素</span><br>    li_st.reverse()<span class="hljs-comment"># 调用reverse()函数，逆置list</span><br>    <span class="hljs-keyword">return</span> li_st<span class="hljs-comment"># 返回list</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Good Solution</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseseq</span>(<span class="hljs-params">n</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(n, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><blockquote><p>语法：</p><p><a href="https://docs.python.org/zh-cn/3/library/stdtypes.html?highlight=range#range"><code>range</code></a> 类型表示不可变的数字序列，通常用于在 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for"><code>for</code></a> 循环中循环指定的次数。</p><p>range(start, stop[,step])</p><p>如果 <em>step</em> 为正值，确定 range <code>r</code> 内容的公式为 <code>r[i] = start + step*i</code> 其中 <code>i &gt;= 0</code> 且 <code>r[i] &lt; stop</code>。</p><p>如果 <em>step</em> 为负值，确定 range 内容的公式仍然为 <code>r[i] = start + step*i</code>，但限制条件改为 <code>i &gt;= 0</code> 且 <code>r[i] &gt; stop</code>.</p></blockquote></blockquote><h4 id="3｜Take-a-Number-And-Sum-Its-Digits-Raised-To-The-Consecutive-Powers-And-…-¡Eureka"><a href="#3｜Take-a-Number-And-Sum-Its-Digits-Raised-To-The-Consecutive-Powers-And-…-¡Eureka" class="headerlink" title="3｜Take a Number And Sum Its Digits Raised To The Consecutive Powers And ….¡Eureka!!"></a>3｜Take a Number And Sum Its Digits Raised To The Consecutive Powers And ….¡Eureka!!</h4><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-26-115102.png" alt="image-20210326195102091" style="zoom:40%;" /><blockquote><p>解题思想：</p><p>先要对list[]中的数字进行拆分，拆分为个位、十位、百位</p><p>然后在进行计算（利用python中的枚举函数）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Good Solution</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_dit</span>(<span class="hljs-params">n</span>):</span><br>    result = []<br>    <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>):<br>        x = n % <span class="hljs-number">10</span><br>        result.append(x)<br>        n = n // <span class="hljs-number">10</span><span class="hljs-comment"># 注意</span><br>    result.reverse()<br>    <span class="hljs-keyword">return</span> result<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum_dig_pow</span>(<span class="hljs-params">a, b</span>):</span> <span class="hljs-comment"># range(a, b + 1) will be studied by the function</span><br>    result = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(a,b+<span class="hljs-number">1</span>):<br>        <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> index,x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(get_dit(i),start = <span class="hljs-number">1</span>):<br>            <span class="hljs-built_in">sum</span> += x ** index<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">sum</span> :<br>            result.append(i)       <br>    <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><blockquote><p>语法：</p><p><code>enumerate</code>(<em>iterable</em>, <em>start=0</em>)</p><p>返回一个枚举对象。<em>iterable</em> 必须是一个序列，或 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-iterator">iterator</a>，或其他支持迭代的对象。 <a href="https://docs.python.org/zh-cn/3/library/functions.html?highlight=enumerate#enumerate"><code>enumerate()</code></a> 返回的迭代器的 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#iterator.__next__"><code>__next__()</code></a> 方法返回一个元组，里面包含一个计数值（从 <em>start</em> 开始，默认为 0）和通过迭代 <em>iterable</em> 获得的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">seasons = [<span class="hljs-string">&#x27;Spring&#x27;</span>, <span class="hljs-string">&#x27;Summer&#x27;</span>, <span class="hljs-string">&#x27;Fall&#x27;</span>, <span class="hljs-string">&#x27;Winter&#x27;</span>]<br>enum = <span class="hljs-built_in">enumerate</span>(seasons) <span class="hljs-comment"># enumerate返回值是一个对象</span><br><span class="hljs-built_in">list</span>(enum)<span class="hljs-comment"># 将枚举对象转化为列表</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filter_func</span>(<span class="hljs-params">a</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">int</span>(d) ** (i+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> i, d <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">str</span>(a))) == a<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum_dig_pow</span>(<span class="hljs-params">a, b</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">filter</span>(filter_func, <span class="hljs-built_in">range</span>(a, b+<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>CodeWar</category>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1_AL_union-find_set</title>
    <link href="/2021/03/26/1-AL-union-find-set/"/>
    <url>/2021/03/26/1-AL-union-find-set/</url>
    
    <content type="html"><![CDATA[<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><blockquote><p>并查集主要是用于将n个不同的元素划分为一组不相交的集合，开始的时候每个元素自成一个集合，然后按照规律将归于同一组元素的集合合并。</p><p>并查集中多次用到的操作就是查询元素x属于那个集合。</p><p>实现并查集的典型的方法是采用树形结构来表示元素及其所属子集的关系。</p></blockquote><blockquote><p>并查集的操作</p><p>1｜Merge（Root1，Root2），将自己和Root2并入集合Root1中，要求是Root2与Root1并不想交，否则不予执行。</p><p>2｜Find（x）：搜索单元素x所在的集合，并返回该集合的名字</p><p>3｜UFSets(s)：将并查集中s个元素初始化为s个只有一个单元素的子集合。</p></blockquote><h4 id="1｜并查集（数组实现）"><a href="#1｜并查集（数组实现）" class="headerlink" title="1｜并查集（数组实现）"></a>1｜并查集（数组实现）</h4><blockquote><p>使用方法：使用父指针数组（树形结构）</p><p><code>父指针数组</code>:数组中存储的元素是父结点的下标。</p><p>每个集合以一棵树表示，树的每一个结点代表集合的一个单元素，各个集合的全集合构成森林。</p></blockquote><h5 id="1｜数据成员"><a href="#1｜数据成员" class="headerlink" title="1｜数据成员"></a>1｜数据成员</h5><blockquote><p>1、集合名：一般以整数作为集合名</p><p>2、集合元素：如果集合中有n个元素，可以用1～n内的整数来表示元素（抽象化，更方便利用数组）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span>;<span class="hljs-comment">//n个元素的规模</span><br><span class="hljs-keyword">int</span> parent[N];<span class="hljs-comment">//父指针数组</span><br></code></pre></td></tr></table></figure><p>数组的下标表示的是集合的名字，数组的值表示的父结点（路径压缩后表示的是根结点）</p></blockquote><h5 id="2｜初始化"><a href="#2｜初始化" class="headerlink" title="2｜初始化"></a>2｜初始化</h5><blockquote><p>并查集初始化，就是根据并查集的数据成员对集合名和集合元素进行初始化，下标i对应集合的名字，值q[i]对应集合的父结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// n 表示的是最开始的时候有n不同个元素待操作</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[])</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)q[i] = i;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="3｜寻找根结点"><a href="#3｜寻找根结点" class="headerlink" title="3｜寻找根结点"></a>3｜寻找根结点</h5><blockquote><p>并查集故名思义就是合并与查找，查找主要是给定元素然后查找元素在那个集合中,返回集合的名字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//递归查找父结点，并进行路径压缩，但是每次只压缩了x的路径，并不是对所有的路径都进行压缩。</span><br>  <span class="hljs-comment">//以下为代码执行的例子</span><br>  <span class="hljs-comment">/*1</span><br><span class="hljs-comment">  23</span><br><span class="hljs-comment">  45</span><br><span class="hljs-comment">  x = 5parent[5] = 2 ===&gt; parent[2] = 1 ===&gt; parent[5] = 1===&gt; return parent[5]==&gt;属于集合1</span><br><span class="hljs-comment">  1</span><br><span class="hljs-comment">  235</span><br><span class="hljs-comment">  4</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">if</span>(parent[x] != x)parent[x] = find(parent[x]);<br>  <span class="hljs-keyword">return</span> parent[x];<br>&#125;<br></code></pre></td></tr></table></figure><p>使用递归的方法进行了优化（压缩路径），递归结束的条件是<code>parent[x] = x</code></p></blockquote><h5 id="4｜合并集合"><a href="#4｜合并集合" class="headerlink" title="4｜合并集合"></a>4｜合并集合</h5><blockquote><p>并查集处理元素的基本要求是处理n个不同的元素，所以不考虑集合中有重复的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//将x、y元素所在的集合合并在一个集合中</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//将4与7合并在同一集合中</span><br>  <span class="hljs-comment">//find[4] = 1find[7] = 6 ====&gt; parent[6] = 1(使用数组进行链接)</span><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    161</span><br><span class="hljs-comment">  2357==&gt; 2  3  4  5  6</span><br><span class="hljs-comment">  47</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-comment">//只要使用find则进行路径压缩</span><br>  parent[find[y]] =find[x]; <span class="hljs-comment">//表示parent[6]的父结点为1</span><br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="5｜判断元素是否在一个集合中"><a href="#5｜判断元素是否在一个集合中" class="headerlink" title="5｜判断元素是否在一个集合中"></a>5｜判断元素是否在一个集合中</h5><blockquote><p>就是判判断根结点是不是同一个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">One</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(find[x] == find[y])<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> flase;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="2｜例题"><a href="#2｜例题" class="headerlink" title="2｜例题"></a>2｜例题</h4>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>AL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codewars_2021_3_25</title>
    <link href="/2021/03/25/7-Codewars-2021-3-25/"/>
    <url>/2021/03/25/7-Codewars-2021-3-25/</url>
    
    <content type="html"><![CDATA[<h4 id="题目1"><a href="#题目1" class="headerlink" title="题目1:"></a>题目1:</h4><blockquote><h4 id="1672-最富有客户的资产总量"><a href="#1672-最富有客户的资产总量" class="headerlink" title="1672. 最富有客户的资产总量"></a><a href="https://leetcode-cn.com/problems/richest-customer-wealth/">1672. 最富有客户的资产总量</a></h4><blockquote><p>语法：</p><p>二维数组的边界：</p><p>外层：<code>i&lt;array.size()</code></p><p>内层：<code>j &lt; array[0].size()</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//暴力解法：</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maximumWealth</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; accounts)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;accounts.size();i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;accounts[<span class="hljs-number">0</span>].size();j++)<br>            &#123;<br>                sum += accounts[i][j];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(sum &gt;= max)  max = sum;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;  <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br></code></pre></td></tr></table></figure></blockquote><h5 id="题目2"><a href="#题目2" class="headerlink" title="题目2:"></a>题目2:</h5><blockquote><h4 id="1512-好数对的数目"><a href="#1512-好数对的数目" class="headerlink" title="1512. 好数对的数目"></a><a href="https://leetcode-cn.com/problems/number-of-good-pairs/">1512. 好数对的数目</a></h4><p>解法一：暴力解法</p><p>时间复杂度为$O(n^2)$，从前向后遍历，找到满足条件的元素，ans++；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numIdenticalPairs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.size();i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;nums.size();j++)<br>            <span class="hljs-keyword">if</span>(nums[i] == nums[j])  ans++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numIdenticalPairs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum;<br>        <span class="hljs-keyword">int</span> ans[<span class="hljs-number">101</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.size();i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> u = nums[i] - <span class="hljs-number">1</span>;<br>            ans[u]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">101</span>;i++)<br>        &#123;<br>            sum += (ans[i]<span class="hljs-number">-1</span>)*ans[i]/<span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numIdenticalPairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//因为 1&lt;= nums[i] &lt;= 100  所以申请大小为100的数组</span><br>        <span class="hljs-comment">//temp用来记录num的个数</span><br>        <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">100</span>];<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        从前面开始遍历nums</span><br><span class="hljs-comment">        假设nums = [1,1,1,1]</span><br><span class="hljs-comment">        第一遍</span><br><span class="hljs-comment">        temp是[0,0,0,0]</span><br><span class="hljs-comment">        ans+=0;</span><br><span class="hljs-comment">        temp[0]++;</span><br><span class="hljs-comment">        第二遍</span><br><span class="hljs-comment">        temp是[1,0,0,0]</span><br><span class="hljs-comment">        ans+=1;</span><br><span class="hljs-comment">        temp[0]++;</span><br><span class="hljs-comment">        第三遍</span><br><span class="hljs-comment">        temp=[2,0,0,0]</span><br><span class="hljs-comment">        ans+=2;</span><br><span class="hljs-comment">        temp[0]++;</span><br><span class="hljs-comment">        第四遍</span><br><span class="hljs-comment">        temp=[3,0,0,0]</span><br><span class="hljs-comment">        ans+=3;</span><br><span class="hljs-comment">        temp[0]++;</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            这行代码可以写成</span><br><span class="hljs-comment">            ans+=temp[num - 1];</span><br><span class="hljs-comment">            temp[num - 1]++;</span><br><span class="hljs-comment">            */</span><br>            ans += temp[num - <span class="hljs-number">1</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>Codewars</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1_AL_Trie</title>
    <link href="/2021/03/25/1-AL-Trie/"/>
    <url>/2021/03/25/1-AL-Trie/</url>
    
    <content type="html"><![CDATA[<h4 id="1｜Trie树"><a href="#1｜Trie树" class="headerlink" title="1｜Trie树"></a>1｜Trie树</h4><blockquote><p>Trie树称为前缀树或者是字典树，是一种有序树；键不是直接保存在结点中，而是有结点在树中的位置决定，一个结点的所有子孙都有相同的前缀。</p><p>trie树常用于搜索提示，如输入一个网站可以自动搜索出可能的选择，包括终端中文件夹路径的实现。</p></blockquote><blockquote><p>目前实现的trie树主要用于存储和查找字符串，而且字符串有比较明确的限定，要不是全小写，要不就是全大写，或者是全数字或者是只有0或者1。</p><p>主要用二维数组来实现，但是这种存储方式查询效率高，但是空间利用率较低。</p></blockquote><blockquote><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-25-063718.png" alt="image-20210325143715427"></p><p>用二维数组实现Trie树，其中要深刻的理解数组的作用以及数组的存储方法。</p></blockquote><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N =<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> son[N][<span class="hljs-number">26</span>],cnt[N],idx;<br><span class="hljs-keyword">char</span> str[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-keyword">char</span> str[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> p =<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;str[i];i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!son[p][u])      son[p][u] = ++ idx;<br>        p = son[p][u];<br>    &#125;<br>    cnt[p] ++ ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Query</span><span class="hljs-params">(<span class="hljs-keyword">char</span> str[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;str[i];i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!son[p][u])  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        p = son[p][u];<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[p];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-keyword">char</span> op[<span class="hljs-number">2</span>];<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>,op,str);<br>        <span class="hljs-keyword">if</span>(op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;I&#x27;</span>)    Insert(str);<br>        <span class="hljs-keyword">else</span>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,Query(str));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Trie</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法导论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codewars_2021_3_24</title>
    <link href="/2021/03/24/7-Codewars-2021-3-24/"/>
    <url>/2021/03/24/7-Codewars-2021-3-24/</url>
    
    <content type="html"><![CDATA[<h4 id="题目1"><a href="#题目1" class="headerlink" title="题目1:"></a>题目1:</h4><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-24-154826.png" alt="image-20210324234826225"></p><blockquote><p>分析：题目没有对时间复杂度的要求，所以尽可能的最短化时间复杂度</p></blockquote><blockquote><p>暴力解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">runningSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> _ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.size();i++)<br>        &#123;<br>            _ans += nums[i];<br>            ans.push_back(_ans);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>优化解法</p><p><code>就地运算</code></p><p>就地运算的时间花费要比开辟数组的时间花费较小；从《剑指offer》得到的一个结论：越简单的问题，越要注意坑，而且要考虑全面。题目非常简单，只是求出每个下标对应的动态和，这个动态和就是一个累加和。</p><p>因为题目给的信息比较少，所以更多的限制条件需要我们去问面试官，时间复杂度有没有限制，能不能用额外空间，能不能用库函数,能不能修改原数组等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">runningSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.size();i++)<br>        nums[i] += num[i<span class="hljs-number">-1</span>];<br>    &#125;<br>  <span class="hljs-keyword">return</span> nums;<br>&#125;;<br></code></pre></td></tr></table></figure></blockquote><h4 id="题目2："><a href="#题目2：" class="headerlink" title="题目2："></a>题目2：</h4><h4 id="1481-不同整数的最少数目"><a href="#1481-不同整数的最少数目" class="headerlink" title="1481. 不同整数的最少数目"></a><a href="https://leetcode-cn.com/problems/least-number-of-unique-integers-after-k-removals/">1481. 不同整数的最少数目</a></h4><blockquote></blockquote><h4 id="题目3：Returning-Strings"><a href="#题目3：Returning-Strings" class="headerlink" title="题目3：Returning Strings"></a>题目3：Returning Strings</h4><blockquote><p><a href="https://www.codewars.com/kata/55a70521798b14d4750000a4/train/python">https://www.codewars.com/kata/55a70521798b14d4750000a4/train/python</a></p><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-24-162904.png" alt="image-20210325002904086"></p></blockquote><blockquote><p>语法：python 中f - String的用法</p><p>link : <a href="https://realpython.com/python-f-strings/">https://realpython.com/python-f-strings/</a></p><ul><li>使用%-formatting()进行格式化</li></ul><p>使用<code>%s</code>匹配要格式化输出内容的类型 ，字符串类型为<code>%s</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>):</span><br> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, %s how are you doing today?&quot;</span> % name<br></code></pre></td></tr></table></figure><ul><li>如果说插入的元素多于一个的话，使用元组的形式，但是数据类型要匹配</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;Eric&quot;</span><br>age = <span class="hljs-number">74</span><br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Hello, %s. You are %s.&quot;</span> % (name, age)<br><span class="hljs-string">&#x27;Hello Eric. You are 74.&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>使用str.format()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>):</span><br> <span class="hljs-comment">#Good Luck (like you need it)</span><br> <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;Hello, &#123;&#125; how are you doing today?&quot;</span>.<span class="hljs-built_in">format</span>(name))<br></code></pre></td></tr></table></figure><ul><li>format()中参数多于一个的话，按照顺序输入，或者按照元组的下标进行</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&quot;Hello, &#123;1&#125;. You are &#123;0&#125;.&quot;</span>.<span class="hljs-built_in">format</span>(age, name)<br><span class="hljs-string">&#x27;Hello, Eric. You are 74.&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>使用字典</li></ul><p>用变量匹配字典中的键值对，或者直接使用<code>**</code>引用字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>person = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Eric&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">74</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&quot;Hello, &#123;name&#125;. You are &#123;age&#125;.&quot;</span>.<span class="hljs-built_in">format</span>(name=person[<span class="hljs-string">&#x27;name&#x27;</span>], age=person[<span class="hljs-string">&#x27;age&#x27;</span>])<br><span class="hljs-string">&#x27;Hello, Eric. You are 74.&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>person = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Eric&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">74</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&quot;Hello, &#123;name&#125;. You are &#123;age&#125;.&quot;</span>.<span class="hljs-built_in">format</span>(**person)<br><span class="hljs-string">&#x27;Hello, Eric. You are 74.&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>使用str.format()的弊端</li></ul><p><code>str.format()</code> can still be quite verbose when you are dealing with multiple parameters and longer strings. Take a look at this:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>first_name = <span class="hljs-string">&quot;Eric&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>last_name = <span class="hljs-string">&quot;Idle&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>age = <span class="hljs-number">74</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>profession = <span class="hljs-string">&quot;comedian&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>affiliation = <span class="hljs-string">&quot;Monty Python&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>print((<span class="hljs-string">&quot;Hello, &#123;first_name&#125; &#123;last_name&#125;. You are &#123;age&#125;. &quot;</span> + <br><span class="hljs-meta">&gt;&gt;&gt; </span>       <span class="hljs-string">&quot;You are a &#123;profession&#125;. You were a member of &#123;affiliation&#125;.&quot;</span>) \<br><span class="hljs-meta">&gt;&gt;&gt; </span>       .<span class="hljs-built_in">format</span>(first_name=first_name, last_name=last_name, age=age, \<br><span class="hljs-meta">&gt;&gt;&gt; </span>               profession=profession, affiliation=affiliation))<br><span class="hljs-string">&#x27;Hello, Eric Idle. You are 74. You are a comedian. You were a member of Monty Python.&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>使用<code>f</code>前缀格式化输出字符串</li></ul><p>Formatted string literals are prefixed with <code>&#39;f&#39;</code> and are similar to the format strings accepted by <a href="https://docs.python.org/3/library/stdtypes.html#str.format"><code>str.format()</code></a>. They contain replacement fields surrounded by curly braces. The replacement fields are expressions, which are evaluated at run time, and then formatted using the <a href="https://docs.python.org/3/library/functions.html#format"><code>format()</code></a> protocol:</p><p><code>f</code>前缀的功能相当于<code>str.format()</code>，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>):</span><br> <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;Hello, <span class="hljs-subst">&#123;name&#125;</span> how are you doing today?&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">f&quot;He said his name is <span class="hljs-subst">&#123;name&#125;</span>.&quot;</span><br><span class="hljs-string">&#x27;He said his name is Fred.&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>width = <span class="hljs-number">10</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>precision = <span class="hljs-number">4</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>value = decimal.Decimal(<span class="hljs-string">&quot;12.34567&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">f&quot;result: <span class="hljs-subst">&#123;value:&#123;width&#125;</span>.<span class="hljs-subst">&#123;precision&#125;</span>&#125;&quot;</span>  <span class="hljs-comment"># 通过value设置格式</span><br><span class="hljs-string">&#x27;result:      12.35&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>使用字符串拼接</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>):</span><br> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + name + <span class="hljs-string">&quot; how are you doing today?&quot;</span><br></code></pre></td></tr></table></figure><ul><li>使用lambda表达式</li></ul><blockquote><p>link:</p><p><a href="https://www.codenong.com/39795734/">https://www.codenong.com/39795734/</a></p><p><a href="https://docs.python.org/zh-cn/3/tutorial/controlflow.html#lambda-expressions">https://docs.python.org/zh-cn/3/tutorial/controlflow.html#lambda-expressions</a></p></blockquote><p><a href="https://docs.python.org/zh-cn/3/reference/expressions.html#lambda"><code>lambda</code></a> 关键字用于创建小巧的匿名函数。<code>lambda a, b: a+b</code> 函数返回两个参数的和。Lambda 函数可用于任何需要函数对象的地方。在语法上，匿名函数只能是单个表达式。在语义上，它只是常规函数定义的语法糖。与嵌套函数定义一样，lambda 函数可以引用包含作用域中的变量：</p><p>lambda 变量：对变量进行的操作</p><ul><li><input disabled="" type="checkbox"> 主要要理解sort方法的使用,具体内部是怎么实现的？写就是怎么实现sort？</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">greet = <span class="hljs-keyword">lambda</span> name: <span class="hljs-string">f&#x27;Hello, <span class="hljs-subst">&#123;name&#125;</span> how are you doing today?&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">pairs = [(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;one&#x27;</span>), (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;two&#x27;</span>), (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;three&#x27;</span>), (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;four&#x27;</span>)]<br><span class="hljs-comment"># 主要要理解sort方法的使用</span><br><span class="hljs-comment"># key相当于处理pairs[0]-pairs[3]中的每一个元素</span><br>pairs.sort(key=<span class="hljs-keyword">lambda</span> pair: pair[<span class="hljs-number">1</span>])<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">key</span>(<span class="hljs-params">pair</span>):</span><br>  <span class="hljs-keyword">return</span> pair[<span class="hljs-number">1</span>]<br>pairs<br></code></pre></td></tr></table></figure><p>您的lambda函数将一个元组作为输入，并返回索引为1的元素，因此排序只会考虑每个元组的第二个元素(英文单词)。这就是为什么您的输出在第二个元素’four’&gt;’one’&gt;’three’&gt;’two’中按字母顺序排序的原因。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># lambda是匿名表达式，所以其中没有参数的名字</span><br>key=<span class="hljs-keyword">lambda</span> pair: pair[<span class="hljs-number">1</span>]<br>key(pair=pairs[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-25-082927.png" alt="image-20210325162923718"></p></blockquote><h4 id="题目4-Sum-of-positive"><a href="#题目4-Sum-of-positive" class="headerlink" title="题目4 : Sum of positive"></a>题目4 : Sum of positive</h4><blockquote><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-24-164114.png" alt="image-20210325004114207" style="zoom:50%;" /></blockquote><blockquote><p>语法：循环遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">positive_sum</span>(<span class="hljs-params">arr</span>):</span><br>    <span class="hljs-comment"># Your code here</span><br>    ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> arr:<br>        <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>):<br>            ans += i;<br>    <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">positive_sum</span>(<span class="hljs-params">arr</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">positive_sum</span>(<span class="hljs-params">arr</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: x &gt; <span class="hljs-number">0</span>,arr))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">positive_sum</span>(<span class="hljs-params">arr</span>):</span><br>    <span class="hljs-string">&#x27;&#x27;&#x27; I really hate these one line codes, but here I am...</span><br><span class="hljs-string">        trying to be cool here... and writing some&#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>, arr))<br></code></pre></td></tr></table></figure></blockquote><h4 id="题目5-string-repeat"><a href="#题目5-string-repeat" class="headerlink" title="题目5:string repeat"></a>题目5:string repeat</h4><blockquote><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-25-084735.png" alt="image-20210325004913204" style="zoom:50%;" /></blockquote><blockquote><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">repeat_str</span>(<span class="hljs-params">repeat, string</span>):</span><br>    s = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">while</span> (repeat &gt; <span class="hljs-number">0</span>):<br>        repeat -= <span class="hljs-number">1</span><br>        s += string<br>    <span class="hljs-keyword">return</span> s<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">repeat_str</span>(<span class="hljs-params">repeat, string</span>):</span><br>    <span class="hljs-keyword">return</span> string*repeat<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">repeat_str = <span class="hljs-keyword">lambda</span> r, s: s * r<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">repeat_str=<span class="hljs-built_in">__import__</span>(<span class="hljs-string">&#x27;operator&#x27;</span>).mul<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>Codewars</tag>
      
      <tag>Array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Map</title>
    <link href="/2021/03/24/1-AL-Map/"/>
    <url>/2021/03/24/1-AL-Map/</url>
    
    <content type="html"><![CDATA[<h3 id="STL-MAP"><a href="#STL-MAP" class="headerlink" title="STL:MAP"></a>STL:MAP</h3><h4 id="0｜参考文章"><a href="#0｜参考文章" class="headerlink" title="0｜参考文章"></a>0｜参考文章</h4><h4 id="1｜map的常用用法"><a href="#1｜map的常用用法" class="headerlink" title="1｜map的常用用法"></a>1｜map的常用用法</h4><h5 id="1｜map的定义"><a href="#1｜map的定义" class="headerlink" title="1｜map的定义"></a>1｜map的定义</h5><blockquote><p>map是常用的STL容器，主要完成映射工作；通过键来找值，主要的用途如下所示：</p><p>1、建立字符或者是字符串与整数之间的映射</p><p>2、判断大整数或者是其他数据是否存在的题目</p><p>3、字符串和字符串的映射</p><p><code>map会以键从小到大的顺序自动排序</code>，map内部是使用<code>红黑树</code>实现的，在建立映射的时候会自动实现从小到大的排序,</p><p><code>map的键和值是唯一的，如果说需要一个键对应多个值不能使用map，需要使用multimap</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-built_in">map</span> &lt;<span class="hljs-keyword">typename</span>,<span class="hljs-keyword">typename</span>&gt;mp;<br><span class="hljs-comment">//类型为map，其中第一个typename为键的类型，第二个typename为value的类型</span><br><span class="hljs-comment">//map可以将任何基本数据类型映射到任何基本数据类型</span><br><span class="hljs-built_in">map</span> &lt; <span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt;,<span class="hljs-built_in">string</span>&gt; mp;<br><span class="hljs-comment">//mp的定义</span><br>mp[key] = value;<br></code></pre></td></tr></table></figure></blockquote><h5 id="2｜map容器内元素的访问"><a href="#2｜map容器内元素的访问" class="headerlink" title="2｜map容器内元素的访问"></a>2｜map容器内元素的访问</h5><blockquote><p>1｜通过下标访问（应该是通过键来访问value</p><p>建立映射的时候，和数组一样可以通过键的下标访问键对应的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#incclude <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">map</span> &lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; mp;<br>  mp[<span class="hljs-string">&#x27;c&#x27;</span>] = <span class="hljs-number">20</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,mp[<span class="hljs-string">&#x27;c&#x27;</span>]);<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>2｜通过迭代器访问</p><p>通过迭代器<code>map &lt;char,int&gt; ::iterator it</code>    的 <code>it-&gt;first,it-&gt;second</code>分别访问key和value；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">map</span> &lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; mp;<br>  <span class="hljs-built_in">map</span> &lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; ::iterator it;<br>  <span class="hljs-built_in">map</span>[<span class="hljs-string">&#x27;m&#x27;</span>] = <span class="hljs-number">20</span>;<br>  <span class="hljs-built_in">map</span>[<span class="hljs-string">&#x27;c&#x27;</span>] = <span class="hljs-number">30</span>;<br>  <span class="hljs-built_in">map</span>[<span class="hljs-string">&#x27;d&#x27;</span>] = <span class="hljs-number">40</span>;<br>  <span class="hljs-keyword">for</span>(it=<span class="hljs-built_in">map</span>.begin();it!=mp.end();it++)<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c %d\n&quot;</span>,it-&gt;first,it-&gt;second);<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">c 30</span><br><span class="hljs-comment">d 40</span><br><span class="hljs-comment">m 20</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></blockquote><h5 id="3｜map常用的函数—find-函数"><a href="#3｜map常用的函数—find-函数" class="headerlink" title="3｜map常用的函数—find()函数"></a>3｜map常用的函数—find()函数</h5><blockquote><p>it = mp.find(key)</p><ul><li><input disabled="" type="checkbox"> 查找值的方法有问题：it = mp.find(x)</li></ul><p>参数：</p><table><thead><tr><th>key</th><th>-</th><th>key value of the element to search for</th></tr></thead><tbody><tr><td>x</td><td>-</td><td>a value of any type that can be transparently compared with a key</td></tr></tbody></table><p>返回值：</p><p>Iterator to an element with key equivalent to <code>key</code>. If no such element is found, past-the-end (see [end()](dfile:///Users/uoruichi/Library/Application Support/Dash/DocSets/C++/C++.docset/Contents/Resources/Documents/en.cppreference.com/w/cpp/container/map/end.html)) iterator is returned.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (search != example.end()) &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Found &quot;</span> &lt;&lt; search-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; search-&gt;second &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Not found\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FatKey</span>   &#123;</span> <span class="hljs-keyword">int</span> x; <span class="hljs-keyword">int</span> data[<span class="hljs-number">1000</span>]; &#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LightKey</span> &#123;</span> <span class="hljs-keyword">int</span> x; &#125;;<br><span class="hljs-comment">// Note: as detailed above, the container must use std::less&lt;&gt; (or other </span><br><span class="hljs-comment">//   transparent Comparator) to access these overloads.</span><br><span class="hljs-comment">// This includes standard overloads, such as between std::string and std::string_view.</span><br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> FatKey&amp; fk, <span class="hljs-keyword">const</span> LightKey&amp; lk) &#123; <span class="hljs-keyword">return</span> fk.x &lt; lk.x; &#125;<br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> LightKey&amp; lk, <span class="hljs-keyword">const</span> FatKey&amp; fk) &#123; <span class="hljs-keyword">return</span> lk.x &lt; fk.x; &#125;<br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> FatKey&amp; fk1, <span class="hljs-keyword">const</span> FatKey&amp; fk2) &#123; <span class="hljs-keyword">return</span> fk1.x &lt; fk2.x; &#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;  <br><span class="hljs-comment">// simple comparison demo</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">char</span>&gt; example = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;a&#x27;</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;b&#x27;</span>&#125;&#125;;<br> <br>    <span class="hljs-keyword">auto</span> search = example.find(<span class="hljs-number">2</span>);<br>  <span class="hljs-comment">//返回值查找成功与失败的判断条件</span><br>    <span class="hljs-keyword">if</span> (search != example.end()) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Found &quot;</span> &lt;&lt; search-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; search-&gt;second &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Not found\n&quot;</span>;<br>    &#125;<br> <br><span class="hljs-comment">// transparent comparison demo</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;FatKey, <span class="hljs-keyword">char</span>, <span class="hljs-built_in">std</span>::less&lt;&gt;&gt; example2 = &#123; &#123; &#123;<span class="hljs-number">1</span>, &#123;&#125; &#125;,<span class="hljs-string">&#x27;a&#x27;</span>&#125;, &#123; &#123;<span class="hljs-number">2</span>, &#123;&#125; &#125;,<span class="hljs-string">&#x27;b&#x27;</span>&#125; &#125;;<br> <br>    LightKey lk = &#123;<span class="hljs-number">2</span>&#125;;<br>    <span class="hljs-keyword">auto</span> search2 = example2.find(lk);<br>    <span class="hljs-keyword">if</span> (search2 != example2.end()) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Found &quot;</span> &lt;&lt; search2-&gt;first.x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; search2-&gt;second &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Not found\n&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要是两种查找方法：通过key找value，还有就是通过value找key。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br> <br> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span>**argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">char</span> &gt; aMap;<br><span class="hljs-comment">/**插入初始化的元素**/</span><br><span class="hljs-comment">/*//1.用insert函數插入pair</span><br><span class="hljs-comment">    aMap.insert(pair&lt;string, string&gt;(&quot;r000&quot;, &quot;student_zero&quot;));</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">    //2.用&quot;array&#x27;方式插入</span><br><span class="hljs-comment">*/</span><br>    aMap[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;o&#x27;</span>;<br>    aMap[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;a&#x27;</span>;<br>    aMap[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;b&#x27;</span>;<br>    aMap[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;c&#x27;</span>;<br>    aMap[<span class="hljs-number">4</span>] = <span class="hljs-string">&#x27;d&#x27;</span>;<br>    aMap[<span class="hljs-number">5</span>] = <span class="hljs-string">&#x27;d&#x27;</span>;<span class="hljs-comment">//故意弄个重复的value </span><br>    <br><span class="hljs-keyword">int</span> key =<span class="hljs-number">5</span>;<br><span class="hljs-keyword">char</span> value=<span class="hljs-string">&#x27;d&#x27;</span>;<br><br><span class="hljs-comment">//通过key找value </span><br><span class="hljs-keyword">if</span>(aMap.count(key)&gt;<span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;通过key:  &quot;</span>&lt;&lt;key&lt;&lt;<span class="hljs-string">&quot;     找到的value:&quot;</span>&lt;&lt;aMap[key]&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-comment">//通过value找 key</span><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">char</span>&gt;::iterator it = aMap.begin();it!=aMap.end();it++) <br>&#123;<br><span class="hljs-keyword">if</span>(it-&gt;second==value)<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;通过value:  &quot;</span>&lt;&lt;value&lt;&lt;<span class="hljs-string">&quot;    找到的key:&quot;</span>&lt;&lt;it-&gt;first&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125; <br> <br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="4｜map常用的函数—erase-函数"><a href="#4｜map常用的函数—erase-函数" class="headerlink" title="4｜map常用的函数—erase()函数"></a>4｜map常用的函数—erase()函数</h5><blockquote><p>删除单个元素和删除一个去区间内的所有元素</p></blockquote><blockquote><p>通过迭代器来删除单个元素,时间复杂度为$O(1)$</p><p>find()函数的返回值是迭代器类型，erase()函数的参数可以是迭代器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; mp;<br>  mp[<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-number">20</span>;<br>  mp[<span class="hljs-string">&#x27;b&#x27;</span>] = <span class="hljs-number">30</span>;<br>  mp[<span class="hljs-string">&#x27;c&#x27;</span>] = <span class="hljs-number">40</span>;<br>  <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; ::iterator it = <span class="hljs-built_in">map</span>.find(<span class="hljs-string">&#x27;b&#x27;</span>);<br>  mp.erase(it);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt;::iterator it = mp.begin();it!=mp.end();it++)<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c %d&quot;</span>,it-&gt;first,it-&gt;second);<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>通过键值来删除，但是时间复杂度为$O(logN)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; mp;<br>  mp[<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-number">20</span>;<br>  mp[<span class="hljs-string">&#x27;b&#x27;</span>] = <span class="hljs-number">30</span>;<br>  mp[<span class="hljs-string">&#x27;c&#x27;</span>] = <span class="hljs-number">40</span>;<br>  <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; ::iterator it = <span class="hljs-built_in">map</span>.find(<span class="hljs-string">&#x27;b&#x27;</span>);<br>  mp.erase(it);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt;::iterator it = mp.begin();it!=mp.end();it++)<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c %d&quot;</span>,it-&gt;first,it-&gt;second);<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>删除一个区间内的所有元素,通过迭代器标识开始和结束[first,last)，但是是左闭右开的区间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; mp;<br>  mp[<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-number">20</span>;<br>  mp[<span class="hljs-string">&#x27;b&#x27;</span>] = <span class="hljs-number">30</span>;<br>  mp[<span class="hljs-string">&#x27;c&#x27;</span>] = <span class="hljs-number">40</span>;<br>  <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; ::iterator it = <span class="hljs-built_in">map</span>.find(<span class="hljs-string">&#x27;b&#x27;</span>);<br>  mp.erase(it,mp.end());<br>  <span class="hljs-keyword">for</span>(<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt;::iterator it = mp.begin();it!=mp.end();it++)<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c %d&quot;</span>,it-&gt;first,it-&gt;second);<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="5｜map常用函数—–size"><a href="#5｜map常用函数—–size" class="headerlink" title="5｜map常用函数—–size()"></a>5｜map常用函数—–size()</h5><blockquote><p>用来返回map中映射的个数，时间复杂度为$O(1)$，返回值为int类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> main<br>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; mp;<br>  mp[<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-number">20</span>;<br>  mp[<span class="hljs-string">&#x27;b&#x27;</span>] = <span class="hljs-number">30</span>;<br>  mp[<span class="hljs-string">&#x27;c&#x27;</span>] = <span class="hljs-number">40</span>;<br>  <span class="hljs-keyword">int</span> si_ze = mp.size();<br>  <span class="hljs-built_in">cout</span> &lt;&lt; si_ze &lt;&lt; <span class="hljs-built_in">endl</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="6｜map常用函数—–clear-函数"><a href="#6｜map常用函数—–clear-函数" class="headerlink" title="6｜map常用函数—–clear()函数"></a>6｜map常用函数—–clear()函数</h5><blockquote><p>用于清空map中的所有元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> main<br>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; mp;<br>  mp[<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-number">20</span>;<br>  mp[<span class="hljs-string">&#x27;b&#x27;</span>] = <span class="hljs-number">30</span>;<br>  mp[<span class="hljs-string">&#x27;c&#x27;</span>] = <span class="hljs-number">40</span>;<br>  mp.clear();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="2｜Unordered-map"><a href="#2｜Unordered-map" class="headerlink" title="2｜Unordered_map"></a>2｜Unordered_map</h4><blockquote><p>unordered_map 是关联容器，含有带唯一键的键-值 pair 。搜索、插入和元素移除拥有平均常数时间复杂度。</p><p>元素在内部不以任何特定顺序排序，而是组织进桶中。元素放进哪个桶完全依赖于其键的哈希。这允许对单独元素的快速访问，因为一旦计算哈希，则它准确指代元素所放进的桶。</p><p><code>std::unordered_map</code> 满足<a href="https://www.apiref.com/cpp-zh/cpp/named_req/Container.html"><em>容器</em> <em>(Container)</em> </a>、<a href="https://www.apiref.com/cpp-zh/cpp/named_req/AllocatorAwareContainer.html"><em>知分配器容器</em> <em>(AllocatorAwareContainer)</em> </a>、<a href="https://www.apiref.com/cpp-zh/cpp/named_req/UnorderedAssociativeContainer.html"><em>无序关联容器</em> <em>(UnorderedAssociativeContainer)</em> </a>的要求。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 1、Create an unordered_map of three strings (that map to strings)</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; u = &#123;<br>        &#123;<span class="hljs-string">&quot;RED&quot;</span>,<span class="hljs-string">&quot;#FF0000&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;GREEN&quot;</span>,<span class="hljs-string">&quot;#00FF00&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;BLUE&quot;</span>,<span class="hljs-string">&quot;#0000FF&quot;</span>&#125;<br>    &#125;;<br> <span class="hljs-comment">// 2、遍历map,并输出相关的元素</span><br>  <span class="hljs-comment">// 3、注意遍历的方法，const auto &amp;n:u，遍历u中的元素n,并且不改变n的值</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Iterate and print keys and values of unordered_map:\n&quot;</span>;<br>    <span class="hljs-keyword">for</span>( <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; n : u ) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Key:[&quot;</span> &lt;&lt; n.first &lt;&lt; <span class="hljs-string">&quot;] Value:[&quot;</span> &lt;&lt; n.second &lt;&lt; <span class="hljs-string">&quot;]\n&quot;</span>;<br>    &#125;<br> <span class="hljs-comment">// 4、第二种遍历方法：using structured binding（c++17后才能使用）</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Iterate and print keys and values using structured binding (since C++17):\n&quot;</span>;<br>    <span class="hljs-keyword">for</span>( <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; [key, value] : u ) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Key:[&quot;</span> &lt;&lt; key &lt;&lt; <span class="hljs-string">&quot;] Value:[&quot;</span> &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot;]\n&quot;</span>;<br>    &#125;<br> <br>    <span class="hljs-comment">// 5、Add two new entries to the unordered_map</span><br>    u[<span class="hljs-string">&quot;BLACK&quot;</span>] = <span class="hljs-string">&quot;#000000&quot;</span>;<br>    u[<span class="hljs-string">&quot;WHITE&quot;</span>] = <span class="hljs-string">&quot;#FFFFFF&quot;</span>;<br> <span class="hljs-comment">// 6、通过键值key访问值value</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Output values by key:\n&quot;</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;The HEX of color RED is:[&quot;</span> &lt;&lt; u[<span class="hljs-string">&quot;RED&quot;</span>] &lt;&lt; <span class="hljs-string">&quot;]\n&quot;</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;The HEX of color BLACK is:[&quot;</span> &lt;&lt; u[<span class="hljs-string">&quot;BLACK&quot;</span>] &lt;&lt; <span class="hljs-string">&quot;]\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 两数之和</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; hashtable;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); ++i) &#123;<br>            <span class="hljs-keyword">auto</span> it = hashtable.find(target - nums[i]);<br>            <span class="hljs-keyword">if</span> (it != hashtable.end()) &#123;<br>                <span class="hljs-keyword">return</span> &#123;it-&gt;second, i&#125;;<br>            &#125;<br>            hashtable[nums[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 第二种代码的方法，但是要注意边界条件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; table;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.size();i++)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> it = table.find(target-nums[i]);<br>            <span class="hljs-keyword">if</span>(it != table.end() &amp;&amp; it-&gt;second != i)   <span class="hljs-keyword">return</span> &#123;i,it-&gt;second&#125;;<br>            table[nums[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></blockquote><h5 id="1｜unordered-map的定义"><a href="#1｜unordered-map的定义" class="headerlink" title="1｜unordered_map的定义"></a>1｜unordered_map的定义</h5><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; hashtable;<span class="hljs-comment">// &lt;其中是两个参数类型：第一个是键，第二个是值&gt;</span><br></code></pre></td></tr></table></figure></blockquote><h5 id="2｜unordered-map的成员访问"><a href="#2｜unordered-map的成员访问" class="headerlink" title="2｜unordered_map的成员访问"></a>2｜unordered_map的成员访问</h5><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 键和值的访问，通过迭代器访问，迭代器的定义</span><br><span class="hljs-built_in">unordered_map</span> &lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; ::iterator it;<span class="hljs-comment">//it为迭代器</span><br><span class="hljs-comment">// it-&gt;first 对应的是key</span><br><span class="hljs-comment">// it-&gt;second 对应的是value</span><br></code></pre></td></tr></table></figure></blockquote><h5 id="3｜map与vector的映射"><a href="#3｜map与vector的映射" class="headerlink" title="3｜map与vector的映射"></a>3｜map与vector的映射</h5><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">hashtable[nums[i]] = i;<span class="hljs-comment">//将num[i]作为键，将i作为值，映射到map中</span><br></code></pre></td></tr></table></figure></blockquote><h5 id="4｜find-函数的使用"><a href="#4｜find-函数的使用" class="headerlink" title="4｜find()函数的使用"></a>4｜find()函数的使用</h5><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;  <br><span class="hljs-comment">// 简单比较演示</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">char</span>&gt; example = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;a&#x27;</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;b&#x27;</span>&#125;&#125;;<br> <br>    <span class="hljs-keyword">auto</span> search = example.find(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (search != example.end()) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Found &quot;</span> &lt;&lt; search-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; search-&gt;second &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Not found\n&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>语法：</p><p>1、使用unordered_map要引入头文件<code>#include &lt;unordered_map&gt;</code></p><p>2、find()函数的，通过key来找到value，输入的参数为key</p><p>3、返回值：指向键等于 <code>key</code> 的元素的迭代器。若找不到这种元素，则返回尾后（见 <a href="https://www.apiref.com/cpp-zh/cpp/container/unordered_map/end.html">end()</a> ）迭代器，所以返回值的定义有两种，第一种是使用<code>auto</code>关键字，第二种是使用定义迭代器的方法。</p></blockquote></blockquote><h4 id="3｜例题练习"><a href="#3｜例题练习" class="headerlink" title="3｜例题练习"></a>3｜例题练习</h4><h5 id="1｜771-宝石与石头"><a href="#1｜771-宝石与石头" class="headerlink" title="1｜771. 宝石与石头"></a>1｜<a href="https://leetcode-cn.com/problems/jewels-and-stones/">771. 宝石与石头</a></h5><blockquote><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-31-034240.png" alt="image-20210331114240185" style="zoom:50%;" /><p>My Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numJewelsInStones</span><span class="hljs-params">(<span class="hljs-built_in">string</span> jewels, <span class="hljs-built_in">string</span> stones)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;hashmap;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;stones[i];i++)<br>            hashmap[stones[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;jewels[i];i++)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> it = hashmap.find(jewels[i] - <span class="hljs-string">&#x27;a&#x27;</span>);<br>            <span class="hljs-keyword">if</span>(it != hashmap.end())  ans += it-&gt;second;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>语法：</p><p>1、hash map[key] = value，可以进行自加操作<code>hashmap[stones[i] - &#39;a&#39;]++;</code></p><p>2、注意边界条件的判断：<code>if(it != hashmap.end())  ans += it-&gt;second;</code></p></blockquote><h5 id="2｜136-只出现一次的数字"><a href="#2｜136-只出现一次的数字" class="headerlink" title="2｜136. 只出现一次的数字"></a>2｜<a href="https://leetcode-cn.com/problems/single-number/">136. 只出现一次的数字</a></h5><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-31-042238.png" alt="image-20210331122237387" style="zoom:50%;" /><blockquote><p>My Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;hashmap;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.size();i++)<br>        &#123;<br>            hashmap[nums[i]]++;<br>        &#125;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;::iterator it;<br>        <span class="hljs-keyword">for</span>(it = hashmap.begin();it!=hashmap.end();it++)<br>            <span class="hljs-keyword">if</span> (it-&gt;second == <span class="hljs-number">1</span>)    <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">return</span> it-&gt;first;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Good Solution</p><p>解题思路：使用位运算进行解答</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e: nums) ret ^= e;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/single-number/solution/zhi-chu-xian-yi-ci-de-shu-zi-by-leetcode-solution/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> ans = nums[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">if</span> (nums.length &gt; <span class="hljs-number">1</span>) &#123;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>      ans = ans ^ nums[i];<br>   &#125;<br> &#125;<br> <span class="hljs-keyword">return</span> ans;<br><br>作者：yinyinnie<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/single-number/solution/xue-suan-fa-jie-guo-xiang-dui-yu-guo-cheng-bu-na-y/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure></blockquote><h5 id="3｜1160-拼写单词"><a href="#3｜1160-拼写单词" class="headerlink" title="3｜1160. 拼写单词"></a>3｜<a href="https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/">1160. 拼写单词</a></h5><h6 id="1｜My-Solution"><a href="#1｜My-Solution" class="headerlink" title="1｜My Solution"></a>1｜My Solution</h6><blockquote><p>解题思路：</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Sorting</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单调栈</title>
    <link href="/2021/03/24/1-AL-%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <url>/2021/03/24/1-AL-%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><blockquote><p>单调栈主要是用于寻找next bigger或者是next smaller 的元素；</p><p>因为数组是从 i = 0开始遍历，然后一直遍历到maxSize-1，但是不能够回溯，所以在比较的过程中没有记忆功能，如1 3 7 5 6 4 8序列，当数组遍历到7 5 6 8 时，过了7，遍历到5时就没有变量来记录7了，所以暴力解法的时间复杂度为$$O(n^2)$$。</p><p>在相同空间复杂度的下没有办法进行优化，那么就采用以空间换时间的方法进行，借助其他的数据结构来进行优化时间复杂度。</p><p>单调栈并不是将原数组的元素保证单调，而是要借助单调栈这种数据结构作为辅助手段来实现寻找next bigger或者是next smaller 的元素。</p></blockquote><blockquote><p>单调栈是保证从栈顶 —&gt; 栈底保证栈内的单调不减或者是不增。并不是将数组中所有的元素都放入栈中，而是将满足要求的元素入栈，入栈的元素要保证栈的单调性。</p><p>例：以next bigger问题为例</p><table><thead><tr><th>i</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>num[i]</td><td>2</td><td>1</td><td>5</td><td>4</td><td>6</td></tr><tr><td>top = -1（栈顶）</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>Stack[j]（辅助）</td><td>2</td><td>2、1</td><td>5</td><td>4</td><td>6</td></tr></tbody></table><p>分析：</p><p>1、遍历数组i = 0开始</p><p>2、此时栈中为空，入栈</p><p>3、i = 1 num[1] &lt; Stack[top] ,入栈，保证了栈的单调，此时栈中最小值为Stack[top]，此时没有比num[0]更大的元素</p><p>4、i = 2 num[2] &gt; Stack[top]，出栈，再次对比num[2] 与 Stack[top]，num[2] &gt; Stack[top]，那么继续出栈，出栈后栈空，入栈；此时就找到了比num[0]~num[1]的next bigger number。</p><ul><li><input disabled="" type="checkbox"> 使用python画图理解</li></ul></blockquote><h4 id="2｜例题"><a href="#2｜例题" class="headerlink" title="2｜例题"></a>2｜例题</h4><h5 id="1｜Acwing-830-单调栈"><a href="#1｜Acwing-830-单调栈" class="headerlink" title="1｜Acwing 830 单调栈:"></a>1｜Acwing 830 单调栈:</h5><blockquote><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-24-013110.png" alt="image-20210324093110207" style="zoom:50%;" /><p>1、先考虑不是边界条件的情况：</p><p>1｜因为是要找左边的元素，所以只能将遍历的元素入栈，然后考虑什么情况下出栈</p><p>2｜如果满足Stack[N]单调递减的，要保证Stack[top]是最小值，那么就要求入栈的元素要比Stack[top]小，所以只要Stack[top] &gt; = x的，那么就要求栈顶元素一直出栈。当Stack[top] &lt; x的时候，那么就满足题目要求</p><p>3｜只要给定的条件为真，<strong>while</strong> 循环语句会重复执行一个目标语句。题目要求是找到比x小的元素，<code>直到Stack[top] &lt; x为止</code>，所以如果说Stack[top] &gt;= x,那么就不满足题目要求，要一直循环；所以while的条件就是Stack[top] &gt;= x；</p><p>4｜边界条件：栈空的时候<code>top</code>就不能在进行后续的操作了,所以while循环中加入限定条件<code>top != 0</code></p><p>5 | 如果此时栈不为空了，那么就说明待插入的x左侧的最小元素为Stack[top]，那么输出，然后将x入栈。</p><p>6｜如果此时栈为空，那么就说明左侧没有比x更小的数了，则输出-1，并且为了后续的对比同样要将x入栈。</p><p>正常逻辑分析代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++">&gt;<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> Stack[N];<br><span class="hljs-keyword">int</span> n,top = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> x;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>        <span class="hljs-keyword">if</span>(top == <span class="hljs-number">0</span>)    <br>        &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            Stack[++top] = x;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">while</span>(top != <span class="hljs-number">0</span> &amp;&amp; Stack[top] &gt;= x)  top--;<br>            <span class="hljs-keyword">if</span>(top == <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>                Stack[++top] = x;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">cout</span> &lt;&lt; Stack[top] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>                Stack[++top] = x;<br>            &#125;<br>        &#125;<br>   <br>    &#125;<br>         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p>优化代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++">&gt;<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> Stack[N];<br><span class="hljs-keyword">int</span> n,top = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>     &#123;<br>        <span class="hljs-keyword">int</span> x;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>        <span class="hljs-keyword">while</span>( top !=<span class="hljs-number">0</span> &amp;&amp; Stack[top] &gt;= x)   top --; <br>        <span class="hljs-keyword">if</span>(top)<br>            <span class="hljs-built_in">cout</span> &lt;&lt; Stack[top] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        Stack[++top] = x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>   &#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="2｜121-买卖股票的最佳时机"><a href="#2｜121-买卖股票的最佳时机" class="headerlink" title="2｜121. 买卖股票的最佳时机"></a>2｜<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h5><h6 id="1｜My-Solution"><a href="#1｜My-Solution" class="headerlink" title="1｜My Solution"></a>1｜My Solution</h6><blockquote><p>解题思路：</p><p>1、用单调栈实现，但是有点牵强，实现比较复杂，要添加变量</p></blockquote><blockquote><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">解题思路：</span><br><span class="hljs-comment">1、找到数组中差值最大的两个元素</span><br><span class="hljs-comment">2、暴力：双循环</span><br><span class="hljs-comment">3、线性：单调栈</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res[N] = &#123;<span class="hljs-number">0</span>&#125;,top = <span class="hljs-number">-1</span>,max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(prices.size() == <span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i &lt; prices.size();i++)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(top &gt;=<span class="hljs-number">0</span> &amp;&amp; prices[i] &lt; res[<span class="hljs-number">0</span>] &amp;&amp; i != prices.size()<span class="hljs-number">-1</span>)    top--;<br>            <span class="hljs-keyword">if</span>(top == <span class="hljs-number">-1</span>)   res[++top] = prices[i];<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(res[top] &lt; prices[i])    res[++top] = prices[i];<br>                <span class="hljs-keyword">else</span>    <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(res[top] - res[<span class="hljs-number">0</span>] &gt; max) max = res[top]- res[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Stack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法导论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++_函数、函数进阶</title>
    <link href="/2021/03/23/0-CPP-%E5%87%BD%E6%95%B0%E3%80%81%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"/>
    <url>/2021/03/23/0-CPP-%E5%87%BD%E6%95%B0%E3%80%81%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h3><h4 id="1｜函数基本知识"><a href="#1｜函数基本知识" class="headerlink" title="1｜函数基本知识"></a>1｜函数基本知识</h4><h5 id="0｜库函数的使用"><a href="#0｜库函数的使用" class="headerlink" title="0｜库函数的使用"></a>0｜库函数的使用</h5><blockquote><p>库函数的使用涉及到编译的知识，以后在慢慢往懂搞吧，比较复杂，目前先学会库函数的使用，以及哪些库中有哪些常用的函数。</p></blockquote><blockquote><p>库函数是已经定义和编译好的函数，所以使用库函数的话，只需要增加相应的标准头文件，然后正确的调用函数。</p></blockquote><blockquote><h6 id="C-服务编译耗时优化原理及实践"><a href="#C-服务编译耗时优化原理及实践" class="headerlink" title="C++服务编译耗时优化原理及实践"></a><a href="https://tech.meituan.com/2020/12/10/apache-kylin-practice-in-meituan.html">C++服务编译耗时优化原理及实践</a></h6></blockquote><h5 id="1｜函数的定义"><a href="#1｜函数的定义" class="headerlink" title="1｜函数的定义"></a>1｜函数的定义</h5><blockquote><p>函数的定义需要说明函数的返回值类型即typeName，typeName为数据类型的名字，若返回值类型不为void，则必须有return；</p><p>返回值类型不能是数组，除数组之外可以是任何数据类型（可以是结构和对象，如果非要返回数组的话，那么可以将数组作为结构或者对象的一部分返回）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//伪代码</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Head&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Function</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//提供函数原型</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  Function();<span class="hljs-comment">//函数的调用</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function">typeName <span class="hljs-title">Function</span><span class="hljs-params">(para)</span><span class="hljs-comment">// 函数的定义</span></span><br><span class="hljs-function"></span>&#123;<br>  statements;<br>  <span class="hljs-keyword">return</span> ;<span class="hljs-comment">// optional</span><br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>函数参数：</p><p>按值传递：将数值参数传递给函数，函数将其赋值给新的变量；按值传递不会影响到main中的数据。</p><p>实参：argu（传递给函数的值）</p><p>形参：para（用于接收传递值的变量）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> volume = cube(side);<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">volume</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span></span><br><span class="hljs-function">  <span class="hljs-comment">//被调用时函数创建名字为x的变量，并将其初始化为5</span></span><br><span class="hljs-function">  <span class="hljs-comment">//side 为实参 ， x 为形参</span></span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>作用域：</p><p>函数中声明的变量为该函数私有，在调用该函数的时候在内存中开辟空间，调用完成后会回收空间。</p></blockquote><h5 id="2｜提供函数原型"><a href="#2｜提供函数原型" class="headerlink" title="2｜提供函数原型"></a>2｜提供函数原型</h5><blockquote><p>为什么要提供函数原型：</p><p>第一：原型告诉编译器，函数的参数，如果函数的参数类型或者数量存在问题，编译器可以捕捉到这类错误。</p><p>第二：在函数执行完毕之后，将把返回值放置在指定的位置（CPU寄存器或内存中），然后调用这个函数的时候，就从这个位置取得返回值。由于原型指出了函数的返回值类型，所以编译器就可以知道检索多少个字节来解释这个返回值。</p><p>第三：单文件编译不存在函数原型和函数定义分离，但是如果是多文件编程，那么如果不提供函数原型，则会影响编译速度。避免使用函数原型的方法就是在调用函数前就定义函数，但是在实际的项目中有时是不可行的。</p></blockquote><blockquote><p>函数原型语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">cube</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">cube</span><span class="hljs-params">(<span class="hljs-keyword">double</span>)</span></span>;<br><span class="hljs-comment">//以上几种定义都是可以的，函数的参数只需提供类型列表，不一定一定要类型名字。</span><br><span class="hljs-comment">//这是函数原型的语法，不能与函数定义混淆，函数定义一定要提供类型名字的。</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">cube1</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x * x;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">cube2</span><span class="hljs-params">(<span class="hljs-keyword">double</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">double</span> x = <span class="hljs-number">4.5</span>,y = <span class="hljs-number">4.6</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; cube1(x) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; cube2(y) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">cube2</span><span class="hljs-params">(<span class="hljs-keyword">double</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> y*y;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">错误做法：</span><br><span class="hljs-comment">double cube2(double)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    return y*y;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></blockquote><h5 id="3｜调用函数"><a href="#3｜调用函数" class="headerlink" title="3｜调用函数"></a>3｜调用函数</h5><h4 id="2｜函数与数组"><a href="#2｜函数与数组" class="headerlink" title="2｜函数与数组"></a>2｜函数与数组</h4><blockquote><p>函数参数为数组：</p><p>传递数组的时候，并没有发生拷贝的情况，而是将数组在内存中地址等数组信息传递给函数，是在原有数组的基础上进行操作的。其实相当于函数创建了一个新的变量，这个新的变量是地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// int arr[] []为空则表示可以将任意长度的数组传递给函数</span><br><span class="hljs-comment">//实际情况时arr并不是数组，而是指针，但是在编写函数其余部分时候，可以将arr看作是数组。</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[],<span class="hljs-keyword">int</span> n)</span></span>;<br><span class="hljs-comment">//如果要同时操作数组和数组的长度的时候要传递两个参数，数组名字和数组的长度</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fillArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[],<span class="hljs-keyword">int</span> size)</span></span>;<br><span class="hljs-comment">//bad prototype</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fillArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[size])</span></span>;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>C++将数组名解释为其第一个元素的地址，但是也有例外。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">cookies = &amp; cookies[<span class="hljs-number">0</span>];<br><span class="hljs-comment">//表示的是整个数组的长度，而不是单个元素的长度</span><br><span class="hljs-keyword">sizeof</span>(cookies);<br><span class="hljs-comment">//因为数组的内存空间是连续的，所以&amp; cookies返回的是整个数组大小的内存块地址</span><br>&amp; cookies;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>在C++中，当且仅当用于函数头或者函数原型的时候<code>int *arr</code>和<code>int arr[]</code>的含义才相同，并不能在函数体中使用<code>int arr[]</code>来声明指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">arr[i] == *(arr+i);<br>&amp;arr[i] == arr+i;<br><span class="hljs-comment">//由以上两个等式知道遍历数组的时候使用指针加法和数组的下标是等效的。</span><br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Grammar</category>
      
      <category>Base</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Reading And Thinking</title>
    <link href="/2021/03/17/8-ReadingList/"/>
    <url>/2021/03/17/8-ReadingList/</url>
    
    <content type="html"><![CDATA[<h3 id="0｜计算机网络-自顶向下方法"><a href="#0｜计算机网络-自顶向下方法" class="headerlink" title="0｜计算机网络-自顶向下方法"></a>0｜计算机网络-自顶向下方法</h3><h4 id="2021-3-17"><a href="#2021-3-17" class="headerlink" title="2021-3-17"></a>2021-3-17</h4><h5 id="计算机网络概论-P54"><a href="#计算机网络概论-P54" class="headerlink" title="计算机网络概论 P54"></a>计算机网络概论 <code>P54</code></h5><blockquote><p>未来网络的发展方向：</p><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-17-005635.png" alt="image-20210317085634458"></p><p>未来的网络部署的智能软件代理功能就是数据挖掘，所以数据挖掘的范围并不是局限于互联网的内容产生的数据，更广阔的应用在于对于端（主机）产生的数据挖掘。</p><p>对于主机，我们一定要使用一种安全的语言，所以这可能是Rust具有未来的原因吧。</p><ul><li>未来网络发展要解决的问题</li><li>未来网络发展的方向</li><li>Rust应用在嵌入式中有哪些弊端？相比其他的语言有什么优势？</li></ul></blockquote><blockquote><p>计算机网络存在的理由：</p><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-17-010231.png" alt="image-20210317090231061"></p><p>未来的技术发展是要开拓更加实用的网络应用，而不是局限于现在的网络应用。<code>本书的读者能够创建下一代招人喜爱的因特网应用。</code>这才是学习计算机网络的目的。</p><p>创建下一代因特网应用的前提是要明白计算机网络的原理。</p><p>未来的网络应用：</p><ul><li>全息投影的游戏</li><li>全息投影的导航系统</li><li>根据数据挖掘出来的生活习惯—嵌入式助手（规划个人的生活）</li><li>5G的发展对于人们生活的影响<ul><li><input disabled="" type="checkbox"> 下一代5G的因特网应用</li><li><input disabled="" type="checkbox"> 了解5G的优点和缺点</li><li><input disabled="" type="checkbox"> 5G开发已经在路上</li></ul></li></ul></blockquote><h4 id="2021-3-18"><a href="#2021-3-18" class="headerlink" title="2021-3-18"></a>2021-3-18</h4><blockquote><p>1、如何将想法转化为真实世界的网络应用：</p><p>研发网络应用程序的核心是写出能够运行在<code>不同的端系统</code>和<code>通过网络彼此通信的程序</code>。</p><p>应用程序体系结构：</p><p>规定如何在各种端系统上组织该应用程序，在现在网络应用程序中使用的两种主流体系结构：客户-服务器体系结构或对等（P2P）体系结构。</p><p>客户服务器体系：比如Web应用程序，当Web服务器收到来自某用户的请求时，它向客户发送<code>所请求的对象(request)</code>作为<code>响应(response)</code>。</p><p>P2P体系结构：</p><p>应用程序在<code>间接连接</code>的主机对之间使用<code>直接通信</code>。</p><ul><li><input disabled="" type="checkbox"> 加密的百度云盘（企业级应用，安全、高效）</li><li><input disabled="" type="checkbox"> 如何对等（上传和下载一样多）</li></ul></blockquote><blockquote><p>2、进程通信</p><p>运行在多个端系统上的程序是如何相互通信的情况有一个基本的了解，在操作系统的层次上，相互通信的实际是进程而不是程序。进程间通信的规则由端系统上的操作系统确定。</p><p>在不同端系统上的进程，通过跨国计算机网络交换报文的相互通信。发送进程生成并向网络中发送报文，接收进程接收这些报文，并通过报文发送回去进行响应。</p><ul><li><input disabled="" type="checkbox"> 可能不好理解的就是为什么是进程到进程之间的通信？</li></ul></blockquote><blockquote><p>3、进程与计算机网络之间的接口：</p><p>进程通过一个称为套接字<code>socket</code>的软件结构向网络发送报文和从网络接收报文。进程好比是房子，套接字好比是他的门。</p><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-18-003403.png" alt="image-20210318083357996"></p></blockquote><blockquote><p>4、进程寻址</p><p>为了保证进程通信之间的准确性（比如QQ发送的消息微信并不能收到，你发送的消息别人并不能收到），发送目的地必须要一个地址，所以这就涉及到网络协议中各层的地址标识。</p><ul><li><input disabled="" type="checkbox"> 在网络应用编程中这些参数应该如何使用？</li></ul><p>应用层：端口号</p><p>网络层：ip地址</p><p>链路层：MAC地址</p></blockquote><blockquote><p>5、可供应用程序使用的运输服务</p><p><code>套接字是应用程序进程和运输层协议之间的接口</code></p><p>很多网络提供了不知一种运输层协议，在开发一个应用时，必须根据实际情况选用一种运输层协议，为你的应用需求提供恰当服务的协议。比如银行的数据传输必须是安全的不能丢失的，微信视频的时候允许有卡顿、丢失（你刚说了啥我没听见）</p><p>在运输层既可以提供可靠的数据传输、也可以提供不可靠的数据传输</p></blockquote><h3 id="1｜数据结构-邓俊辉"><a href="#1｜数据结构-邓俊辉" class="headerlink" title="1｜数据结构                                    邓俊辉"></a>1｜数据结构                                    <code>邓俊辉</code></h3><h4 id="2021-3-17-1"><a href="#2021-3-17-1" class="headerlink" title="2021-3-17"></a>2021-3-17</h4><h5 id="1｜算法的基本要求：P5-P16"><a href="#1｜算法的基本要求：P5-P16" class="headerlink" title="1｜算法的基本要求：P5-P16"></a>1｜算法的基本要求：<code>P5-P16</code></h5><blockquote><p>1、输入与输出</p></blockquote><blockquote><p>2、基本操作、确定性、可行性</p></blockquote><blockquote><p>3、正确定、有穷性</p><p>如何保证算法的正确性与有穷性？</p><p>通过不变性与单调性进行保证（此处的单调性与数学中的单调性有略微差别）</p><p>单调性是指问题的有效规模会随着算法的推进不断递减</p><p>不变形是指程序的每一轮循环或者是迭代都满足题目的要求，所以掌握迭代和循环很重要。</p></blockquote><blockquote><p>4、退化与鲁棒性</p><p>退化就是要考虑输入的各种极端的实例，也就是边界条件的考虑</p><p>鲁棒性：将可能的将边界条件考虑全面</p></blockquote><blockquote><p>5、重用性</p><p>算法模式推广：比如说用于不同的数据类型</p></blockquote><h5 id="2｜算法效率"><a href="#2｜算法效率" class="headerlink" title="2｜算法效率"></a>2｜算法效率</h5><blockquote><p>1、计算效率</p></blockquote><blockquote><p>2、数据结构</p><p>不论输入、输出、中间结果都是在计算机中以数据的形式表示的，对数据的存储、组织、转移以及变换等操作，对不同的计算模型和平台环境所支持的具体形式不尽相同，执行效率直接影响整体的效率。</p><p>数据结构就是以数据作为研究对象，建立支持高效算法的数据处理策略、技巧以及方法。也就是研究数据如何进行增、删、改、查更加高效而且满足实际的要求。</p><p>要做到根据实际应用需求自如的设计、实现和选用适当的数据结构，必须要首先对算法设计的技巧以及相应的数据结构的特征了然于心。</p><p>归根结底在于：算法设计的技巧、数据结构的特征。</p><p>所以学习这本书的关键在于掌握书中算法设计的技巧，以及掌握数据结构的特征。</p></blockquote><h5 id="3｜复杂度分析"><a href="#3｜复杂度分析" class="headerlink" title="3｜复杂度分析"></a>3｜复杂度分析</h5><blockquote><p>时间复杂度</p></blockquote><blockquote><p>空间复杂度</p></blockquote><blockquote><p>渐进复杂度</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Reading</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Reading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++_Acwing</title>
    <link href="/2021/03/16/0-CPP-Acwing/"/>
    <url>/2021/03/16/0-CPP-Acwing/</url>
    
    <content type="html"><![CDATA[<h3 id="2｜数据结构"><a href="#2｜数据结构" class="headerlink" title="2｜数据结构"></a>2｜数据结构</h3><h4 id="2021-3-17"><a href="#2021-3-17" class="headerlink" title="2021 - 3 -17"></a>2021 - 3 -17</h4><h5 id="1｜题目"><a href="#1｜题目" class="headerlink" title="1｜题目"></a>1｜题目</h5><blockquote><p><a href="https://www.acwing.com/problem/content/828/">https://www.acwing.com/problem/content/828/</a></p></blockquote><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-17-062437.png" alt="image-20210317142437242" style="zoom:33%;" /><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-17-062455.png" alt="image-20210317142455159"></p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-17-062525.png" alt="image-20210317142524989" style="zoom:33%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> elem[M],List[M];<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> head,avil;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head = <span class="hljs-number">-1</span>;<br>    avil = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Head</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    elem[avil] = x;<br>    List[avil] = head;<br>    head = avil;<br>    avil ++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    elem[avil] = x;<br>    List[avil] = List[k];<br>    List[k] = avil;<br>    avil ++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    List[k] = List[List[k]];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Init();<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;m);<br>    <span class="hljs-keyword">char</span> op;<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> x,k;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; op;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;H&#x27;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>            Head(x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;I&#x27;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt;k &gt;&gt; x;<br>            Insert(k,x);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; k;<br> <span class="hljs-comment">//这里不是很清楚，头结点的作用是什么？为了遍历？</span><br>            <span class="hljs-keyword">if</span>(!k)  head = List[head];  <br>            Delete(k);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i= head;i!=<span class="hljs-number">-1</span>;i=List[i])     <span class="hljs-built_in">cout</span> &lt;&lt; elem[i]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h4 id="2021-3-24"><a href="#2021-3-24" class="headerlink" title="2021-3-24"></a>2021-3-24</h4>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>环境搭建常见问题</title>
    <link href="/2021/03/12/8-Env/"/>
    <url>/2021/03/12/8-Env/</url>
    
    <content type="html"><![CDATA[<h3 id="环境搭建常见问题及处理"><a href="#环境搭建常见问题及处理" class="headerlink" title="环境搭建常见问题及处理"></a>环境搭建常见问题及处理</h3><h4 id="1｜VS-Code配置C-的debug"><a href="#1｜VS-Code配置C-的debug" class="headerlink" title="1｜VS Code配置C++的debug"></a>1｜VS Code配置C++的debug</h4><p><code>mac OS</code></p><h5 id="问题1-无法在vs-code的内置终端中进行输入，也就是会出现终端将被任务重用，按任意键关闭，而且不启动外部终端，即使启动外部终端也无法读入输入。"><a href="#问题1-无法在vs-code的内置终端中进行输入，也就是会出现终端将被任务重用，按任意键关闭，而且不启动外部终端，即使启动外部终端也无法读入输入。" class="headerlink" title="问题1:无法在vs code的内置终端中进行输入，也就是会出现终端将被任务重用，按任意键关闭，而且不启动外部终端，即使启动外部终端也无法读入输入。"></a>问题1:无法在vs code的内置终端中进行输入，也就是会出现终端将被任务重用，按任意键关闭，而且不启动外部终端，即使启动外部终端也无法读入输入。</h5><blockquote><p>问题原因：The issue is when VSCode launches the debug adapter, then the debug adapter launches <code>lldb-mi</code>, then <code>lldb-mi</code> launches <code>Terminal</code>. There is a prompt that should appear, but somehow the DebugAdapter is not forwarding this permissions request.</p><p>解决方法：因为vscode的macos版本目前还不支持C++的debug的内置终端输入，所以要启动自带的终端进行调试的输入。按照官方文档配置launch.json和tasks.json文件，然后在tasks.json文件中加入启动外部终端的代码块。</p><p><code>launch.json配置</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>    <span class="hljs-comment">// 使用 IntelliSense 了解相关属性。 </span><br>    <span class="hljs-comment">// 悬停以查看现有属性的描述。</span><br>    <span class="hljs-comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span><br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.2.0&quot;</span>,<br>    <span class="hljs-string">&quot;configurations&quot;</span>: [<br>        &#123;<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;g++-10 - 生成和调试活动文件&quot;</span>,<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;cppdbg&quot;</span>,<br>            <span class="hljs-string">&quot;request&quot;</span>: <span class="hljs-string">&quot;launch&quot;</span>,<br>            <span class="hljs-string">&quot;program&quot;</span>: <span class="hljs-string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span>,<br>            <span class="hljs-string">&quot;args&quot;</span>: [],<br>            <span class="hljs-string">&quot;stopAtEntry&quot;</span>: <span class="hljs-literal">false</span>,<br>            <span class="hljs-string">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,<br>            <span class="hljs-string">&quot;environment&quot;</span>: [],<br>            <span class="hljs-string">&quot;externalConsole&quot;</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-string">&quot;MIMode&quot;</span>: <span class="hljs-string">&quot;lldb&quot;</span>,<br>            <span class="hljs-string">&quot;preLaunchTask&quot;</span>: <span class="hljs-string">&quot;C/C++: g++-10 生成活动文件&quot;</span><br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p><code>tasks.json配置</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>    <span class="hljs-string">&quot;tasks&quot;</span>: [<br>        &#123;<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;cppbuild&quot;</span>,<br>            <span class="hljs-string">&quot;label&quot;</span>: <span class="hljs-string">&quot;C/C++: g++-10 生成活动文件&quot;</span>,<br>            <span class="hljs-string">&quot;command&quot;</span>: <span class="hljs-string">&quot;/usr/local/bin/g++-10&quot;</span>,<br>            <span class="hljs-string">&quot;args&quot;</span>: [<br>                <span class="hljs-string">&quot;-g&quot;</span>,<br>                <span class="hljs-string">&quot;$&#123;file&#125;&quot;</span>,<br>                <span class="hljs-string">&quot;-o&quot;</span>,<br>                <span class="hljs-string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span><br>            ],<br>            <span class="hljs-string">&quot;options&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><br>            &#125;,<br>            <span class="hljs-string">&quot;problemMatcher&quot;</span>: [<br>                <span class="hljs-string">&quot;$gcc&quot;</span><br>            ],<br>            <span class="hljs-string">&quot;group&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;kind&quot;</span>: <span class="hljs-string">&quot;build&quot;</span>,<br>                <span class="hljs-string">&quot;isDefault&quot;</span>: <span class="hljs-literal">true</span><br>            &#125;,<br>            <span class="hljs-string">&quot;detail&quot;</span>: <span class="hljs-string">&quot;调试器生成的任务。&quot;</span><br>        &#125;,<br><span class="hljs-comment">//需要在tasks的内容中增加以下的代码块以启动终端</span><br>        &#123;<br>            <span class="hljs-string">&quot;label&quot;</span>: <span class="hljs-string">&quot;Open Terminal&quot;</span>,<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>,<br>            <span class="hljs-string">&quot;command&quot;</span>: <span class="hljs-string">&quot;osascript -e &#x27;tell application \&quot;Terminal\&quot;\ndo script \&quot;echo hello\&quot;\nend tell&#x27;&quot;</span>,<br>            <span class="hljs-string">&quot;problemMatcher&quot;</span>: []<br>          &#125;<br>    ],<br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;2.0.0&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>配置完tasks.json文件后</p><p>1、You can run this specific task using <code>Command + Shift + p</code>. </p><p>2、Type <code>Tasks</code> and look for <code>Tasks: Run Tasks</code> then select <code>Open Terminal</code>.</p><p>Once you allow this permission, then the external console should appear when you debug.</p><p>成功配置后进行debug显示：</p><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-12-003807.png" alt="image-20210312083804302"></p></blockquote><h4 id="2｜VS-CODE-使用vcpkg管理lib文件"><a href="#2｜VS-CODE-使用vcpkg管理lib文件" class="headerlink" title="2｜VS CODE 使用vcpkg管理lib文件"></a>2｜VS CODE 使用vcpkg管理lib文件</h4><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-04-06-160730.png" alt="image-20210407000730233"></p><p><a href="https://docs.microsoft.com/en-us/cpp/build/vcpkg?view=msvc-160">https://docs.microsoft.com/en-us/cpp/build/vcpkg?view=msvc-160</a></p><p>git 加速，有效解决问题</p><p><a href="https://www.youtube.com/watch?v=hKBhOXlQc4c">https://www.youtube.com/watch?v=hKBhOXlQc4c</a></p><h4 id="2｜在MAC上配置jupyter-和-notebook"><a href="#2｜在MAC上配置jupyter-和-notebook" class="headerlink" title="2｜在MAC上配置jupyter 和 notebook"></a>2｜在MAC上配置jupyter 和 notebook</h4><h5 id="1｜配置python环境"><a href="#1｜配置python环境" class="headerlink" title="1｜配置python环境"></a>1｜配置python环境</h5><h5 id="2｜配置C-环境"><a href="#2｜配置C-环境" class="headerlink" title="2｜配置C++环境"></a>2｜配置C++环境</h5><blockquote><p>为了能在vscode中也使用notebook，于是为mac配置了jupyter和notebook的环境</p><p><a href="https://zhuanlan.zhihu.com/p/82025119">https://zhuanlan.zhihu.com/p/82025119</a></p></blockquote><blockquote><p>坑：配置完之后你要重新启动cling的环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda info --envs<br></code></pre></td></tr></table></figure><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-04-01-080553.png" alt="image-20210401160552430"></p><p>如果要想使用python环境那么就只需要环境名为base</p><p>如果要想使用有C++的环境每次启动都需要进行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda activate cling <span class="hljs-comment">#激活有c++的环境</span><br>jupyter notebook  <span class="hljs-comment">#启动notebook</span><br></code></pre></td></tr></table></figure><p>“jupyter.experiments.optOutFrom”: [“NativeNotebookEditor”],</p></blockquote><h4 id="3｜MAC上使用markdown中html的折叠与收起功能"><a href="#3｜MAC上使用markdown中html的折叠与收起功能" class="headerlink" title="3｜MAC上使用markdown中html的折叠与收起功能"></a>3｜MAC上使用markdown中html的折叠与收起功能</h4><blockquote><p><a href="https://support.typora.io/HTML/#html-entities">https://support.typora.io/HTML/#html-entities</a></p></blockquote><details><summary>题目要求：图片折叠与收起</summary>  <img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-04-03-015920.png" /></details>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>VSCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python语法</title>
    <link href="/2021/03/10/2-Python-Codewar/"/>
    <url>/2021/03/10/2-Python-Codewar/</url>
    
    <content type="html"><![CDATA[<h4 id="0｜目标"><a href="#0｜目标" class="headerlink" title="0｜目标"></a>0｜目标</h4><ul><li><input disabled="" type="checkbox"> 实验楼中的python百题冲关学习完成</li><li><input disabled="" type="checkbox"> 实验楼中的pandas百题冲关学习完成</li><li><input disabled="" type="checkbox"> 实验楼中的NumPy百题冲关学习完成</li></ul><h4 id="1｜字符串string"><a href="#1｜字符串string" class="headerlink" title="1｜字符串string"></a>1｜字符串string</h4><h5 id="1｜基本操作"><a href="#1｜基本操作" class="headerlink" title="1｜基本操作"></a>1｜基本操作</h5><blockquote><p>1、<code>split()|join()</code></p><p><code>str.split(&#39;char&#39;)</code> : 其中str为待操作的字符串，参数char为以什么字符分割</p><p><code>str.join(iterable)</code> : str为在迭代对象<code>iterable</code>的各个成员之间添加的字符。</p><p>2、生成器：在Python中，这种一边循环一边计算的机制，称为<strong>生成器</strong>：generator。</p><p>3、迭代器：</p><p>我们已经知道，可以直接作用于<code>for</code>循环的数据类型有以下几种：一类是集合数据类型，如<code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code>、<code>str</code>等；一类是<code>generator</code>，包括生成器和带<code>yield</code>的generator function。这些可以直接作用于<code>for</code>循环的对象统称为可迭代对象：<code>Iterable</code>。可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterable</code>对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#return 返回时一个string类型变量</span><br><span class="hljs-comment"># 字符串切片</span><br><span class="hljs-comment"># 字符串逆序输出</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse_words</span>(<span class="hljs-params"><span class="hljs-built_in">str</span></span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>.join(s[::-<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>.split(<span class="hljs-string">&#x27; &#x27;</span>))<br>  <br>  <br>s = <span class="hljs-string">&quot;This is an example!&quot;</span><br><span class="hljs-comment"># 实现字符串的分割</span><br>s1 = s.split(<span class="hljs-string">&#x27; &#x27;</span>)<br>print(<span class="hljs-built_in">type</span>(s1))<br><span class="hljs-comment"># &lt;class &#x27;list&#x27;&gt;</span><br><br><span class="hljs-comment"># 生成器</span><br><span class="hljs-comment"># 生成器中的item是str类型的，并且实现将item逆序</span><br>s2 = (item[::-<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> s1)<br>print(<span class="hljs-built_in">type</span>(s2))<br><span class="hljs-comment"># &lt;class &#x27;generator&#x27;&gt;</span><br>print(<span class="hljs-built_in">type</span>(item))<br><span class="hljs-comment"># &lt;class &#x27;str&#x27;&gt;</span><br><br><br><span class="hljs-comment"># string的join方法</span><br><span class="hljs-comment"># str.join()函数操作的成员要求是可迭代对象，生成器也是可迭代对象。</span><br>s3 = <span class="hljs-string">&#x27; &#x27;</span>.join(item[::-<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> s.split(<span class="hljs-string">&#x27; &#x27;</span>))<br>print(s3)<br><span class="hljs-comment"># sihT si na !elpmaxe</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="2｜list操作"><a href="#2｜list操作" class="headerlink" title="2｜list操作"></a>2｜list操作</h4><h5 id="1｜count-操作"><a href="#1｜count-操作" class="headerlink" title="1｜count 操作"></a>1｜count 操作</h5><blockquote><p>1、筛选list中满足条件的值，并返回值的数量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count_sheeps</span>(<span class="hljs-params">arrayOfSheeps</span>):</span><br>  <span class="hljs-keyword">return</span> arrayOfSheeps.count(<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 返回 list中值为True的数量</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="2021-3-18"><a href="#2021-3-18" class="headerlink" title="2021-3-18"></a>2021-3-18</h4><h5 id="1｜Given-two-arrays-a-and-b-write-a-function-comp-a-b-orcompSame-a-b-that-checks-whether-the-two-arrays-have-the-“same”-elements-with-the-same-multiplicities-“Same”-means-here-that-the-elements-in-b-are-the-elements-in-a-squared-regardless-of-the-order"><a href="#1｜Given-two-arrays-a-and-b-write-a-function-comp-a-b-orcompSame-a-b-that-checks-whether-the-two-arrays-have-the-“same”-elements-with-the-same-multiplicities-“Same”-means-here-that-the-elements-in-b-are-the-elements-in-a-squared-regardless-of-the-order" class="headerlink" title="1｜Given two arrays a and b write a function comp(a, b) (orcompSame(a, b)) that checks whether the two arrays have the “same” elements, with the same multiplicities. “Same” means, here, that the elements in b are the elements in a squared, regardless of the order."></a>1｜Given two arrays <code>a</code> and <code>b</code> write a function <code>comp(a, b)</code> (or<code>compSame(a, b)</code>) that checks whether the two arrays have the “same” elements, with the same <em>multiplicities</em>. “Same” means, here, that the elements in <code>b</code> are the elements in <code>a</code> squared, regardless of the order.</h5><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-18-024925.png" alt="image-20210318104921162"></p><blockquote><p>解决方法：排序后对比</p><p>因为数组或者是列表无序，如果使用for循环挨个对比，则时间复杂度为$O(n^2)$；</p><p>所以使用排序后对比可以降低时间复杂度，而且可以保证正确性。</p></blockquote><blockquote><p>语法：try、except、sorted()函数</p><p>if……else和try、except的区别？</p><p>try和except是python的异常处理</p><ul><li><input disabled="" type="checkbox"> python异常处理</li></ul><p>sorted函数</p><p><code>sorted(iterable, ***, key=None, reverse=False)</code></p><p>Return a new sorted list from the items in <em>iterable</em>.</p><p><em>key</em> specifies a function of one argument that is used to extract a comparison key from each element in <em>iterable</em> (for example, <code>key=str.lower</code>). The default value is <code>None</code> (compare the elements directly).</p><p>key就是一个函数的功能</p><p><em>reverse</em> is a boolean value. If set to <code>True</code>, then the list elements are sorted as if each comparison were reversed.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>]<br>b = <span class="hljs-built_in">sorted</span>(a,key=<span class="hljs-built_in">str</span>.lower,reverse=<span class="hljs-literal">True</span>)<br>print(b)<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">comp</span>(<span class="hljs-params">array1, array2</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sorted</span>([i ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> array1]) == <span class="hljs-built_in">sorted</span>(array2)<br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">comp</span>(<span class="hljs-params">array1, array2</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">sorted</span>([i*i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> array1]) == <span class="hljs-built_in">sorted</span>(array2):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h5 id="2｜print-Error"><a href="#2｜print-Error" class="headerlink" title="2｜print Error"></a>2｜print Error</h5><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-19-003310.png" alt="image-20210319083309725"></p><blockquote><p>解题思路：</p><p>就是在目标串中找出不符合要求的串，python中提供的机制有两种；第一种是使用re库进行查找，第二种是普通的查找，不满足要求的count++；</p><p>1、利用正则表达式</p><p>2、利用string的运算</p></blockquote><blockquote><p>语法：</p><p>正则表达式：<a href="https://docs.python.org/zh-cn/3/library/re.html?highlight=re#module-re">https://docs.python.org/zh-cn/3/library/re.html?highlight=re#module-re</a></p></blockquote><blockquote><p>语法：</p><p>string的查找与判断（子串的查找）</p><ul><li><pre><code class="python">[x for x in s if x not in &quot;abcdefghijklm&quot;]<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- ```python<br>  if i &gt; <span class="hljs-string">&quot;m&quot;</span>:<br></code></pre></td></tr></table></figure></code></pre></li></ul><p>len()函数的使用</p><ul><li><p>Return the length (the number of items) of an object. The argument may be a sequence (<code>such as a string, bytes, tuple, list, or range</code>) or a collection (such as a dictionary, set, or frozen set).</p></li><li><p>len()函数中参数可以是字符串、字节？、元素、列表或者是范围，字典、集合、冻结集</p></li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 利用正则表达式</span><br><span class="hljs-keyword">from</span> re <span class="hljs-keyword">import</span> sub<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printer_error</span>(<span class="hljs-params">s</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#125;/&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(sub(<span class="hljs-string">&quot;[a-m]&quot;</span>,<span class="hljs-string">&#x27;&#x27;</span>,s)),<span class="hljs-built_in">len</span>(s))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printer_error</span>(<span class="hljs-params">s</span>):</span><br>    <span class="hljs-keyword">import</span> re<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(re.findall(<span class="hljs-string">&#x27;[n-z]&#x27;</span>, s))) + <span class="hljs-string">&quot;/&quot;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(s))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printer_error</span>(<span class="hljs-params">s</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#125;/&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>([x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> s <span class="hljs-keyword">if</span> x <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;abcdefghijklm&quot;</span>]), <span class="hljs-built_in">len</span>(s))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printer_error</span>(<span class="hljs-params">s</span>):</span><br>    errors = <span class="hljs-number">0</span><br>    count = <span class="hljs-built_in">len</span>(s)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:<br>        <span class="hljs-keyword">if</span> i &gt; <span class="hljs-string">&quot;m&quot;</span>:<br>            errors += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(errors) + <span class="hljs-string">&quot;/&quot;</span> + <span class="hljs-built_in">str</span>(count)<br></code></pre></td></tr></table></figure><h4 id="2021-3-20"><a href="#2021-3-20" class="headerlink" title="2021-3-20"></a>2021-3-20</h4><h5 id="1｜Find-the-unique-number"><a href="#1｜Find-the-unique-number" class="headerlink" title="1｜Find the unique number"></a>1｜Find the unique number</h5><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-20-092501.png" alt="image-20210320172458124"></p><blockquote><p>算法：</p><p>扫描数组，找到数组中count = 1的元素并输出</p></blockquote><blockquote><p>语法：</p><p>1、使用set（集合）的性质：set中会有去重的功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 对set内元素的赋值</span><br>s = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;<br>a ,b = s<br><span class="hljs-comment"># a = 1</span><br><span class="hljs-comment"># b = 3</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>2、count()方法的使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.count(x) <span class="hljs-comment"># x在s中出现的次数</span><br></code></pre></td></tr></table></figure><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-20-093528.png" alt="image-20210320173528204"></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_uniq</span>(<span class="hljs-params">arr</span>):</span><br>    a, b = <span class="hljs-built_in">set</span>(arr)<br>    <span class="hljs-keyword">return</span> a <span class="hljs-keyword">if</span> arr.count(a) == <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> b<br></code></pre></td></tr></table></figure><h5 id="2｜Take-a-Ten-Minute-Walk"><a href="#2｜Take-a-Ten-Minute-Walk" class="headerlink" title="2｜Take a Ten Minute Walk"></a>2｜Take a Ten Minute Walk</h5><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-20-094310.png" alt="image-20210320174310503"></p><blockquote><p>语法：</p><p>count()方法的使用</p></blockquote><blockquote><p>算法：</p><p>如果返回原点则n、s、w、e的计数相同</p><p>经过多次变化的后仍为0，n与s为相反，所以遇到n则加1，遇到s则减1；w与e同理;</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isValidWalk</span>(<span class="hljs-params">walk</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(walk) == <span class="hljs-number">10</span> <span class="hljs-keyword">and</span> walk.count(<span class="hljs-string">&#x27;n&#x27;</span>) == walk.count(<span class="hljs-string">&#x27;s&#x27;</span>) <span class="hljs-keyword">and</span> walk.count(<span class="hljs-string">&#x27;e&#x27;</span>) == walk.count(<span class="hljs-string">&#x27;w&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isValidWalk</span>(<span class="hljs-params">walk</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(walk) != <span class="hljs-number">10</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    x, y = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> direction <span class="hljs-keyword">in</span> walk:<br>        <span class="hljs-keyword">if</span> direction == <span class="hljs-string">&#x27;n&#x27;</span>:<br>            y += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> direction == <span class="hljs-string">&#x27;s&#x27;</span>:<br>            y -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> direction == <span class="hljs-string">&#x27;e&#x27;</span>:<br>            x += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> direction == <span class="hljs-string">&#x27;w&#x27;</span>:<br>            x -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">return</span> x == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> y == <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h5 id="3｜The-Supermarket-Queue"><a href="#3｜The-Supermarket-Queue" class="headerlink" title="3｜The Supermarket Queue"></a>3｜The Supermarket Queue</h5><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-20-145114.png" alt="image-20210320225114354"></p><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-20-145125.png" alt="image-20210320225125006"></p><blockquote><p>算法：</p></blockquote><blockquote><p>语法：</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
      <category>Base</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>grammar</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0_C++_小型项目</title>
    <link href="/2021/03/10/0-CPP-%E5%B0%8F%E5%9E%8B%E9%A1%B9%E7%9B%AE/"/>
    <url>/2021/03/10/0-CPP-%E5%B0%8F%E5%9E%8B%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="C-实现监控和运动检测"><a href="#C-实现监控和运动检测" class="headerlink" title="C++ 实现监控和运动检测"></a>C++ 实现监控和运动检测</h3><p><code>Makefile|OOP|OpenGL GLUT</code></p><h4 id="1｜环境配置"><a href="#1｜环境配置" class="headerlink" title="1｜环境配置"></a>1｜环境配置</h4><h5 id="1｜安装opencv"><a href="#1｜安装opencv" class="headerlink" title="1｜安装opencv"></a>1｜安装opencv</h5><blockquote><p>1、使用brew 安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install opencv<br></code></pre></td></tr></table></figure><p>2、安装完成后需要添加部分内容到<code>.zshrc</code>中，按照要求进行添加</p><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-10-073515.png" alt="image-20210310153515559"></p><p>3、测试安装是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install opencv-python<br></code></pre></td></tr></table></figure><p>4、安装完成后，使用python测试，测试显示安装成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3 <br>import cv2<br><span class="hljs-built_in">print</span>(cv2.__version__)<br></code></pre></td></tr></table></figure><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-10-073748.png" alt="image-20210310153748185"></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>小型项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>小型项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python爬虫</title>
    <link href="/2021/03/09/2-Python-%E7%88%AC%E8%99%AB/"/>
    <url>/2021/03/09/2-Python-%E7%88%AC%E8%99%AB/</url>
    
    <content type="html"><![CDATA[<hr><p>[TOC]</p><h3 id="0｜目标"><a href="#0｜目标" class="headerlink" title="0｜目标"></a>0｜目标</h3><ul><li><input disabled="" type="checkbox"> 完成蓝桥的11节课程</li><li><input disabled="" type="checkbox"> 爬取2020年经济学人的文章标题</li><li><input disabled="" type="checkbox"> 爬取链家的房价数据</li><li><input disabled="" type="checkbox"> 爬取小木虫的调剂信息，并保存在excel中</li><li><input disabled="" type="checkbox"> 爬取一个感兴趣的微信公众号</li><li><input disabled="" type="checkbox"> 爬取习大大重要讲话的文章，并按照关键字进行提取内容</li><li><input disabled="" type="checkbox"> 爬取B站的弹幕实现词云图片</li></ul><h3 id="1｜爬虫实现的原理以及简单步骤"><a href="#1｜爬虫实现的原理以及简单步骤" class="headerlink" title="1｜爬虫实现的原理以及简单步骤"></a>1｜爬虫实现的原理以及简单步骤</h3><blockquote><p>写爬虫就是通过python程序模拟HTTP协议，通过python中的编程技巧，让网站的服务器通过HTTP协议返回给写好的解析程序，然后将部分有用的数据通过筛选，然后存储到本地。</p></blockquote><h4 id="1｜http协议与https协议"><a href="#1｜http协议与https协议" class="headerlink" title="1｜http协议与https协议"></a>1｜http协议与https协议</h4><blockquote><p>HTTP协议的消息结构：客户端请求消息，服务器响应消息</p><p>客户端的请求消息就是请求报文，服务器的响应消息就是响应报文。</p><p>请求报文（request)：状态行、消息报头、空行、响应正文</p><p>响应报文（response)：请求头、请求数据、响应正文</p></blockquote><h5 id="1｜requsest"><a href="#1｜requsest" class="headerlink" title="1｜requsest"></a>1｜requsest</h5><blockquote><p>request url：请求地址</p><p>request method:请求方法</p><p>status code:状态码</p><p>remote address：当前HTTP请求的远程地址</p><p>reference policy：用于设置referrer策略<code>不知道怎么用</code></p></blockquote><h5 id="2｜request-header"><a href="#2｜request-header" class="headerlink" title="2｜request header"></a>2｜request header</h5><blockquote></blockquote><h4 id="2｜浏览器与服务器"><a href="#2｜浏览器与服务器" class="headerlink" title="2｜浏览器与服务器"></a>2｜浏览器与服务器</h4><h5 id="1｜浏览器的工作原理"><a href="#1｜浏览器的工作原理" class="headerlink" title="1｜浏览器的工作原理"></a>1｜浏览器的工作原理</h5><blockquote><ul><li>请说说从你在浏览器地址栏输入网站到你看到网页中间都发生了什么？</li></ul><p><a href="https://www.youtube.com/watch?v=jaPpP3cdgDQ">https://www.youtube.com/watch?v=jaPpP3cdgDQ</a></p></blockquote><h5 id="2｜URL"><a href="#2｜URL" class="headerlink" title="2｜URL"></a>2｜URL</h5><blockquote><p>一般的URL为：<a href="//%E8%AE%BF%E9%97%AE%E8%B5%84%E6%BA%90%E9%9C%80%E8%A6%81%E7%9A%84%E5%87%AD%E8%AF%81%E4%BF%A1%E6%81%AF@%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%B0%E5%9D%80:%E7%AB%AF%E5%8F%A3%E5%8F%B7/%E8%B5%84%E6%BA%90%E5%B1%82%E7%BA%A7UNIX%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E6%96%87%E4%BB%B6%E5%90%8D?%E6%9F%A5%E8%A9%A2#%E7%89%87%E6%AE%B5ID">  协议类型  </a> : //服务器地址:端口号/资源层级UNIX文件路径文件名?查詢#片段ID</p><p>其中[访问凭证信息]、[端口号]、[查询]、[片段ID]都属于选填项。</p></blockquote><blockquote><p>通常服务器为域名，有时也为ip地址</p></blockquote><blockquote><p><a href="https://www.youtube.com/watch?v=ZMjhBB17KVY">https://www.youtube.com/watch?v=ZMjhBB17KVY</a></p><p>https 为协议</p><p><a href="http://www.youtube.com/">www.youtube.com</a> 为域名</p><p>watch 为资源层级</p><p>v=ZMjhBB17KVY 为查询</p></blockquote><h5 id="3｜服务器"><a href="#3｜服务器" class="headerlink" title="3｜服务器"></a>3｜服务器</h5><blockquote><p><strong>服务器</strong>（英語：server）指：</p><ul><li>一个管理资源并为用户提供服务的计算机软件，通常分为<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8">文件服务器</a>（能使用户在其它计算机存取<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6">文件</a>），<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8">数据库服务器</a>和<a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9C%8D%E5%8A%A1%E5%99%A8">应用程序服务器</a>。</li><li>运行以上软件的<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA">计算机</a>，或稱為**<a href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E6%9C%BA_(%E7%BD%91%E7%BB%9C)">網路主機</a>**（host）。</li></ul><p>服务器与主機不同，主机是通过<a href="https://zh.wikipedia.org/wiki/%E7%B5%82%E7%AB%AF">终端</a>给用户使用的，服务器是通过网络给<a href="https://zh.wikipedia.org/wiki/%E5%AE%A2%E6%88%B7%E7%AB%AF">客户端</a>用户使用的，所以除了要擁有終端裝置，還要利用網路才能使用伺服器電腦，但用戶連上線後就能使用伺服器上的特定服務了。</p><p><a href="https://www.youtube.com/watch?v=L1O2zo3fGys">https://www.youtube.com/watch?v=L1O2zo3fGys</a></p></blockquote><h5 id="4｜DNS缓存"><a href="#4｜DNS缓存" class="headerlink" title="4｜DNS缓存"></a>4｜DNS缓存</h5><blockquote><p>为了提升域名查询效率，设计了域名缓存机制，当访问过某个网站并得到其IP后，会将其域名和IP缓存下来，下一次访问的时候，就不需要再请求域名服务器获取IP，直接使用缓存中的IP，提高了响应的速度。当然缓存是有有效时间（即TTL值）的，当过了有效时间后，再次请求网站，还是需要先请求域名解析。</p><p>baidu和google就需要使用DNS的缓存机制了</p></blockquote><h5 id="5｜Request-Headers-计算机网络应用层"><a href="#5｜Request-Headers-计算机网络应用层" class="headerlink" title="5｜Request Headers                                                                                               计算机网络应用层"></a>5｜Request Headers                                                                                               <code>计算机网络应用层</code></h5><blockquote><p>我们不断地请求一个网页数据，肯定会被检测到异常，所以我们需要考虑使用代理和Useragent。</p><p>有一些网站不喜欢被爬虫程序访问，所以会检测连接对象，如果是爬虫程序，也就是非人点击访问，它就会不让你继续访问，所以为了要让程序可以正常运行，需要隐藏自己的爬虫程序的身份。此时，我们就可以通过设置User Agent的来达到隐藏身份的目的，User Agent的中文名为用户代理，简称UA。</p><p>在HTTP的请求中使用，其实就是HTTP的请求报文</p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-10-085113.png" alt="image-20210310165113253" style="zoom:50%;" /><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-10-085235.png" alt="image-20210310165235350" style="zoom:50%;" /></blockquote><h5 id="6｜IP代理"><a href="#6｜IP代理" class="headerlink" title="6｜IP代理"></a>6｜IP代理</h5><blockquote><p>User Agent已经设置好了，但是还应该考虑一个问题，程序的运行速度是很快的，如果我们利用一个爬虫程序在网站爬取东西，一个固定IP的访问频率就会很高，这不符合人为操作的标准，因为人操作不可能在几ms内，进行如此频繁的访问。所以一些网站会设置一个IP访问频率的阈值，如果一个IP访问频率超过这个阈值，说明这个不是人在访问，而是一个爬虫程序。</p><ul><li><input disabled="" type="checkbox"> 设置IP代理</li></ul></blockquote><h5 id="7｜设置Cookie"><a href="#7｜设置Cookie" class="headerlink" title="7｜设置Cookie"></a>7｜设置Cookie</h5><blockquote><p>Http协议是无状态的，也就是说同一个人对服务器发送了两次请求，服务器没有能力知道这是否来自同一个人，因此就需要cookie来帮助服务器进行标识，因此当我们想要爬取需要登陆的网站时，我们就需要设置相应的Cookie。</p></blockquote><h5 id="8｜HTML代码"><a href="#8｜HTML代码" class="headerlink" title="8｜HTML代码"></a>8｜HTML代码</h5><blockquote><p>分别有什么用？</p><p>我们想要爬取的信息就藏在html代码中，我们可以通过解析方法提取其中我们想要的内容。如果html代码里面没有我们想要的数据，但是在网页里面却看到了，那就是浏览器通过ajax请求异步加载（偷偷下载）了那部分数据。</p><blockquote><p>CSS文件：css文件是把css代码放入一个单独盛放css的文件，css是以.css为扩展命名的，我们看到以.css为后缀的文件就是css文件。它是一种与html语言配合使用制作网页的文件，它的作用主要是控制html文章的布局，简单的说就是控制网页的显示外观。</p><p>JS文件：JavaScript 是一种解释型语言。因此，它不需要编译。JavaScript 以交互式和动态的方式呈现网页。这允许页面对事件做出反应，展示特殊效果，接受可变文本，验证数据，创建 cookie，检测用户的浏览器等。</p></blockquote></blockquote><h4 id="3｜编码与解码"><a href="#3｜编码与解码" class="headerlink" title="3｜编码与解码"></a>3｜编码与解码</h4><h3 id="2｜项目1-爬取蓝桥的全部课程标题"><a href="#2｜项目1-爬取蓝桥的全部课程标题" class="headerlink" title="2｜项目1:爬取蓝桥的全部课程标题"></a>2｜项目1:爬取蓝桥的全部课程标题</h3><h4 id="1｜使用环境"><a href="#1｜使用环境" class="headerlink" title="1｜使用环境"></a>1｜使用环境</h4><blockquote><p>使用vs code进行实现，因为是属于小项目，所以选用vs code进行编译</p></blockquote><h4 id="2｜实现Request对象"><a href="#2｜实现Request对象" class="headerlink" title="2｜实现Request对象"></a>2｜实现Request对象</h4><blockquote><p>URL：<a href="https://lanqiao-horuikidi.vercel.app/">https://lanqiao-horuikidi.vercel.app/</a></p></blockquote><h5 id="1｜requests库中get方法"><a href="#1｜requests库中get方法" class="headerlink" title="1｜requests库中get方法"></a>1｜requests库中get方法</h5><blockquote><p><code>requests库的文档</code><a href="https://requests.readthedocs.io/en/master/">https://requests.readthedocs.io/en/master/</a></p><p>get方法是发起网络请求的方法，可以在get方法中添加相关的参数，如url、headers、proxies等参数</p></blockquote><h5 id="2｜re库"><a href="#2｜re库" class="headerlink" title="2｜re库"></a>2｜re库</h5><blockquote><p>re库为python中自带的正则表达式的库，正则表达式是要好好学习一下的，因为在c++和python中都可以用到，同时以后的数据分析也可以用到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">result = re.match(<span class="hljs-string">&quot;str1&quot;</span>,<span class="hljs-string">&quot;str2&quot;</span>)<br></code></pre></td></tr></table></figure></blockquote><h4 id="3｜代码实现"><a href="#3｜代码实现" class="headerlink" title="3｜代码实现"></a>3｜代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br><span class="hljs-comment"># 定义函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_course</span>(<span class="hljs-params">url</span>):</span><br><span class="hljs-comment"># 设置请求头</span><br>    headers = &#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span> : <span class="hljs-string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 11_1_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36&#x27;</span>&#125;<br><span class="hljs-comment"># 使用get方法来发送请求</span><br>    res = requests.get(url,headers = headers)<br><span class="hljs-comment">#保存返回内容</span><br>    html_data = res.text<br><span class="hljs-comment">#   print(html_data)</span><br><span class="hljs-comment">#利用re库中的正则表达式的findall方法，查找html_data中满足正则表达式要求的内容，并返回到</span><br><span class="hljs-comment">#  results中</span><br>    results = re.findall(<span class="hljs-string">&#x27;&lt;h6 title=&quot;(.*)&quot; class=&quot;course-name&quot;&#x27;</span>,html_data)<br><span class="hljs-comment">#   print(results)</span><br><span class="hljs-comment">#利用循环将results中的结果格式化保存到文件data.txt中</span><br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> results:<br>        new_str = <span class="hljs-string">&quot;课程名:&#123;&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(item)<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./data.txt&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:<br>            f.write(new_str)<br><span class="hljs-comment">#使用python中列表数据结构保存所有的页面，通过循环结果一次爬取各个页面中的内容</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    start_urls = [<span class="hljs-string">&#x27;https://www.lanqiao.cn/courses/?page=1&#x27;</span>,]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">32</span>):<br>        start_urls.append(<span class="hljs-string">f&#x27;https://www.lanqiao.cn/courses/?page=<span class="hljs-subst">&#123;i&#125;</span>&#x27;</span>)<br>    <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> start_urls:<br>        save_course(url)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><blockquote><ul><li><p><input disabled="" type="checkbox">  python的文件操作</p></li><li><p><input disabled="" type="checkbox">  python的函数定义及使用</p></li><li><p><input disabled="" type="checkbox">  python中元组、列表、字典等数据结构的使用</p></li><li><p><input disabled="" type="checkbox">  python中的正则表达式</p></li></ul></blockquote><h3 id="3｜小米应用商店APP排行榜爬取"><a href="#3｜小米应用商店APP排行榜爬取" class="headerlink" title="3｜小米应用商店APP排行榜爬取"></a>3｜小米应用商店APP排行榜爬取</h3><p><code>HTTP协议介绍｜requests库响应体｜re库的使用｜批量的图片存储</code></p><h4 id="1｜requests库响应体"><a href="#1｜requests库响应体" class="headerlink" title="1｜requests库响应体"></a>1｜requests库响应体</h4><blockquote><ul><li>文本形式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br>res = requests.get(<span class="hljs-string">&quot;https://app.mi.com/&quot;</span>)<br><span class="hljs-comment"># python中枚举的使用</span><br><span class="hljs-keyword">if</span> res.status_code == requests.codes.ok:<br>    print(<span class="hljs-string">&quot;请求成功&quot;</span>)<br><span class="hljs-comment"># 设置响应体内容格式</span><br>res.encoding = <span class="hljs-string">&quot;utf-8&quot;</span><br><span class="hljs-comment"># 以文本的形式访问响应体</span><br>html_data = res.text<br>print(html_data)<br></code></pre></td></tr></table></figure><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-12-032505.png" alt="image-20210312112505040"></p><ul><li>字节形式：获取响应体的主要场景应用在图片获取、文件获取、视频音频获取</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br>img_url = <span class="hljs-string">&quot;https://image.baidu.com/search/detail?ct=503316480&amp;z=0&amp;ipn=d&amp;word=tupian&amp;step_word=&amp;hs=0&amp;pn=0&amp;spn=0&amp;di=8360&amp;pi=0&amp;rn=1&amp;tn=baiduimagedetail&amp;is=0%2C0&amp;istype=0&amp;ie=utf-8&amp;oe=utf-8&amp;in=&amp;cl=2&amp;lm=-1&amp;st=undefined&amp;cs=3363295869%2C2467511306&amp;os=892371676%2C71334739&amp;simid=4203536407%2C592943110&amp;adpicid=0&amp;lpn=0&amp;ln=1584&amp;fr=&amp;fmq=1615519984102_R&amp;fm=&amp;ic=undefined&amp;s=undefined&amp;hd=undefined&amp;latest=undefined&amp;copyright=undefined&amp;se=&amp;sme=&amp;tab=0&amp;width=undefined&amp;height=undefined&amp;face=undefined&amp;ist=&amp;jit=&amp;cg=&amp;bdtype=0&amp;oriquery=&amp;objurl=https%3A%2F%2Fgimg2.baidu.com%2Fimage_search%2Fsrc%3Dhttp%3A%2F%2Fa0.att.hudong.com%2F30%2F29%2F01300000201438121627296084016.jpg%26refer%3Dhttp%3A%2F%2Fa0.att.hudong.com%26app%3D2002%26size%3Df9999%2C10000%26q%3Da80%26n%3D0%26g%3D0n%26fmt%3Djpeg%3Fsec%3D1618111986%26t%3D9ce41e27eeee1e538b7f6dd2f32a3687&amp;fromurl=ippr_z2C%24qAzdH3FAzdH3Fooo_z%26e3Bfhyvg8_z%26e3Bv54AzdH3F4AzdH3Fetjo_z%26e3Brir%3Fwt1%3Dmb9l9&amp;gsm=1&amp;rpstart=0&amp;rpnum=0&amp;islist=&amp;querylist=&amp;force=undefined&quot;</span><br>res2 = requests.get(img_url)<br><span class="hljs-keyword">if</span> res2.status_code == requests.codes.ok:<br>    print(<span class="hljs-string">&quot;OK&quot;</span>)<br>html_context = res2.content<br>print(html_context)<br></code></pre></td></tr></table></figure><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-12-032603.png" alt="image-20210312112603085"></p><ul><li>json序列化</li></ul><p>报错</p><ul><li>套接字</li></ul><p>&lt;urllib3.response.HTTPResponse object at 0x7f828c02ef10&gt;</p></blockquote><h4 id="2｜代码实现"><a href="#2｜代码实现" class="headerlink" title="2｜代码实现"></a>2｜代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> time<br><span class="hljs-comment"># 请求的网址</span><br>url = <span class="hljs-string">&#x27;https://app.mi.com/topList?page=1&#x27;</span><br><span class="hljs-comment"># 设置请求头</span><br>headers = &#123;<br>    <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 11_1_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82 Safari/537.36&#x27;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_img</span>(<span class="hljs-params">img_url,name</span>):</span><br>    img_res = requests.get(url = img_url,headers = headers)<br>    <span class="hljs-keyword">if</span> img_res.status_code == requests.codes.ok:<br>        data = img_res.content<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span> (<span class="hljs-string">&quot;./icons/&#123;name&#125;.png&quot;</span>.<span class="hljs-built_in">format</span>(name = name),<span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>            f.write(data)<br>        print(<span class="hljs-string">&quot;&#123;name&#125; - 图片存储完毕&quot;</span>.<span class="hljs-built_in">format</span>(name = name))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_item</span>(<span class="hljs-params">page</span>):</span><br>    url = <span class="hljs-string">&quot;https://app.mi.com/topList?page=&#123;page&#125;&quot;</span>.<span class="hljs-built_in">format</span>(page = page)<br>    res = requests.get(url=url,headers = headers)<br>    <span class="hljs-keyword">if</span> res.status_code == requests.codes.ok:<br>        html = res.text<br>        pattern = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;&lt;li&gt;&lt;a href=&quot;/details(.*?)&quot;&gt;&lt;img data-src=&quot;(.*?)&quot; src=&quot;(.*?)&quot; alt=&quot;(.*?)&quot; width=&quot;72&quot; height=&quot;72&quot;&gt;&lt;/a&gt;&lt;h5&gt;&lt;a href=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&lt;/h5&gt;&lt;p class=&quot;(.*?)&quot;&gt;&lt;a href=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#x27;</span>)<br>        iterms = pattern.findall(html)<br>        <span class="hljs-keyword">for</span> iterm <span class="hljs-keyword">in</span> iterms:<br>            save_img(iterm[<span class="hljs-number">1</span>],iterm[<span class="hljs-number">3</span>])<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>):<br>        print(<span class="hljs-string">&quot;正在爬取第&#123;page&#125;页&quot;</span>.<span class="hljs-built_in">format</span>(page = page))<br>        get_item(page)<br>        time.sleep(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><blockquote><p>这个就属于一个小型的python爬虫了，一步一步分析</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>爬虫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Introduction to Algorithms：Sorting And Finding</title>
    <link href="/2021/03/03/1_AL_Introduction_to_Algorithms_Sorting/"/>
    <url>/2021/03/03/1_AL_Introduction_to_Algorithms_Sorting/</url>
    
    <content type="html"><![CDATA[<h2 id="第一部分：基础知识"><a href="#第一部分：基础知识" class="headerlink" title="第一部分：基础知识"></a>第一部分：基础知识</h2><h2 id="第二部分-：排序与顺序统计量"><a href="#第二部分-：排序与顺序统计量" class="headerlink" title="第二部分 ：排序与顺序统计量"></a>第二部分 ：排序与顺序统计量</h2><h3 id="一、排序"><a href="#一、排序" class="headerlink" title="一、排序"></a>一、排序</h3><blockquote><p>四分之一的CPU时间都在执行同一类的计算：按照某种约定的次序，将给定的一组元素进行排序。</p></blockquote><h4 id="0｜two-pointers"><a href="#0｜two-pointers" class="headerlink" title="0｜two pointers"></a>0｜two pointers</h4><h4 id="1｜选择排序"><a href="#1｜选择排序" class="headerlink" title="1｜选择排序"></a>1｜选择排序</h4><p><code>直接选择｜胜者树｜堆</code></p><h5 id="1｜直接选择排序模版"><a href="#1｜直接选择排序模版" class="headerlink" title="1｜直接选择排序模版"></a>1｜直接选择排序模版</h5><blockquote><p>从V[i] ~V[n-1]中每轮次选取出最小的元素（或者是最小排序码<code>即数组的下标</code>）</p><p><code>Notice:</code>使用排序码也是一种编程技巧</p><p><code>KCN比较次数</code>：KCN = ${n(n-1)\over 2}$</p><p><code>RMN移动次数</code>：$RMN<del>max</del>= 3(n-1)$​</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SelectSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left;i&lt;right;i++)<br>  &#123;<br>   <span class="hljs-comment">//设置单指针，为了后续的交换使用</span><br>    <span class="hljs-keyword">int</span> k = i;<br>   <span class="hljs-comment">//从q[i]~q[right-1]中选取最小的元素，找出当前元素的最小排序码。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>;j&lt;right;j++)<span class="hljs-keyword">if</span>(q[j] &lt; q[k])k=j;<br>   <span class="hljs-comment">//边界条件，如果说存在排序码则进行交换</span><br>  <span class="hljs-keyword">if</span>(k!=i)swap(q[k],q[i]);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2｜锦标赛排序模版（使用胜者树实现）"><a href="#2｜锦标赛排序模版（使用胜者树实现）" class="headerlink" title="2｜锦标赛排序模版（使用胜者树实现）"></a>2｜锦标赛排序模版（使用胜者树实现）</h5><h5 id="3｜堆排序（使用堆结构和形成堆的算法实现）"><a href="#3｜堆排序（使用堆结构和形成堆的算法实现）" class="headerlink" title="3｜堆排序（使用堆结构和形成堆的算法实现）"></a>3｜堆排序（使用堆结构和形成堆的算法实现）</h5><h4 id="2｜插入排序"><a href="#2｜插入排序" class="headerlink" title="2｜插入排序"></a>2｜插入排序</h4><h4 id="3｜快速排序"><a href="#3｜快速排序" class="headerlink" title="3｜快速排序"></a>3｜快速排序</h4><h5 id="1｜快速排序模版"><a href="#1｜快速排序模版" class="headerlink" title="1｜快速排序模版"></a>1｜快速排序模版</h5><p><code>双指针｜边界条件判断｜时间复杂度｜TLE（超时）错误</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//此模版存在问题，做题可能会出现Time Limit Exceeded问题</span><br><span class="hljs-comment">//因为此模版式中定义起始位置为A[left],如果为递增或者是递减序列，则时间复杂度为O(n^2),而不是O（nlogn）</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Partition</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> A[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> temp = A[left];<br>  <span class="hljs-keyword">while</span>(left &lt; right)<br>  &#123;<br>    <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; A[right]&gt;temp)right--;<br>    A[left] = A[right];<br>    <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; A[left] &lt;= temp)left++;<br>    A[right] = A[left];<br>  &#125;<br>  A[left] = temp;<br>  <span class="hljs-keyword">return</span> left;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(left &lt; right)<br>  &#123;<br>    <span class="hljs-keyword">int</span> pos = Partition(A,left,right);<br>    quickSort(A,left,pos<span class="hljs-number">-1</span>);<br>    quickSort(A,pos+<span class="hljs-number">1</span>,right);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//测试通过的快速排序模版</span><br><span class="hljs-comment">//边界条件的判断比较多，所以建议在理解的基础上练熟悉模版</span><br><span class="hljs-comment">//很多算法的模版都是使用了双指针的方法进行操作的，所以双指针的使用是比较重要的，需要多加练习</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//边界条件判断</span><br>  <span class="hljs-keyword">if</span>(left &gt;= right)<span class="hljs-keyword">return</span>;<br><span class="hljs-comment">//随机取值</span><br>  <span class="hljs-keyword">int</span> tmp = q[(left+right)/<span class="hljs-number">2</span>];<br>  <span class="hljs-comment">//设置双指针，因为left和right是全局变量，所以要设置i和j为局部变量，通过i和j的变化和关系，实现程序。</span><br>  <span class="hljs-comment">//为什么要设置双指针：全局变量和局部变量的使用</span><br>  <span class="hljs-keyword">int</span> i = left<span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">int</span> j = right+<span class="hljs-number">1</span>;<br>  <span class="hljs-comment">//循环操作，直到i与j相遇，因为i与j相遇为一轮操作，</span><br>  <span class="hljs-keyword">while</span>(i &lt; j)<br>  &#123;<br>    <span class="hljs-comment">//与第9行的tmp取值有关</span><br>    <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(q[i] &lt; tmp);<br>    <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(q[j] &gt; tmp);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    此处双指针已经就位，需要补入进行的操作；进行交换、对比、取出等操作。</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span>(i &lt; j)swap(q[i],q[j]);<br>  &#125;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  1、循环结束，此时i == j的；</span><br><span class="hljs-comment">  2、后续递归处理的范围是[left,j]</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-comment">//递归处理前半段和后半段</span><br>  quickSort(q,left,j);<br>  quickSort(q,j+<span class="hljs-number">1</span>,right);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 需要进行测试，调试输出</li></ul><blockquote><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-09-021013.png" alt="image-20210309100704169" style="zoom:50%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">quickSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right,<span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(left == right)   <span class="hljs-keyword">return</span> q[left];<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">int</span> i=left<span class="hljs-number">-1</span>,j=right+<span class="hljs-number">1</span>,mid = q[left+right &gt;&gt; <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span>(i &lt; j)<br>        &#123;<br>            <span class="hljs-keyword">do</span>(i++);<span class="hljs-keyword">while</span>(q[i] &lt; mid);<br>            <span class="hljs-keyword">do</span>(j--);<span class="hljs-keyword">while</span>(q[j] &gt; mid);<br>            <span class="hljs-keyword">if</span>(i &lt; j)   swap(q[i],q[j]);<br>        &#125;<br>        quickSearch(q,left,j,k);<br>        quickSearch(q,j+<span class="hljs-number">1</span>,right,k);<br>        <br>        <span class="hljs-keyword">return</span> q[k<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n,k;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br>    <br>    <span class="hljs-built_in">cout</span> &lt;&lt; quickSearch(q,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>,k);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="4｜归并排序"><a href="#4｜归并排序" class="headerlink" title="4｜归并排序"></a>4｜归并排序</h4><h5 id="0｜算法思想"><a href="#0｜算法思想" class="headerlink" title="0｜算法思想"></a>0｜算法思想</h5><blockquote><p>基于分治的思想，将整体序列分为<code>logn</code>组数据，组内数据进行排序，排序后合并；</p><p>快排：n/2｜n/4｜n/8……</p><p>归并：……｜n/8｜n/4｜n/2｜=&gt;归并为n</p><p>所以递归调用的位置不同</p><p>归并排序需要开辟新的数组，空间换时间</p></blockquote><h5 id="1｜递归实现归并排序"><a href="#1｜递归实现归并排序" class="headerlink" title="1｜递归实现归并排序"></a>1｜递归实现归并排序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(left &gt;= right)<span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">//边界条件判断，如果只有一个元素则返回</span><br>  <span class="hljs-keyword">int</span> mid = left+right &gt;&gt; <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">//设置数组下标</span><br>  mergeSort(q,left,mid);<br>  <span class="hljs-comment">//递归调用划分左区间</span><br>  mergeSort(q,mid+<span class="hljs-number">1</span>,right);<br>  <span class="hljs-comment">//递归调用划分右区间</span><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  1、递归执行完成后，相当于是序列中的q[i]和q[j]两两对比，所以在执行16-17时已经有序了</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">//设置新开辟数组的下标</span><br>  <span class="hljs-keyword">int</span> i = left;<br>  <span class="hljs-comment">//设置双指针</span><br>  <span class="hljs-keyword">int</span> j = mid+<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right)<br>  <span class="hljs-comment">//执行循环，双指针移动</span><br>    <span class="hljs-keyword">if</span>(q[i] &lt;= q[j])tmp[k++] = q[i++];<br>  <span class="hljs-comment">//给新开辟数组赋值</span><br>  <span class="hljs-keyword">else</span> tmp[k++] = q[j++];<br>  <span class="hljs-comment">//给新开辟数组赋值</span><br>  <span class="hljs-keyword">while</span>(i&lt;= mid)tmp[k++] = q[i++];<br>  <span class="hljs-comment">//将未排序的数组导入到新开辟数组中</span><br>  <span class="hljs-keyword">while</span>(j&lt;=right)tmp[k++] = q[j++];<br>  <span class="hljs-comment">//同上</span><br>  <br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left,j=<span class="hljs-number">0</span>;i&lt;=right;i++,j++)q[i] = tmp[j];<br>  <span class="hljs-comment">//将tmp拷贝到q中，也可以直接使用c++的copy函数</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-09-094303.png" alt="image-20210309174303153" style="zoom:50%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> q[N],tmp[N];<br><span class="hljs-keyword">int</span> n;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">if</span>( left &gt;= right)  <span class="hljs-keyword">return</span>;<br> <span class="hljs-keyword">int</span> mid = (left+right) &gt;&gt; <span class="hljs-number">1</span>;<br> mergeSort(q,left,mid);<br> mergeSort(q,mid+<span class="hljs-number">1</span>,right);<br><br> <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>,i=left,j=mid+<span class="hljs-number">1</span>;<br> <span class="hljs-keyword">while</span>(i&lt;=mid &amp;&amp; j &lt;= right)<br> &#123;<br>     <span class="hljs-keyword">if</span>(q[i] &lt;= q[j]) tmp[k++] = q[i++];<br>     <span class="hljs-keyword">else</span>             tmp[k++] = q[j++];<br> &#125;<br> <span class="hljs-keyword">while</span>(i&lt;=mid)   tmp[k++] = q[i++];<br> <span class="hljs-keyword">while</span>(j&lt;=right) tmp[k++] = q[j++];<br><br> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left,j=<span class="hljs-number">0</span>;i&lt;=right;i++,j++)   q[i] = tmp[j];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br> mergeSort(q,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,q[i]);<br><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-12-090059.png" alt="image-20210312170059531" style="zoom:50%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> q[N],tmp[N];<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<br><span class="hljs-comment">//注意返回值res的类型</span><br><span class="hljs-function">LL <span class="hljs-title">Inversion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(left &gt;= right)   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> mid = (left+right) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-comment">//调用递归，递归叠加</span><br>    LL res = Inversion(q,left,mid) + Inversion(q,mid+<span class="hljs-number">1</span>,right);<br>    <span class="hljs-keyword">int</span> i=left,j=mid+<span class="hljs-number">1</span>,k=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;= mid &amp;&amp; j&lt;=right)<br>        <span class="hljs-keyword">if</span>(q[i] &lt;= q[j])    tmp[k++] = q[i++];<br>        <span class="hljs-keyword">else</span>                  <br>        &#123;<br>            res += mid-i+<span class="hljs-number">1</span>;<br>            tmp[k++] = q[j++];<br>        &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid)   tmp[k++] = q[i++];<br>    <span class="hljs-keyword">while</span>(j&lt;=right) tmp[k++] = q[j++];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left,j=<span class="hljs-number">0</span>;i&lt;=right;i++,j++)    q[i] = tmp[j];<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> n;<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br>  <span class="hljs-built_in">cout</span> &lt;&lt; Inversion(q,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="2｜非递归实现归并排序"><a href="#2｜非递归实现归并排序" class="headerlink" title="2｜非递归实现归并排序"></a>2｜非递归实现归并排序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br></code></pre></td></tr></table></figure><h4 id="5｜冒泡排序"><a href="#5｜冒泡排序" class="headerlink" title="5｜冒泡排序"></a>5｜冒泡排序</h4><h5 id="1｜冒泡排序的思想"><a href="#1｜冒泡排序的思想" class="headerlink" title="1｜冒泡排序的思想"></a>1｜冒泡排序的思想</h5><blockquote><p>冒泡排序时比较简单的排序方法</p><p>冒泡排序基于的关系:满足$A[i - 1] &lt;= A[i]$,保证相邻的元素间有序，但是不能保证整体有序，所以时间复杂度为$O(n^2)$。</p><p><code>1 3 5 8 2 6 7 9 </code></p><p>第一轮循环：<code>1 3 5 2 6 7 8 9</code>：因为i是一直前进的，没有回溯，所以就不能判断出<code>5 2 </code>的大小，所以要进行后续的循环。</p></blockquote><h5 id="2｜冒泡排序模版"><a href="#2｜冒泡排序模版" class="headerlink" title="2｜冒泡排序模版"></a>2｜冒泡排序模版</h5><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-comment">//冒泡排序模版：</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//整体的排序标志，首先假定整体尚未排序 </span><br>  <span class="hljs-keyword">bool</span> sorted = <span class="hljs-literal">false</span>;<br>  <span class="hljs-comment">//sort = false时，!sort = true，进入循环，经常使用的方法</span><br>  <span class="hljs-comment">//循环直到sorted == true时，退出循环;sorted == true的条件就是没有过交换，</span><br>    <span class="hljs-keyword">while</span>(!sorted)<br>    &#123;<br>  <span class="hljs-comment">//假设已经排好序，这样做可以减少循环次数，不需要蛮力遍历n-1趟；</span><br>      sorted = <span class="hljs-literal">true</span>;<br>  <span class="hljs-comment">//每一次循环都会保证至少有一个元素（每次排序中最大的元素）落位。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>;i&lt;n;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(a[i - <span class="hljs-number">1</span>] &gt; a[i])     <br>            &#123;<br>                swap(a[i<span class="hljs-number">-1</span>],a[i]);<br>                sorted = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>  <span class="hljs-comment">//通过n--，保证算法的有穷性</span><br>        n -- ;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 当n=5时，排序完成；但是需要多进行一趟循环，即n=4这趟循环完成后（多一趟判断是否有序）退出函数。这样就不需要进行7趟循环了。</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>&#125;;<br>    bubbleSort(<span class="hljs-built_in">array</span>,<span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">array</span>[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>有穷性和正确性分析：</p><p>正确性：经过K趟扫描交换之后，最大的前K个元素必然就位，对应14行注释</p><p>有穷性：经过K趟扫描交换之后，待求解问题的有效规模将缩减至n-k。每一次都有一个元素就位，所以经过n趟必然有序。</p></blockquote><h3 id="二、查找"><a href="#二、查找" class="headerlink" title="二、查找"></a>二、查找</h3><h4 id="1｜二分"><a href="#1｜二分" class="headerlink" title="1｜二分"></a>1｜二分</h4><blockquote><p><code>（基于数组的下标进行操作）</code></p><p>严格单调的话：不存在边界问题</p><p>有重复元素存在大量边界问题会造成死循环和查找不完全</p></blockquote><h5 id="1｜基于严格单调的有序数列"><a href="#1｜基于严格单调的有序数列" class="headerlink" title="1｜基于严格单调的有序数列"></a>1｜基于严格单调的有序数列</h5><h5 id="2｜基于不严格单调的有序序列（仍为有序序列）"><a href="#2｜基于不严格单调的有序序列（仍为有序序列）" class="headerlink" title="2｜基于不严格单调的有序序列（仍为有序序列）"></a>2｜基于不严格单调的有序序列（仍为有序序列）</h5><blockquote><p>思想：</p><p>1、找到序列中第一个大于等于x的元素的位置L，以及找到第一个大于x元素位置的R，找这两个位置都要基于二分进行查找，查找出来的区间就是[L,R），返回值为lower_bound和upper_bound</p><p>2、这样的边界主要是在代码中的判断条件进行控制。</p><p>3、基于序列<code>1 2 2 3 3 3 4 5 6</code></p><ul><li>left = 0 | right = 8 | mid = 4.    ====&gt; mid的左右两侧都有3</li><li>对left和right重新赋值if(a[mid] &lt; x)   left = mid+1;else right = mid;</li><li>left = 0｜right =4 ｜mid = 2     ====&gt;mid只有右侧有3</li><li>此时a[mid] &lt; x left = mid+1=3;</li><li>left = 3 ｜right =4｜mid = 3</li><li>此时a[mid] ==x ，则right = mid = 3,不满足循环条件while（left&lt;right)</li><li>此时如果循环条件为while（left &lt;= right)，则 mid = 3｜right = 3｜left = 3那么会发生死循环，为了</li></ul><p><code>例题：</code><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-08-144339.png" alt="image-20210308224339528"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lower_bound</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right,<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> mid;<br>    <span class="hljs-keyword">while</span>(left &lt; right)<br>    &#123;<br>        mid = left+right &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(a[mid] &gt;= x) right = mid;<br>        <span class="hljs-keyword">else</span> left = mid+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">upper_bound</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right,<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> mid;<br>    <span class="hljs-keyword">while</span>(left &lt; right)<br>    &#123;<br>        mid = left + right &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(a[mid] &gt; x)  right = mid;<br>        <span class="hljs-keyword">else</span> left = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n,x,que,LB,RB;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;x);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br><br>    <span class="hljs-keyword">while</span>(x--)<br>    &#123;   <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;que);<br>        LB = lower_bound(q,<span class="hljs-number">0</span>,n,que);<br>        RB = upper_bound(q,<span class="hljs-number">0</span>,n,que);<br>        <span class="hljs-keyword">if</span>(q[LB] != que)  LB = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(q[RB] != que )  RB = <span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; LB &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>&lt;&lt; RB &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="二、高精度计算"><a href="#二、高精度计算" class="headerlink" title="二、高精度计算"></a>二、高精度计算</h3><blockquote><p>利用结构体实现</p><p>利用vector实现</p><p>比较大小</p></blockquote><h4 id="1｜高精度加法"><a href="#1｜高精度加法" class="headerlink" title="1｜高精度加法"></a>1｜高精度加法</h4><h5 id="1｜存储方式"><a href="#1｜存储方式" class="headerlink" title="1｜存储方式"></a>1｜存储方式</h5><blockquote><p>进行运算的过程中从整数的低位到高位进行枚举，因为存在进位情况</p></blockquote><h5 id="2｜算法实现"><a href="#2｜算法实现" class="headerlink" title="2｜算法实现"></a>2｜算法实现</h5><blockquote><p>实现从低到高位存储，封装在函数内部</p><p>进位处理</p><p>位数多进行存储</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;a,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; c;<br><br>    <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;a.size() || i &lt; b.size();i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i &lt; a.size())    carry += a[i];<br>        <span class="hljs-keyword">if</span>(i &lt; b.size())    carry += b[i];<br>        c.push_back(carry % <span class="hljs-number">10</span>);<br>        carry /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>( carry ) c.push_back(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; a,b,c;<br>    <span class="hljs-built_in">string</span> add1,add2;<br>    getline(<span class="hljs-built_in">cin</span>,add1);<br>    getline(<span class="hljs-built_in">cin</span>,add2);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=add1.size()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) a.push_back(add1[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=add2.size()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) b.push_back(add2[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    c = add(a,b);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=c.size()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,c[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="2｜高精度减法"><a href="#2｜高精度减法" class="headerlink" title="2｜高精度减法"></a>2｜高精度减法</h4><h4 id="3｜高精度乘法"><a href="#3｜高精度乘法" class="headerlink" title="3｜高精度乘法"></a>3｜高精度乘法</h4><h4 id="4｜高精度除法"><a href="#4｜高精度除法" class="headerlink" title="4｜高精度除法"></a>4｜高精度除法</h4><h3 id="三｜前缀与差分"><a href="#三｜前缀与差分" class="headerlink" title="三｜前缀与差分"></a>三｜前缀与差分</h3><h4 id="1｜前缀和"><a href="#1｜前缀和" class="headerlink" title="1｜前缀和"></a>1｜前缀和</h4><blockquote><p>1、前缀和简单的理解就是数列中的前n项和，实现通过<code>递推关系实现</code>，主要把握递推关系</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//前缀和数组第i项 = 原数组的[0,i-1]+第i项的和</span><br>B[<span class="hljs-number">0</span>] = A [<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)B[i] = B[i - <span class="hljs-number">1</span>] + A[i];<br><span class="hljs-comment">//如果用原数组求的话，要定义一个sum的辅助变量。</span><br><span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>&#123;<br>  sum += A[i];<br>  B[i] = sum;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>2、C++中实现前缀和</p><ul><li><input disabled="" type="checkbox"> 需要一定的模版和类的基础，所以模版和类的语法还需要练习。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;numeric&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iterator&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>&#125;; <span class="hljs-comment">// 或 std::vector&lt;int&gt;v(10, 2);</span><br> <br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;The first 10 even numbers are: &quot;</span>;<br>    <span class="hljs-built_in">std</span>::partial_sum(v.begin(), v.end(), <br>                     <span class="hljs-built_in">std</span>::ostream_iterator&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>, <span class="hljs-string">&quot; &quot;</span>));<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br> <br>    <span class="hljs-built_in">std</span>::partial_sum(v.begin(), v.end(), v.begin(), <span class="hljs-built_in">std</span>::multiplies&lt;<span class="hljs-keyword">int</span>&gt;());<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;The first 10 powers of 2 are: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : v) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="2｜二维或者是多维的前缀和"><a href="#2｜二维或者是多维的前缀和" class="headerlink" title="2｜二维或者是多维的前缀和"></a>2｜二维或者是多维的前缀和</h4><blockquote><p>1、多维前缀和的普通求解方法几乎都是基于容斥原理，就是类似概率中去重的方法。</p><p><code>Notice：注意sum[1,0] 并不是等于sum[0,j]+sum[1,0]</code></p><p>2、求子矩阵的公式很重要的。</p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-14-030535.png" alt="image-20210314110535114" style="zoom:50%;" /><p>利用公式的时候要搞清楚边界条件</p><p>例题：</p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-14-065458.png" alt="image" style="zoom:40%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">103</span>][<span class="hljs-number">103</span>];<br><span class="hljs-keyword">int</span> b[<span class="hljs-number">103</span>][<span class="hljs-number">103</span>];  <span class="hljs-comment">// 前缀和数组，相当于上文的 sum[]</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> n, m;<br>  <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br><span class="hljs-comment">//求二维的前缀和，一般前缀和边界从1开始，到n与m结束</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>      <span class="hljs-built_in">cin</span> &gt;&gt; a[i][j];<br> <span class="hljs-comment">//二维前缀和公式</span><br>      b[i][j] =<br>          b[i][j - <span class="hljs-number">1</span>] + b[i - <span class="hljs-number">1</span>][j] - b[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + a[i][j];  <br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">int</span> l = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">while</span> (l &lt;= min(n, m)) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = l; i &lt;= n; i++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = l; j &lt;= m; j++) &#123;<br><span class="hljs-comment">//利用前缀和求子矩阵的和，因为正方形为1，所以子矩阵的和 == l*l</span><br>        <span class="hljs-keyword">if</span> (b[i][j] - b[i - l][j] - b[i][j - l] + b[i - l][j - l] == l * l) &#123;<br>          ans = max(ans, l);<br>        &#125;<br>      &#125;<br>    &#125;<br>    l++;<br>  &#125;<br><br>  <span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-built_in">endl</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="3｜基于DP求高维的前缀和"><a href="#3｜基于DP求高维的前缀和" class="headerlink" title="3｜基于DP求高维的前缀和"></a>3｜基于DP求高维的前缀和</h4><h4 id="4｜树上前缀和"><a href="#4｜树上前缀和" class="headerlink" title="4｜树上前缀和"></a>4｜树上前缀和</h4><h4 id="5｜差分"><a href="#5｜差分" class="headerlink" title="5｜差分"></a>5｜差分</h4><blockquote><p>灵活使用差分数组转前缀和，以及已知一个数组求差分数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//已知差分求前缀和</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)b[i] += b[i<span class="hljs-number">-1</span>];<br><span class="hljs-comment">// 已知前缀和求差分</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adjacent</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>  b[l] += c;<br>  b[r+<span class="hljs-number">1</span>] -= c;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)adjcent(i,i,a[i]);<span class="hljs-comment">//即得到a[N]的差分数组b[N]</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>它可以维护多次对序列的一个区间加上一个数，并在最后询问某一位的数或是多次询问某一位的数。注意修改操作一定要在查询操作之前。</p><ul><li><input disabled="" type="checkbox"> 但是为什么说减少了时间复杂度？（从$O(n) ===&gt; O(1)$)，不是还得先构造差分数组？</li></ul><p>$$a_i = b_1+b_2+……+b_i$$</p><p>$$b_1 = a_1$$</p><p>$b_2 = a_2 - a_1$</p><p>$b_3 = a_3 - a_2$</p><p>$a_1 = b_1$</p><p>$a_2 = b_1+b_2$</p><p>$a_3=b_1+b_2+b_3$</p><p>$a_4 = b_1+b_2+b_3+b_4$</p><p>实现了从1开始所有的 $a_i + c$ 的操作</p><p>$b_1=b_1+c$ </p><p>$ a_1 = a_1+c $</p><p>$a_2 = a_2+c$ </p><p>$a_3 = a_3 + c$</p><p>$a_4 = a_4 +c$</p><p>实现从5开始所有的$a_i-c$的操作，既从$a_5$开始所有的和原有数组$a_{i(&gt;=5)}$保持相同，即实现了[1,4]的区间内的书全部加c的操作</p><p>$b_5 = b_5 - c$</p><p>$a_5 = b_1+c+b_2+b_3+b_4+b_5-c$</p><p>$a_5 = a_5$</p></blockquote><blockquote><p>例题：</p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-14-084913.png" alt="image-20210314164913512" style="zoom:33%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> a[N],b[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adjacent</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    b[l] += c;<br>    b[r+<span class="hljs-number">1</span>] -=c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n,m;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br><span class="hljs-comment">//  初始化b[N],即初始化差分数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)   adjacent(i,i,a[i]);<br><span class="hljs-comment">//    printf(&quot;%d &quot;,b[0]); //b[0] == 0</span><br><span class="hljs-comment">//    for(int i=1;i&lt;=n;i++)   printf(&quot;%d &quot;,b[i]);   </span><br><span class="hljs-comment">//    cout &lt;&lt; endl;</span><br><span class="hljs-comment">//利用差分的关系来实现，在区间[l,r]内添加c的操作</span><br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> l,r,c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;c);<br>        adjacent(l,r,c);<br>    &#125;<br><span class="hljs-comment">//  操作完成之后的差分数组</span><br><span class="hljs-comment">//  for(int i=1;i&lt;=n;i++)   printf(&quot;%d &quot;,b[i]);</span><br><span class="hljs-comment">//  cout &lt;&lt; endl;</span><br><span class="hljs-comment">// 将差分数组转化为前缀和数组即所得a[N]</span><br><span class="hljs-comment">// 差分和前缀和可以相互转化，前缀和数组可以转化为差分，差分可以转化为前缀和</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)   b[i] += b[i<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,b[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="6｜树上差分"><a href="#6｜树上差分" class="headerlink" title="6｜树上差分"></a>6｜树上差分</h4><h5 id="1｜点差分"><a href="#1｜点差分" class="headerlink" title="1｜点差分"></a>1｜点差分</h5><h5 id="2｜边差分"><a href="#2｜边差分" class="headerlink" title="2｜边差分"></a>2｜边差分</h5><h3 id="四｜位运算"><a href="#四｜位运算" class="headerlink" title="四｜位运算"></a>四｜位运算</h3><h3 id="五｜离散化与区间合并"><a href="#五｜离散化与区间合并" class="headerlink" title="五｜离散化与区间合并"></a>五｜离散化与区间合并</h3><h2 id="第三部分：数据结构"><a href="#第三部分：数据结构" class="headerlink" title="第三部分：数据结构"></a>第三部分：数据结构</h2><blockquote><p>算法中较多使用的是数组模拟存储，在算法中或者是笔试（算法考试中）较少去考虑边界条件，但是要保证语法正确和输出正确。</p><p>实际工程中大多使用的是结构体形式模拟存储，在实际工程中要仔细考虑边界条件。</p><p>所以两种方法都要掌握，数组模拟主要就是解决关系问题，解决了关系问题其他操作都大致相同。</p></blockquote><h4 id="1｜单链表"><a href="#1｜单链表" class="headerlink" title="1｜单链表"></a>1｜单链表</h4><p><code>主要实现的功能：增｜删｜改｜查</code></p><blockquote><p>在算法中要保证运算的效率，所以链表使用静态链表来实现。</p></blockquote><blockquote><p>做题的时候要分清楚题目的要求与已知条件，已知条件就是区分是数组下标为k还是第k个插入的点，最好是画图理解。</p></blockquote><h5 id="1｜静态链表"><a href="#1｜静态链表" class="headerlink" title="1｜静态链表"></a>1｜静态链表</h5><blockquote><p>理解好链表中各个数据成员的</p></blockquote><blockquote><p>1、数据结构的组成元素以及关系</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> value[N],pointer[N];<br><span class="hljs-keyword">int</span> head;<br><span class="hljs-keyword">int</span> avil;<br></code></pre></td></tr></table></figure><p>静态链表主要采用双数组的形式，一个数组存储value，一个数组存储指针pointer，通过对应的关系来实现。</p><p>关系：</p><p>1｜$value[N]$和$pointer[N]$数组下标是相同的。</p><p>2｜链表之间的关系主要通过$pointer[N]$实现.</p><p>3｜在$pointer[N]$数组中，$pointer[index]$表示的是第$index$元素对应的下一个元素的下标index1，$index1 = pointer[index]$，$index2=pointer[index1]$，表示的是下标为index1的元素的下一个元素的下标；（有点绕，然是这个实现链表的关键，迭代实现）</p><ul><li><input disabled="" type="checkbox"> 需要完善</li></ul><p>4｜因为静态链表中如果要输出，必须要按照链表的顺序输出，那么就要有一个头指针，指向链表的头部。</p></blockquote><blockquote><p>2、静态链表初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  head = <span class="hljs-number">-1</span>;<br>  avil = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>3、头插法</p><p>表示向链表头插入一个数 x,链表的表头通过头指针标识。</p><p>z-&gt;y-&gt;x-&gt;NULL</p><p>head-&gt;z:标识z是链表的表头</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//在链表头部插入元素x</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Head</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>  value[avil] = x;<br>  pointer[avid] = avil;<br>  head = avil;<br>  avil++;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>4、尾插法</p></blockquote><blockquote><p>5、删除元素：也就是遍历链表的时候不输出</p><p>表示删除第 k个插入的数后面的数（当 k 为 0 时，表示删除头结点），当k=2的时候，删除x</p><p>链表为:z-&gt;y-&gt;x，所以删除第2个插入的数后面的数就是删除x；本质就是删除链表中的第三个元素；</p><ul><li><input disabled="" type="checkbox"> 这个是不是静态链表的弊端，不好实现按照直接删除第k个元素，或者是删除value = x的元素？</li></ul><table><thead><tr><th>数组下标</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>value[N]</td><td>x</td><td>y</td><td>z</td></tr><tr><td>pointer[N]</td><td>-1</td><td>1</td><td>2</td></tr><tr><td>将k-1的指针赋值给k</td><td>-1</td><td>-1</td><td>2</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//删除第k个插入的元素</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>  pointer[k] = pointer[pointer[k]];<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>6、插入元素</p><p>链表的插入主要要保证不断链。</p><p>表示在第 k个插入的数后面插入一个数 x（此操作中 k 均大于 0）</p><p>z-&gt;y-&gt;x-&gt;NULL，在第二个插入的数y后面插入x，链表变为z-&gt;y-&gt;x-&gt;x-&gt;NULL</p><table><thead><tr><th>Array</th><th>1</th><th>2</th><th>H:3</th><th>4</th><th></th></tr></thead><tbody><tr><td>value[N]</td><td>x</td><td>y</td><td>z</td><td>x</td><td></td></tr><tr><td>pointer[N]</td><td>-1</td><td>4</td><td>2</td><td>1</td><td></td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>  value[avil] = x;<br>  pointer[avil] = pointer[k];<br>  pointer[k] = avil;<br>  avil++;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>7、输出链表</p><p>输出链表主要是靠头指针的标识，从头指针开始遍历，找好对应关系，index = pointer[i]的数值是value[i]的下标</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">out_List</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">for</span>(i = head;i!=<span class="hljs-number">-1</span>;i = pointer[i]<span class="hljs-built_in">cout</span> &lt;&lt; value[i]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;)<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-19-023554.png" alt="image-20210319103554334" style="zoom:50%;" /><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-19-023615.png" alt="image-20210319103615345" style="zoom:50%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> elem[M],List[M];<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> head,avil;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head = <span class="hljs-number">0</span>;<br>    avil = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Head</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    elem[avil] = x;<br>    List[avil] = head;<br>    head = avil;<br>    avil ++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    elem[avil] = x;<br>    List[avil] = List[k];<br>    List[k] = avil;<br>    avil ++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    List[k] = List[List[k]];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Init();<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;m);<br>    <span class="hljs-keyword">char</span> op;<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> x,k;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; op;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;H&#x27;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>            Head(x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;I&#x27;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt;k &gt;&gt; x;<br>            Insert(k,x);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; k;<br>            <span class="hljs-keyword">if</span>(!k)  head = List[head];  <span class="hljs-comment">//这里不是很清楚，头结点的作用是什么？为了遍历？</span><br>            Delete(k);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i= head;i!=<span class="hljs-number">0</span>;i=List[i])     <span class="hljs-built_in">cout</span> &lt;&lt; elem[i]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure></blockquote><h4 id="2｜双链表"><a href="#2｜双链表" class="headerlink" title="2｜双链表"></a>2｜双链表</h4><h5 id="1｜双链表的性质"><a href="#1｜双链表的性质" class="headerlink" title="1｜双链表的性质"></a>1｜双链表的性质</h5><blockquote><p>双链表给定一个结点node，可以通过该结点的left和right指针可以找到node-1和node+1结点。</p></blockquote><h5 id="2｜双链表的构造"><a href="#2｜双链表的构造" class="headerlink" title="2｜双链表的构造"></a>2｜双链表的构造</h5><blockquote><p>通过三个数组进行构造，node结点的left[N]表示的是node-1的下标，right[N]表示的是node+1的下标。</p><p>边界判断：</p><ul><li>当链表中没有结点的时候</li><li>当链表中只有一个结点的时候</li></ul></blockquote><blockquote><p>1、双链表的数据成员：</p><p>1｜数据规模的大小为N</p><p>2｜存储链表中值的数组$value[N]$</p><p>3｜记录结点node的前后元素的指针数组$left[N]$    $right[N]$,数组中存储的值是对应node的数组的下标。</p><p>4｜avil表示下一个可用的数组空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e56</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> value[N],left[N],right[N],avil;<br></code></pre></td></tr></table></figure><p>使用数组的0号元素和1号元素记录数组的头结点和尾结点，在头结点和尾结点中插入链表的元素。</p><p>$Head -&gt; Tail$        //初始化链表</p><p>$Head -&gt; x -&gt; Tail$     //插入元素x</p><table><thead><tr><th>下标</th><th>0｜H</th><th>1｜T</th><th>2</th></tr></thead><tbody><tr><td>value</td><td>Head</td><td>Tail</td><td>x</td></tr><tr><td>left</td><td>1</td><td>2</td><td>0</td></tr><tr><td>right</td><td>2</td><td>0</td><td>1</td></tr><tr><td>avil</td><td>2</td><td>2</td><td>3</td></tr></tbody></table></blockquote><blockquote><p>2、初始化</p><p>1｜取0号元素为头结点、1号元素为尾结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  right[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>  left[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  avil = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>3、插入元素：左插入、右插入</p><p>$Head -&gt; x -&gt; Tail$     //插入元素x</p><blockquote><p>右插法<code>（在下标为k的点的右侧插入z）</code></p><p>avil = 3；</p><p>$Head -&gt;x -&gt; y -&gt; Tail$     //在y的右边插入z,此时不考虑边界条件,k = 2;</p><p>$Head -&gt;x -&gt; y -&gt; z -&gt; Tail$     </p><ul><li><input disabled="" type="checkbox"> 写一个debug工具，可以可视化的按照表格的形式输出各个值，类似excel的数据透视表的功能。</li></ul><table><thead><tr><th>下标</th><th>0｜H</th><th>1｜T</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>value</td><td>Head</td><td>Tail</td><td>x</td><td>y</td><td>z</td></tr><tr><td>left</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>right</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>avil</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>保证不断链<code>（链表操作的关键）</code></p><p>1｜要先设置插入元素的指针</p><p>2｜在断链后修改原有指针；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert_Right</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> z)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//先保证插入元素的指针，也就是z的指针的指向。</span><br>value[avil] = z;<br>  right[avil] = right[k];<br>  left[avil] = k;<br>  <span class="hljs-comment">//断链,注意断链的顺序，因为要使用right[k]的值，所以要先保证right[k]的值没有改变前调用。</span><br>  <span class="hljs-comment">//难点其实在于找前指针和后指针的表达式，找到之后保证不断链的前提下，修改链。</span><br>  left[right[k]] = avil;<br>  right[k] = avil;<br>  avil++;<br>&#125; <br></code></pre></td></tr></table></figure></blockquote><blockquote><p>左插法<code>（在下标为k的点的左侧插入z）</code></p><p>avil = 3；</p><p>$Head -&gt;x -&gt; z-&gt; y -&gt;Tail$     //在y的左边插入z,此时不考虑边界条件,k = 2;</p><p>保证不断链的条件和右插一样，但是指针不同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert_Left</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> z)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//先赋值</span><br>  value[avil] = z;<br>  left[avil] = left[k];<br>  right[avil] = k;<br>  <span class="hljs-comment">//断链</span><br>  right[left[k]] = avil;<br>  left[k] = avil;<br>  avil++;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></blockquote><blockquote><p>4、删除操作<code>删除第k个点</code></p><p>$Head -&gt;x -&gt; y -&gt; z -&gt; Tail$  //删除z，那么就是删除第3个点，数组的话是删除avil = k+1的点，因为插入是从avil = 2开始操作的；删除也存在保证不断链的要求。</p><p>也就是修改前一个元素的右链和后一个元素的左链；</p><p>前一个元素的右链：right[left[k+1]]</p><p>后一个元素的左链：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>  right[left[k+<span class="hljs-number">1</span>]] = right[k+<span class="hljs-number">1</span>];<br>  left[right[k+<span class="hljs-number">1</span>]] = left[k+<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>5、输出（从头结点开始输出，到尾结点结束）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Input_List</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i!=<span class="hljs-number">1</span>;i=left[i])<span class="hljs-built_in">cout</span> &lt;&lt; value[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><ul><li><input disabled="" type="checkbox"> 未完成</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> value[N],_left[N],_right[N];<br><span class="hljs-keyword">int</span> M,avil;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    _right[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    _left[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    avil = <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">//实现头插</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Head</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    value[avil] = x;<br>    _right[avil] = _right[<span class="hljs-number">0</span>];<br>    _left[avil] = <span class="hljs-number">0</span>;<br>    _left[_right[<span class="hljs-number">0</span>]] = avil;<br>    _right[<span class="hljs-number">0</span>] = avil;<br>    avil++;<br>&#125;<br><span class="hljs-comment">//实现尾插</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Tail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    value[avil] = x;<br>    _right[avil] = <span class="hljs-number">1</span>;<br>    _left[avil] = _left[<span class="hljs-number">1</span>];<br>    _right[_left[<span class="hljs-number">1</span>]] = avil;<br>    _left[<span class="hljs-number">1</span>] = avil;<br>    avil++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Inster_Left</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    value[avil] = x;<br>    _left[avil] = _right[k];<br>    _right[avil] = k;<br>    _left[_right[k]] = avil;<br>    _right[k] = avil;<br>    avil ++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert_Right</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    value[avil] = x;<br>    _right[avil] = _left[k];<br>    _left[avil] = k;<br>    _left[_right[k]] = avil;<br>    _right[k] = avil;<br>    avil++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    _left[_right[k]] = _left[k];<br>    _right[_left[k]] = _right[k];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output_List</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i!= <span class="hljs-number">1</span>;i = _right[i])   <span class="hljs-built_in">cout</span> &lt;&lt; value[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;M);<br>    Init();<br>    <span class="hljs-built_in">string</span> op;<br>    <span class="hljs-keyword">int</span> k,x;<br>    <span class="hljs-keyword">while</span>(M--)<br>    &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; op;<br>        <span class="hljs-keyword">if</span>( op == <span class="hljs-string">&quot;R&quot;</span>)  <br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>            Head(x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( op == <span class="hljs-string">&quot;L&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>            Tail(x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( op == <span class="hljs-string">&quot;D&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; k;<br>            Delete(k+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;IL&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; k &gt;&gt; x;<br>            Inster_Left(k,x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( op == <span class="hljs-string">&quot;IR&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; k &gt;&gt; x;<br>            Insert_Right(k,x);<br>        &#125;<br>    &#125;<br>    output_List();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3｜栈"><a href="#3｜栈" class="headerlink" title="3｜栈"></a>3｜栈</h4><h5 id="1｜栈的性质"><a href="#1｜栈的性质" class="headerlink" title="1｜栈的性质"></a>1｜栈的性质</h5><blockquote><p>1、先进后出，所以适用于记录什么样的数据？</p><p>1｜优先处理新加入的数据</p><p>2、栈的操作：初始化、进栈、出栈、判空、判满</p></blockquote><h5 id="2｜栈的实现"><a href="#2｜栈的实现" class="headerlink" title="2｜栈的实现"></a>2｜栈的实现</h5><blockquote><p>1、栈的数据组成：栈分为两种，一种是链栈（利用指针实现），另一种是顺序栈（利用数组实现）</p><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-21-011946.jpg" alt="img"></p><p>在算法实现中，大多是利用顺序栈来实现，一般在算法做题中，栈是作为一种中间的工具实现一些功能。</p><ul><li><input disabled="" type="checkbox"> 所以注意栈用于哪些场景，要总结。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<span class="hljs-comment">//栈内最大的容量为1e6</span><br><span class="hljs-keyword">int</span> Stack[N];<span class="hljs-comment">//顺序栈</span><br><span class="hljs-keyword">int</span> top;<span class="hljs-comment">//栈顶指针，因为栈先进栈的指针并不能进行操作，只能操作后进栈的指针，所以只需要栈顶指针即可。</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>2、栈的初始化（先不考虑边界条件）</p><p>初始化只要对top指针进行初始化，初始化方式有两种<code>top = -1</code>或是<code>top = 0</code>，会导致判空与判满的条件不同。</p><p><code>top = -1 </code>:那么栈的元素与数组下标一致，</p><p><code>top = 0</code>：栈的元素的顺序与插入的顺序一致</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  top = <span class="hljs-number">0</span>;<span class="hljs-comment">//个人喜好</span><br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>3、进栈(未考虑边界条件)</p><p>top相当于栈顶的一个指针，标记栈顶，所以进栈和出栈都是对top进行操作；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//未优化代码</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>  top ++;<span class="hljs-comment">//top标记栈顶，所以先为插入元素找到下一个插入的空间，也就是进行top++；</span><br>  Stack[top] = x;<span class="hljs-comment">//找到空间后，对空间进行赋值,所以就是先++，后赋值</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//优化代码</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>  Stack[++top] = x;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>4、出栈（未考虑边界条件）</p><p>top指向栈顶，要出栈只需要挪动栈顶指针即可，如果要输出栈顶元素，要先输出后挪动top指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//优化代码</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Pop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> x;<br>  x = Stack[top --];<span class="hljs-comment">//先赋值，再--</span><br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>5、获取栈顶元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getTop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> Stack[top];<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>6、判空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Empty</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> (top == <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>7、判满</p><p>一半的算法题中貌似不会判满</p></blockquote><h5 id="4｜栈的应用"><a href="#4｜栈的应用" class="headerlink" title="4｜栈的应用"></a>4｜栈的应用</h5><blockquote><p>一般来说很多问题，栈都作为辅助的工具，而不能够直接解题。</p><p>将栈作为存储的工具，然后根据栈的性质，输出结果</p></blockquote><blockquote><p>括号匹配</p><p>左括号与之相邻的最近的右括号匹配</p></blockquote><blockquote><p>栈思想的应用：</p><p>利用栈的出栈和入栈思想，这个题是对出栈入栈的条件进行了限制，遇到’(‘相当于入栈，遇到’)’，相当于出栈；因为要去掉最外层的（），所以栈底保留一个元素，也就是要求top &gt; 1；</p><p><a href="https://leetcode-cn.com/problems/remove-outermost-parentheses/">https://leetcode-cn.com/problems/remove-outermost-parentheses/</a></p><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-21-083054.png" alt="image-20210321163054142"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">removeOuterParentheses</span><span class="hljs-params">(<span class="hljs-built_in">string</span> S)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> top = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">string</span> ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;S.length();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(S[i] == <span class="hljs-string">&#x27;(&#x27;</span>) <br>            &#123;<br>                top ++;<br>                <span class="hljs-keyword">if</span>(top &gt;<span class="hljs-number">1</span>)    ans += <span class="hljs-string">&#x27;(&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(top &gt; <span class="hljs-number">1</span>)     ans += <span class="hljs-string">&#x27;)&#x27;</span>;<br>                top --;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></blockquote><h4 id="4｜队列"><a href="#4｜队列" class="headerlink" title="4｜队列"></a>4｜队列</h4><h5 id="1｜队列的性质"><a href="#1｜队列的性质" class="headerlink" title="1｜队列的性质"></a>1｜队列的性质</h5><blockquote><p> 只允许一端输入，另一端输出，允许输出是队头，允许输入是队尾，先进先出（FIFO）。</p></blockquote><h5 id="2｜队列实现（数组）"><a href="#2｜队列实现（数组）" class="headerlink" title="2｜队列实现（数组）"></a>2｜队列实现（数组）</h5><p><code>未进行边界条件判断</code></p><blockquote><p>1、数据成员</p><p>因为输入和输出操作的是不同的位置，所以需要双指针来进行操作，设置队头指针为front，队尾指针为rear</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxSize <span class="hljs-number">1e6</span>+!<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> SeqQueue[maxSize];<br><span class="hljs-keyword">int</span> front,rear;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>2、初始化队列</p><p>初始化时队列中没有元素，所以front = rear = 0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  front = rear = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>3、插入元素(入队)</p><p>插入元素只需操作队尾指针，指针rear的含义是下一个可以插入的位置，并不是指向真正的队尾。所以应该是rear ++ ，而不是++rear；这个操作和front = rear = 0 的初始化方式有关。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>  SeqQueue(rear++) = x;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>4、出队</p><p>出队因为只能在队头出队，所以只需要操作队头指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  front ++ ;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>5、判空</p><p>判空的条件就是当队头和队尾相同的时候</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Empty</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> (front == rear);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>6、取出队头元素</p><p>操作front指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getFront</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> SeqQueue[front];<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote> <img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-22-001421.png" alt="image-20210322081421032" style="zoom:50%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxSize = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> M,que[maxSize];<br><span class="hljs-built_in">string</span> op;<br><span class="hljs-keyword">int</span> x,front,rear;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    front = rear = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    que[rear++] = x;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    front ++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">query</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cout</span> &lt;&lt;  que[front] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(front == rear)   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">else</span>                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;M);<br>    Init();<br>    <span class="hljs-keyword">while</span>(M--)<br>    &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; op;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;push&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>            push(x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;pop&quot;</span>)    pop();<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;query&quot;</span>)  query();<br>        <span class="hljs-keyword">else</span>                    empty();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Sorting</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法导论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP/IP-简介</title>
    <link href="/2021/03/01/9-408-TCP-IP/"/>
    <url>/2021/03/01/9-408-TCP-IP/</url>
    
    <content type="html"><![CDATA[<h3 id="一、TCP-IP-简介"><a href="#一、TCP-IP-简介" class="headerlink" title="一、TCP IP 简介"></a>一、TCP IP 简介</h3><p><code>实验环境：Linux-Ubuntu20.04｜Mac</code></p><h4 id="1｜应用模型"><a href="#1｜应用模型" class="headerlink" title="1｜应用模型"></a>1｜应用模型</h4><h4 id="2｜知识点"><a href="#2｜知识点" class="headerlink" title="2｜知识点"></a>2｜知识点</h4><h5 id="1｜IP地址"><a href="#1｜IP地址" class="headerlink" title="1｜IP地址"></a>1｜IP地址</h5><h5 id="2｜域名"><a href="#2｜域名" class="headerlink" title="2｜域名"></a>2｜域名</h5><h5 id="3｜MAC地址"><a href="#3｜MAC地址" class="headerlink" title="3｜MAC地址"></a>3｜MAC地址</h5><h5 id="4｜端口号"><a href="#4｜端口号" class="headerlink" title="4｜端口号"></a>4｜端口号</h5><blockquote><p>端口号作用：</p></blockquote><blockquote><p>常用端口号：</p></blockquote><blockquote><p>端口号实际应用：</p></blockquote><h5 id="5｜封装与分用"><a href="#5｜封装与分用" class="headerlink" title="5｜封装与分用"></a>5｜封装与分用</h5><h5 id="6｜Linux网络相关常用命令"><a href="#6｜Linux网络相关常用命令" class="headerlink" title="6｜Linux网络相关常用命令"></a>6｜Linux网络相关常用命令</h5><p><code>借助netstat命令行工具</code></p><h3 id="二、链路层"><a href="#二、链路层" class="headerlink" title="二、链路层"></a>二、链路层</h3><h4 id="1｜链路层简介"><a href="#1｜链路层简介" class="headerlink" title="1｜链路层简介"></a>1｜链路层简介</h4><p><code>知识点：控制帧的传输、以太网、PPP、SLIP与PPP、MTU</code></p><blockquote><p>以太网<code>CSMA/CD</code></p></blockquote><blockquote><p>MTU</p></blockquote><blockquote><p>PPP</p></blockquote><blockquote><p>SLIP</p></blockquote><h4 id="2｜链路层实现功能以及链路层协议"><a href="#2｜链路层实现功能以及链路层协议" class="headerlink" title="2｜链路层实现功能以及链路层协议"></a>2｜链路层实现功能以及链路层协议</h4><h5 id="1｜差错控制"><a href="#1｜差错控制" class="headerlink" title="1｜差错控制"></a>1｜差错控制</h5><h5 id="2｜反馈重发"><a href="#2｜反馈重发" class="headerlink" title="2｜反馈重发"></a>2｜反馈重发</h5><h5 id="3｜计时器"><a href="#3｜计时器" class="headerlink" title="3｜计时器"></a>3｜计时器</h5><h5 id="4｜序号"><a href="#4｜序号" class="headerlink" title="4｜序号"></a>4｜序号</h5><h5 id="5｜流量控制"><a href="#5｜流量控制" class="headerlink" title="5｜流量控制"></a>5｜流量控制</h5><h3 id="三、网络层"><a href="#三、网络层" class="headerlink" title="三、网络层"></a>三、网络层</h3><h4 id="1｜IP数据报"><a href="#1｜IP数据报" class="headerlink" title="1｜IP数据报"></a>1｜IP数据报</h4><h4 id="2｜地址划分"><a href="#2｜地址划分" class="headerlink" title="2｜地址划分"></a>2｜地址划分</h4><h4 id="3｜子网划分"><a href="#3｜子网划分" class="headerlink" title="3｜子网划分"></a>3｜子网划分</h4><h5 id="1｜子网掩码：netmask："><a href="#1｜子网掩码：netmask：" class="headerlink" title="1｜子网掩码：netmask："></a>1｜子网掩码：netmask：</h5><h4 id="4｜IP路由选择"><a href="#4｜IP路由选择" class="headerlink" title="4｜IP路由选择"></a>4｜IP路由选择</h4><h4 id="5｜NAT技术"><a href="#5｜NAT技术" class="headerlink" title="5｜NAT技术"></a>5｜NAT技术</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ifconfig eth0<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">en0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=400&lt;CHANNEL_IO&gt;<br>ether 38:f9:d3:93:33:9f<br>inet 192.168.3.12 netmask 0xffffff00 broadcast 192.168.3.255<br>media: autoselect<br>status: active<br></code></pre></td></tr></table></figure><blockquote><p>内网IP(192.168.X.X和172.16.X.X)          <code>私网地址</code></p><p>内网与外网的区别？</p><p>广播地址怎么用？</p></blockquote><h4 id="6｜IP的发展及未来"><a href="#6｜IP的发展及未来" class="headerlink" title="6｜IP的发展及未来"></a>6｜IP的发展及未来</h4><blockquote><p>IPV6</p></blockquote><h4 id="7｜网络层协议"><a href="#7｜网络层协议" class="headerlink" title="7｜网络层协议"></a>7｜网络层协议</h4><p><code>ARP|RARP|ICMP|ping|traceroute|IGMP</code></p><h5 id="1｜ARP协议"><a href="#1｜ARP协议" class="headerlink" title="1｜ARP协议"></a>1｜ARP协议</h5><blockquote><p>协议工作原理：</p></blockquote><blockquote><p>ARP代理</p></blockquote><blockquote><p>ARP欺骗</p></blockquote><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">arp<br><br></code></pre></td></tr></table></figure></blockquote><h5 id="2｜icmp协议"><a href="#2｜icmp协议" class="headerlink" title="2｜icmp协议"></a>2｜icmp协议</h5><blockquote><p>协议的工作原理：</p></blockquote><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ping<br></code></pre></td></tr></table></figure><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-17-002443.png" alt="image-20210317082443464" style="zoom:50%;" /><p>ping是什么原理？</p></blockquote><h4 id="7｜实践"><a href="#7｜实践" class="headerlink" title="7｜实践"></a>7｜实践</h4><h5 id="1｜ifconfig命令详解"><a href="#1｜ifconfig命令详解" class="headerlink" title="1｜ifconfig命令详解"></a>1｜ifconfig命令详解</h5><ul><li><input disabled="" type="checkbox"> 搞清楚每一个的含义是什么，分别在网络层有什么用</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs bash">lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384<br>options=1203&lt;RXCSUM,TXCSUM,TXSTATUS,SW_TIMESTAMP&gt;<br>inet 127.0.0.1 netmask 0xff000000<br>inet6 ::1 prefixlen 128<br>inet6 fe80::1%lo0 prefixlen 64 scopeid 0x1<br>nd6 options=201&lt;PERFORMNUD,DAD&gt;<br>gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280<br>stf0: flags=0&lt;&gt; mtu 1280<br>en6: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500<br>ether ac:de:48:00:11:22<br>inet6 fe80::aede:48ff:fe00:1122%en6 prefixlen 64 scopeid 0x4<br>nd6 options=201&lt;PERFORMNUD,DAD&gt;<br>media: autoselect (100baseTX &lt;full-duplex&gt;)<br>status: active<br>ap1: flags=8802&lt;BROADCAST,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=400&lt;CHANNEL_IO&gt;<br>ether 3a:f9:d3:93:33:9f<br>media: autoselect<br>status: inactive<br>en0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=400&lt;CHANNEL_IO&gt;<br>ether 38:f9:d3:93:33:9f<br>inet 192.168.3.12 netmask 0xffffff00 broadcast 192.168.3.255<br>media: autoselect<br>status: active<br>awdl0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=400&lt;CHANNEL_IO&gt;<br>ether 3e:73:6e:0b:bb:ac<br>inet6 fe80::3c73:6eff:fe0b:bbac%awdl0 prefixlen 64 scopeid 0x7<br>nd6 options=201&lt;PERFORMNUD,DAD&gt;<br>media: autoselect<br>status: active<br>llw0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=400&lt;CHANNEL_IO&gt;<br>ether 3e:73:6e:0b:bb:ac<br>inet6 fe80::3c73:6eff:fe0b:bbac%llw0 prefixlen 64 scopeid 0x8<br>nd6 options=201&lt;PERFORMNUD,DAD&gt;<br>media: autoselect<br>status: active<br>en3: flags=8963&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=460&lt;TSO4,TSO6,CHANNEL_IO&gt;<br>ether 82:23:4a:a0:88:05<br>media: autoselect &lt;full-duplex&gt;<br>status: inactive<br>en4: flags=8963&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=460&lt;TSO4,TSO6,CHANNEL_IO&gt;<br>ether 82:23:4a:a0:88:04<br>media: autoselect &lt;full-duplex&gt;<br>status: inactive<br>en2: flags=8963&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=460&lt;TSO4,TSO6,CHANNEL_IO&gt;<br>ether 82:23:4a:a0:88:00<br>media: autoselect &lt;full-duplex&gt;<br>status: inactive<br>en1: flags=8963&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=460&lt;TSO4,TSO6,CHANNEL_IO&gt;<br>ether 82:23:4a:a0:88:01<br>media: autoselect &lt;full-duplex&gt;<br>status: inactive<br>en5: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=6467&lt;RXCSUM,TXCSUM,VLAN_MTU,TSO4,TSO6,CHANNEL_IO,PARTIAL_CSUM,ZEROINVERT_CSUM&gt;<br>ether 00:e0:4c:68:01:5a<br>nd6 options=201&lt;PERFORMNUD,DAD&gt;<br>media: autoselect (none)<br>status: inactive<br>bridge0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=63&lt;RXCSUM,TXCSUM,TSO4,TSO6&gt;<br>ether 82:23:4a:a0:88:01<br>Configuration:<br>id 0:0:0:0:0:0 priority 0 hellotime 0 fwddelay 0<br>maxage 0 holdcnt 0 proto stp maxaddr 100 timeout 1200<br>root id 0:0:0:0:0:0 priority 0 ifcost 0 port 0<br>ipfilter disabled flags 0x0<br>member: en1 flags=3&lt;LEARNING,DISCOVER&gt;<br>        ifmaxaddr 0 port 12 priority 0 path cost 0<br>member: en2 flags=3&lt;LEARNING,DISCOVER&gt;<br>        ifmaxaddr 0 port 11 priority 0 path cost 0<br>member: en3 flags=3&lt;LEARNING,DISCOVER&gt;<br>        ifmaxaddr 0 port 9 priority 0 path cost 0<br>member: en4 flags=3&lt;LEARNING,DISCOVER&gt;<br>        ifmaxaddr 0 port 10 priority 0 path cost 0<br>nd6 options=201&lt;PERFORMNUD,DAD&gt;<br>media: &lt;unknown <span class="hljs-built_in">type</span>&gt;<br>status: inactive<br>utun0: flags=8051&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu 1380<br>inet6 fe80::cdc3:569c:b8e5:27cd%utun0 prefixlen 64 scopeid 0xf<br>nd6 options=201&lt;PERFORMNUD,DAD&gt;<br>utun1: flags=8051&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu 2000<br>inet6 fe80::b3d5:d5dc:d9d:f593%utun1 prefixlen 64 scopeid 0x10<br>nd6 options=201&lt;PERFORMNUD,DAD&gt;<br></code></pre></td></tr></table></figure><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br></code></pre></td></tr></table></figure></blockquote><h5 id="2｜tcpdump抓包"><a href="#2｜tcpdump抓包" class="headerlink" title="2｜tcpdump抓包"></a>2｜tcpdump抓包</h5><blockquote><p>IP数据报(20B)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo tcpdump -nx -c 2<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tcpdump: verbose output suppressed, use -v[v]... <span class="hljs-keyword">for</span> full protocol decode<br>listening on en0, link-type EN10MB (Ethernet), snapshot length 262144 bytes<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">10:25:09.140340 <br>IP 120.232.214.205.22004 &gt; 192.168.3.12.53969: Flags [.], <br>ack 885193681, win 21, length 0<br>0x0000:  4504 0028 5eb6 4000 3606 d2ab 78e8 d6cd<br>0x0010:  c0a8 030c 55f4 d2d1 b856 3706 34c2 fbd1<br>0x0020:  5010 0015 539e 0000 0000 0000 0000<br></code></pre></td></tr></table></figure><blockquote><p>首部分析：</p><p>版本协议：0x4</p><p>首部长度：0x5</p><p>服务类型：04</p><p>总长度：0028</p><p>标识：5eb6</p><p>标志与片偏移：4000</p><p>生存时间：36</p><p>协议：06</p><p>首部校验和：d2ab</p><p><code> 源地址</code>78e8 d6cd</p><p>转化为二进制：01111000｜11101000｜11010110｜11001101</p><p>转化为点分十进制：</p><p><code>目的地址</code>c0a8 030c </p><p>转换为二进制：11000000｜10101000｜00000011｜00001100</p><p>转化为点分十进制：192.168.3.12<code>与192.168.3.12.53969可以对应</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">10:25:09.140420 <br>IP 192.168.3.12.53969 &gt; 120.232.214.205.22004: Flags [.], <br>ack 1, win 4096, length 0<br>0x0000:  4500 0028 0000 4000 4006 2766 c0a8 030c<br>0x0010:  78e8 d6cd d2d1 55f4 34c2 fbd1 b856 3707<br>0x0020:  5010 1000 43b2 0000<br></code></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 怎么样了解这些输出是什么</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">traceroute www.baidu.com<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"> 1  192.168.3.1 (192.168.3.1)  3.086 ms  2.898 ms  1.976 ms<br> 2  192.168.1.1 (192.168.1.1)  2.303 ms  2.396 ms  3.538 ms<br> 3  10.139.0.1 (10.139.0.1)  9.640 ms  8.780 ms  7.852 ms<br> 4  111.56.2.185 (111.56.2.185)  10.049 ms  10.867 ms  9.565 ms<br> 5  221.183.58.205 (221.183.58.205)  12.810 ms<br>    221.183.75.49 (221.183.75.49)  13.646 ms<br>    221.183.58.205 (221.183.58.205)  15.570 ms<br> 6  221.183.37.193 (221.183.37.193)  25.510 ms<br>    221.183.40.21 (221.183.40.21)  29.624 ms<br>    221.183.37.193 (221.183.37.193)  24.770 ms<br> 7  * * 221.183.49.130 (221.183.49.130)  33.833 ms<br> 8  39.156.27.5 (39.156.27.5)  23.339 ms * *<br> 9  39.156.67.73 (39.156.67.73)  35.292 ms<br>    39.156.27.1 (39.156.27.1)  33.018 ms<br>    39.156.67.53 (39.156.67.53)  28.759 ms<br>10  * * 39.156.67.81 (39.156.67.81)  38.491 ms<br>11  * * *<br></code></pre></td></tr></table></figure><blockquote><p>解析：</p><p>每一个序号代表的是一跳，每跳表示一个网关</p><ul><li><input disabled="" type="checkbox"> 网关没有理解是什么东西？就代表的是路由器？</li></ul><p>每一跳后面的三个时间：代表的是探测数据包向每个网关发送三个数据包后，网关响应后的返回时间</p><p>使用的是华为的路由器，所以192.168.3.1表示的是华为路由器的地址，</p><p>192.168.1.1</p><p><code>192.168.1.1 IP地址是大多数无线路由器或ADSL调制解调器的默认网关。路由器可以使用多个IP主地址</code></p></blockquote><h5 id="3｜netstat-使用"><a href="#3｜netstat-使用" class="headerlink" title="3｜netstat 使用"></a>3｜netstat 使用</h5><blockquote><p>1、使用netstat查询路由信息</p><p>Destination:</p><p>Gateway:</p><p>Flags:</p><p>Netif:</p><p>Expire:</p></blockquote><h5 id="4｜traceroute命令"><a href="#4｜traceroute命令" class="headerlink" title="4｜traceroute命令"></a>4｜traceroute命令</h5><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><h4 id="TCP服务"><a href="#TCP服务" class="headerlink" title="TCP服务"></a>TCP服务</h4><p><code>面向连接服务｜可靠数据传输服务｜拥塞控制机制</code></p><blockquote><p>面向连接的服务：</p><p>1、应用层数据报文开始流动之前，TCP让客户和服务器下相互交换<code>运输层控制信息</code>，即所谓经典的三次握手和四次挥手。握手是为了在两个进程的套接字之间建立TCP连接。</p><p>可靠的数据传输：</p><p>1、无差错</p><p>2、按照适当顺序交付所有发送的数据</p><p>3、保证传输的字节没有丢失或者是冗余</p><p>拥塞控制</p></blockquote><blockquote><p>TCP安全</p><p>为了保证隐私和其他的安全问题，可以使用TCP加强版即SSL（安全套接字层），除了TCP的经典服务以外，利用SSL可以提供关键的进程到进程的安全性服务。</p><p>SSL已经有高度优化的库和类，调用SSL API即可实现加密等服务。</p><p>当一个应用使用SSL时，发送进程想SSL的套接字传递明文数据，在主机中的SSL则加密该数据并将加密的数据传递给TCP套接字。</p><p><code>char ==&gt; SSL(API) ==&gt; TCP SOCKET</code></p></blockquote><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><blockquote><p>UDP不提供不必要的轻量级运输协议，<code>UDP是无连接的</code>而且<code>UDP提供不可靠的数据传输服务</code>，同时也没有拥塞控制机制。</p></blockquote><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p><code>2021-3-18</code>                                                            </p><p><code>DNS|FTP|Telnet|SMTP|HTTP|RIP|NFS</code></p><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-18-014102.png" alt="image-20210318094059472"></p><h4 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h4><blockquote><p>应用层协议定义了以下的几样东西：</p><p>1、交换的报文类型：如请求报文和响应报文</p><p>2、各类报文类型的语法：报文中各个字段以及各个字段如何描述</p><p>3、字段的语义：每个字段中包含的信息的含义</p><p>4、一个进程何时以及如何发送报文，对报文进行响应的规则</p><p>应用层协议有的是公开的，有的是专用的，如果你想构建一个web浏览器的应用程序，你就要在参照HTTP RFC规则，这样你写出来的浏览器可以访问遵从该文档标准的web服务器，并获取相应的web页面。</p><ul><li><input disabled="" type="checkbox"> 尝试读取HTTP RFC规则</li><li><input disabled="" type="checkbox"> 所以这就是学会如何使用轮子</li></ul></blockquote><blockquote><p>区分网络应用和应用层协议：</p><p>应用层协议只是网络应用的一部分，但是是很重要的一部分。网络应用包含多个功能，参照浏览器的功能，不仅仅是能够访问web页面一个功能。</p></blockquote><h4 id="Web和HTTP"><a href="#Web和HTTP" class="headerlink" title="Web和HTTP"></a>Web和HTTP</h4><h5 id="1｜HTTP概况"><a href="#1｜HTTP概况" class="headerlink" title="1｜HTTP概况"></a>1｜HTTP概况</h5><p><code>HTTP:超文本传输协议（HyperText Transfer Protocol</code></p><blockquote><p>1、HTTP由两个程序实现：一个是<code>客户程序</code>，一个是<code>服务器程序</code>。这两个程序运行在不同的端系统中，通过交换HTTP报文进行会话。HTTP协议定义了这些报文的结构以及客户和服务器进行报文交换的方式。</p><p><code>python网络爬虫就是对HTTP报文进行操作的一个实际的例子</code></p></blockquote><blockquote><p>2、Web页面</p><p>Web页面由对象组成，一个对象可以是HTML文件、图片、视频或者是一个小程序。他们通过一个URL地址寻址，图示为页面中的对象</p><p><code>URL地址的构成</code></p><p>http<code>协议名</code>://<a href="http://www.someschool.edu`主机名`/someDepartment/picture.gif%60%E8%AE%BF%E9%97%AE%E7%9A%84%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E5%90%8D%60">www.someSchool.edu`主机名`/someDepartment/picture.gif`访问的文件路径名`</a></p><p><code>python爬虫中对于页面的解析</code></p><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-18-020234.png" alt="image-20210318100234461"></p><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-18-020303.png" alt="image-20210318100302919"></p></blockquote><blockquote><p>3、Web服务器</p><p>实现了HTTP的服务器端，用于存储Web对象，每个对象由URL寻址，流行的Web服务器由Apache和Mic Server</p><blockquote><p>link：<a href="https://zhuanlan.zhihu.com/p/22544725">https://zhuanlan.zhihu.com/p/22544725</a></p></blockquote></blockquote><h5 id="2｜HTTP协议的功能"><a href="#2｜HTTP协议的功能" class="headerlink" title="2｜HTTP协议的功能"></a>2｜HTTP协议的功能</h5><blockquote><ul><li>定义了Web客户向Web服务器请求Web页面的方式</li><li>服务器向客户传送Web页面的方式</li><li></li></ul></blockquote><h5 id="3｜客户与服务器的交互过程"><a href="#3｜客户与服务器的交互过程" class="headerlink" title="3｜客户与服务器的交互过程"></a>3｜客户与服务器的交互过程</h5><h5 id="4｜HTTP协议的执行过程"><a href="#4｜HTTP协议的执行过程" class="headerlink" title="4｜HTTP协议的执行过程"></a>4｜HTTP协议的执行过程</h5><blockquote><p>1｜建立连接</p><blockquote><p>使用TCP作为支撑运输协议，端口号为80（默认端口号）</p><ul><li><input disabled="" type="checkbox"> 为什么不使用UDP？</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">1、TCP为HTTP提供可靠数据传输服务<br>2、客户进程发出的每个HTTP请求报文都能完整的到达服务器，同理服务器进程发出的每个HTTP响应也可以到达客户。<br></code></pre></td></tr></table></figure></blockquote><ul><li>HTTP 客户发起一个与服务器的TCP连接</li></ul><p>2｜建立连接后</p><blockquote><p>浏览器和服务器进程通过<code>套接字接口</code>访问<code>TCP</code>，一旦客户向它的<code>套接字接口</code>发送了一个请求报文，该报文就脱离了客户控制并进入TCP控制。（进入TCP以后就是由运输层负责）</p></blockquote></blockquote><h5 id="5｜HTTP协议的特性—P68"><a href="#5｜HTTP协议的特性—P68" class="headerlink" title="5｜HTTP协议的特性—P68"></a>5｜HTTP协议的特性—P68</h5><blockquote><p>1｜HTTP服务器并不保存关于客户的任何信息，所以HTTP是一个无状态协议。</p><p>2｜持续连接和非持续连接</p><blockquote><p>概念：</p><p>非持续连接：每个请求/响应都是经过一个单独的TCP连接发送</p><p>持续连接：所有的请求及其响应都经相同TCP连接发送</p></blockquote><blockquote><p>非持续连接：</p><p>HTTP客户进程在端口号80发起一个到服务器的TCP连接</p><p>HTTP客户经过它的套接字向该服务器发送一个HTTP请求报文。</p><p>HTTP服务器经服务器的套接字接收该请求报文，从存储器中检索出对象，在HTTP响应报文中封装对象，并通过其套接字向客户发送响应报文。‘</p><p>待TCP确认客户已经完成的收到响应报文，关闭TCP连接。</p><ul><li>每个TCP连接在服务器发送一个对象后关闭，即该连接部位其他的对象而持续下来。</li><li>如果是页面中包含一个HTML基本文件和10个JPEG图形的话，那么非持续连接要产生11个TCP连接。</li></ul><p>客户从响应报文中提取出HTML文件，得到对HTML文件中元素的引用，然后对每个引用重复前几步，得到完成的HTML文件</p></blockquote></blockquote><h5 id="6｜并行TCP连接和串行TCP连接"><a href="#6｜并行TCP连接和串行TCP连接" class="headerlink" title="6｜并行TCP连接和串行TCP连接"></a>6｜并行TCP连接和串行TCP连接</h5><blockquote><p>目前大部分浏览器都适用并行的TCP连接，就是浏览器打开5～10个并行的TCP连接，而且每条处理一个请求响应事物。</p></blockquote><h4 id="1｜DNS"><a href="#1｜DNS" class="headerlink" title="1｜DNS"></a>1｜DNS</h4><blockquote><p>DNS协议的作用：域名与ip地址之间通过DNS服务器实现相互转化。</p></blockquote><blockquote><p>DNS服务器：</p><p>根DNS服务器</p><p>顶级DNS服务器</p><p>权威DNS服务器</p><p>本地DNS服务器</p><ul><li><input disabled="" type="checkbox"> 为什么不能讲DNS服务器的内容存储在主机中，然后从主机调用，因为个人访问的网站比较少，并不是所有的网站都访问到。</li></ul></blockquote><blockquote><p>域名解析过程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">host + 域名<br></code></pre></td></tr></table></figure><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-17-003825.png" alt="image-20210317083820648"></p><p>返回的值就是域名对应的ip地址</p></blockquote><blockquote><p>DNS报文</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Base</category>
      
      <category>Experiment</category>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>408实验</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++[基础阶段刷题练习]</title>
    <link href="/2021/02/28/0-CPP-CodeWars/"/>
    <url>/2021/02/28/0-CPP-CodeWars/</url>
    
    <content type="html"><![CDATA[<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h4 id="1｜数值计算"><a href="#1｜数值计算" class="headerlink" title="1｜数值计算"></a>1｜数值计算</h4><blockquote><p>1、浮点数与整数的计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a=<span class="hljs-number">8</span>,b=<span class="hljs-number">10</span>;<br><span class="hljs-keyword">float</span> result;<br>result = a/b;<span class="hljs-comment">//输出还是int类型，输出结果为0</span><br>result = (<span class="hljs-keyword">float</span>) a / (<span class="hljs-keyword">float</span>) b;<span class="hljs-comment">//这个为想要的结果</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>2、数字字符串转换为数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">string</span> str;<br><span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; a;<br>getline(<span class="hljs-built_in">cin</span>,str);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;str.size();i++)a.push_back(str[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>3、判断是不是完全平方数</p><blockquote><p>sqrt(sq) 如果是完全</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;    </span></span><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findNextSquare</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> sq)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sqrt</span>(sq) != (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">sqrt</span>(sq))&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<br>  <span class="hljs-keyword">return</span>  <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">sqrt</span>(sq) + <span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="2｜字符串操作"><a href="#2｜字符串操作" class="headerlink" title="2｜字符串操作"></a>2｜字符串操作</h4><blockquote><p>字符串操作题目类型:</p><p>1、统计字符串中的数字个数、特殊字符个数以及字母个数</p></blockquote><blockquote><p>2、cin 和 fgets的区别</p><ul><li>声明为string使用cin输入</li><li>声明为char str[n]，使用fgets输入；如果声明为string使用fgets输入的话，会报错<code>不存在从 &quot;std::__1::string&quot; 到 &quot;char *&quot; 的适当转换函数C/C++(413)</code></li></ul></blockquote><blockquote><p>3、使用cin、getline等输入方法</p></blockquote><blockquote><p>4、字符串添加操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">string</span> str1,str2;<br><span class="hljs-keyword">int</span> len = str.size();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>  str2 += str1[i]+str1[(i+<span class="hljs-number">1</span>) % len]; <span class="hljs-comment">//字符串可以直接的添加操作，但是数组不可以</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>5、正则表达式</p><ul><li>检查一个字符串中是否包含某种形式的子串</li><li>将匹配的子串替换</li><li>从某个串中取出符合条件的子串</li><li><code>参考文件</code>：<a href="https://www.cnblogs.com/xiaofeiIDO/p/7892185.html">https://www.cnblogs.com/xiaofeiIDO/p/7892185.html</a></li></ul><p>正则表达式中主要在于是把握子串的形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">regex <span class="hljs-title">rx</span> <span class="hljs-params">(<span class="hljs-string">&quot;\\b&quot;</span> + sub + <span class="hljs-string">&quot;\\b&quot;</span>)</span></span>;    <span class="hljs-comment">//需要进行替换的子串</span><br><span class="hljs-built_in">string</span> ans = regex_replace(str,rx,rep);    <span class="hljs-comment">//将str中符合rx要求的子串替换为rep，保存到ans中</span><br><span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt;<span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure></blockquote><h4 id="3｜条件判断"><a href="#3｜条件判断" class="headerlink" title="3｜条件判断"></a>3｜条件判断</h4><blockquote><p>1、类型为bool类型的返回值</p><blockquote><p>// return xcount == oCount；直接返回判断值</p><p>// algorithm头文件中的count函数用于计数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">XO</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; str)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> xCount = <span class="hljs-built_in">std</span>::count(str.begin(), str.end(), <span class="hljs-string">&#x27;x&#x27;</span>) + <span class="hljs-built_in">std</span>::count(str.begin(), str.end(), <span class="hljs-string">&#x27;X&#x27;</span>);<br>  <span class="hljs-keyword">int</span> oCount = <span class="hljs-built_in">std</span>::count(str.begin(), str.end(), <span class="hljs-string">&#x27;o&#x27;</span>) + <span class="hljs-built_in">std</span>::count(str.begin(), str.end(), <span class="hljs-string">&#x27;O&#x27;</span>);<br>  <span class="hljs-keyword">return</span> xCount ==  oCount;<br>&#125;<br><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>2、条件判断中？ ： 的使用，主要用于简化代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">return</span> (num%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)?<span class="hljs-string">&quot;Even&quot;</span>:<span class="hljs-string">&quot;Odd&quot;</span>;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>3、</p></blockquote><h4 id="4｜头文件中的函数"><a href="#4｜头文件中的函数" class="headerlink" title="4｜头文件中的函数"></a>4｜头文件中的函数</h4><blockquote><p>1、判断最小值</p><blockquote><p>//algorithm头文件中有直接取出最小值的函数min_element</p><ul><li><input disabled="" type="checkbox"> cbegin和begin的区别是什么？</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findSmallest</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; xs)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> *<span class="hljs-built_in">std</span>::min_element(xs.cbegin(), xs.cend());<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="5｜宏定义"><a href="#5｜宏定义" class="headerlink" title="5｜宏定义"></a>5｜宏定义</h4><blockquote><p>1、宏定义的使用</p><blockquote><p>题目：一个greet函数输出hello world!</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> roses std</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> are </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> red ::</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> violets string</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> are </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> blue greet</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> this ()</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> poem &#123;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> makes return</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> no <span class="hljs-meta-string">&quot;hello world!&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> sense ;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> microwave &#125;</span><br><br><span class="hljs-comment">// Write a function &quot;greet&quot; that returns &quot;hello world!&quot; of type std::string</span><br>roses are red<br>violets are blue<br><span class="hljs-keyword">this</span> poem makes no sense<br>microwave<br></code></pre></td></tr></table></figure></blockquote><h4 id="6｜容器使用"><a href="#6｜容器使用" class="headerlink" title="6｜容器使用"></a>6｜容器使用</h4><h5 id="1｜vector"><a href="#1｜vector" class="headerlink" title="1｜vector"></a>1｜vector</h5><blockquote><p>1、vector排序:使用al头文件中的sort函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">sumTwoSmallestNumbers</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; numbers)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">std</span>::sort(numbers.begin(), numbers.end());<br>    <br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">long</span>)numbers[<span class="hljs-number">0</span>] + (<span class="hljs-keyword">long</span>)numbers[<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>2、定义一个vector的pair，并对pair内元素进行计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;utility&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">number</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;&amp; busStops)</span></span>&#123;<br>  <span class="hljs-keyword">int</span> passengers = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i: busStops)  passengers += i.first - i.second;<br>  <span class="hljs-keyword">return</span> passengers;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="2｜string"><a href="#2｜string" class="headerlink" title="2｜string"></a>2｜string</h5><blockquote><p>string中大小写转换以及find函数</p><p>toupper()函数只能对字符进行转换，而不能对全部字符串进行转换</p><p><code>toupper(char t)</code>//toupper()函数的参数为字符，而不能是字符串</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">abbrevName</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s = <span class="hljs-string">&quot;&quot;</span>;<br>  s += <span class="hljs-built_in">toupper</span>(name[<span class="hljs-number">0</span>]);<br>  s += <span class="hljs-string">&#x27;.&#x27;</span>;<br>  s += <span class="hljs-built_in">toupper</span>(name[name.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27; &#x27;</span>)+<span class="hljs-number">1</span>]);<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="3｜数组操作"><a href="#3｜数组操作" class="headerlink" title="3｜数组操作"></a>3｜数组操作</h4><blockquote><p>1、下标的转换与数组的首地址和地址操作，下标转换需要一定的积累，多刷题，掌握下标转换的一些技巧。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//遍历仅含a-z的字符串，统计每个字符的数目</span><br><span class="hljs-comment">//通过数量关系转换为数组下标</span><br><span class="hljs-keyword">int</span> count[<span class="hljs-number">26</span>];<br><span class="hljs-built_in">string</span> str;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;str[i] == <span class="hljs-string">&#x27;\0&#x27;</span>;i++)<br>count[str[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br><span class="hljs-comment">//此时，count的下标为str[i] - &#x27;a&#x27;即a的数目存储在count[0]中，以此类推</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>2、如果要进行两个字符串数组操作，如将其中一个字符串数组的元素进行拷贝，增加空格等操作；那么需要设置两个参数<code>int i  |  int j</code>分别对两个数组进行操作；因为可能存在不同步的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//对应的字符串增加空格</span><br><span class="hljs-comment">//增加相应的参数，理解为双指针</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;str1[i] &amp;&amp; str1[i] != <span class="hljs-string">&#x27;\n&#x27;</span>;i++,j+=<span class="hljs-number">2</span>)<br>&#123;<br>  str2[j] = str1[i];<br>  str2[j+<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="4｜基本算法思路"><a href="#4｜基本算法思路" class="headerlink" title="4｜基本算法思路"></a>4｜基本算法思路</h4><blockquote><p>1、字符加密，字符轮回偏移</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//首先要得出偏移量+偏移基础</span><br><span class="hljs-comment">//轮回使用取模运算</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c:s)<br>  <span class="hljs-keyword">if</span>(c &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)c = (c-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>) % <span class="hljs-number">26</span> + <span class="hljs-string">&#x27;a&#x27;</span>;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>2、第一类双指针算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)<br>&#123;<br>  <span class="hljs-keyword">int</span> j = i;<br><span class="hljs-keyword">while</span>(j&lt;str.size() &amp;&amp; str[i] == str[j])j++;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  需要进行的操作</span><br><span class="hljs-comment">  */</span><br>i = j+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>3、做算法题要有逆向思维，比如求子串的循环次数，从字符串入手比较复杂，那么考虑从循环次数入手。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Base</category>
      
      <category>Grammar</category>
      
      <category>Code</category>
      
      <category>Practise</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++_Grammar</title>
    <link href="/2021/02/28/0-CPP-Grammar/"/>
    <url>/2021/02/28/0-CPP-Grammar/</url>
    
    <content type="html"><![CDATA[<h3 id="1｜C-｜数组操作"><a href="#1｜C-｜数组操作" class="headerlink" title="1｜C++｜数组操作"></a>1｜C++｜数组操作</h3><h4 id="1｜C-数组长度"><a href="#1｜C-数组长度" class="headerlink" title="1｜C++数组长度"></a>1｜C++数组长度</h4><blockquote><p>在c++中没有函数直接返回数组长度的，所以使用宏定义和局部变量返回到数组长度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> c = <span class="hljs-keyword">sizeof</span>(a[]) / <span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>]);<br><span class="hljs-comment">//但是总求错，不知道为什么</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="2｜多维数组"><a href="#2｜多维数组" class="headerlink" title="2｜多维数组"></a>2｜多维数组</h4><blockquote><p>C++中二维数组默认是先行后列，a[i] [j]默认为先输出第i行，后输出第j列</p></blockquote><h3 id="2｜C-｜函数"><a href="#2｜C-｜函数" class="headerlink" title="2｜C++｜函数"></a>2｜C++｜函数</h3><h4 id="1｜作用域"><a href="#1｜作用域" class="headerlink" title="1｜作用域"></a>1｜作用域</h4><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><blockquote><p>单个模块使用（函数模块、循环与判断模块）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<span class="hljs-comment">//此时的a只哟ing与main模块中</span><br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-comment">//此时i只用于for循环模块中</span><br></code></pre></td></tr></table></figure></blockquote><h5 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h5><blockquote><p>如果没有发生重名，可以在本.cpp文件中全局使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> global = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">cout</span> &lt;&lt; global &lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">cout</span> &lt;&lt; global &lt;&lt; enld;<br>  func();<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="重名现象"><a href="#重名现象" class="headerlink" title="重名现象"></a>重名现象</h5><blockquote><p>如果全局变量和局部变量重名的话，那么当作是局部变量使用</p></blockquote><h5 id="常量的使用"><a href="#常量的使用" class="headerlink" title="常量的使用"></a>常量的使用</h5><blockquote><p>使用#define定义：只要是C++数据类型都可以使用宏来进行定义；同时宏定义还可以使用函数的形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PI 3.1415926</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NEWLINE <span class="hljs-meta-string">&#x27;\n&#x27;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//宏定义函数形式</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>使用const关键字定义：</p><p>const type(数据类型)    name（名称）</p><p><code>注意语法区别：使用define定义没有&#39;;&#39;，使用const定义有</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi= <span class="hljs-number">3.14</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> p = <span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure></blockquote><h4 id="2｜递归"><a href="#2｜递归" class="headerlink" title="2｜递归"></a>2｜递归</h4><h5 id="1｜递归实现借助堆栈"><a href="#1｜递归实现借助堆栈" class="headerlink" title="1｜递归实现借助堆栈"></a>1｜递归实现借助堆栈</h5><p>​    <code>静态存储分配｜栈内存分配｜堆内存分配</code></p><blockquote><p>c++程序在运行时，计算机的内存区被分为程序代码去、全局数据去、堆区和栈区</p></blockquote><blockquote><p>静态存储区分配：</p><p><code>使用static变量和static object（全局对象）的方式声明</code></p><p>内存在程序编译的时候就已经分配好并且存在于程序的整个运行过程</p></blockquote><ul><li><input disabled="" type="checkbox"> 程序的执行过程：编译、链接、运行</li></ul><blockquote><p>栈内存分配：</p><p>存在于某一个作用域的一块空间，如函数中的局部变量；</p></blockquote><blockquote><p>堆内存分配：</p><p>相当于是动态内存分配，通常使用new和delete关键字进行管理；堆内存空间可以由用户手动分配和释放。</p><p>堆内存的管理借助指针进行管理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> *p; <span class="hljs-comment">//定义一个指向int类型的指针p</span><br>  p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;<span class="hljs-comment">//开辟一个int大小的内存空间，指针p指向这片空间</span><br>  *p = <span class="hljs-number">6</span>;<span class="hljs-comment">//为这片空间中的变量赋值</span><br>  <span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-comment">//输出</span><br>  <span class="hljs-keyword">delete</span> p;<span class="hljs-comment">//释放内存空间</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><ul><li><input disabled="" type="checkbox"> 全局变量是静态存储分配还是堆栈类型？</li><li><input disabled="" type="checkbox"> new｜delete和malloc｜free有什么区别？</li><li><input disabled="" type="checkbox"> 递归是如何借助堆栈实现的？为什么借助了堆？还是只借助了栈？</li></ul><h4 id="3｜引用的使用"><a href="#3｜引用的使用" class="headerlink" title="3｜引用的使用"></a>3｜引用的使用</h4><blockquote><p>修改形参会影响实际参数;</p><p>引用和指针的区别：</p><ul><li>可以通过 <code>指针名=0</code> 描述一个空指针，但不存在空引用。</li><li>指针可在任何时间进行初始化操作，而引用只能在定义时进行初始化操作。</li><li>指针变量指向内存的一个存储单元；而引用只不过是原变量的一个别名而已。</li><li>定义的方式不同：应用的定义为<code>int &amp;x = i;</code>指针的定义为<code>int *s;</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i=<span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">int</span> j=<span class="hljs-number">4</span>;<br><br>    <span class="hljs-keyword">int</span> &amp;x = i;<br>    <span class="hljs-keyword">int</span> *s;<br>    s = &amp;j;<br><br>    <span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; *s &lt;&lt;<span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="4｜函数重载"><a href="#4｜函数重载" class="headerlink" title="4｜函数重载"></a>4｜函数重载</h4><blockquote><p>定义一个参数类型或者是参数个数不同的函数，当程序执行时，程序会根据参数类型和个数匹配函数。</p></blockquote><h3 id="3｜C-｜类和对象"><a href="#3｜C-｜类和对象" class="headerlink" title="3｜C++｜类和对象"></a>3｜C++｜类和对象</h3><p><code>抽象｜封装｜继承｜多态</code></p><blockquote><p>抽象：数据抽象和行为抽象，比如英雄联盟的防御塔，数据抽象就是血量是多少、防御使多少；行为抽象就是英雄进入范围后攻击</p><p>封装：对外提供ganging访问方式，内部的数据和行为进行隐藏；比如防御塔，在main函数中，直接调用防御塔这个对象就可以。</p><p>继承：通过代码复用，对子类进行具体说明；比如防御塔，二塔有一塔全部的属性和行为，但是在一塔告破后，二塔增加属性。</p><p>多态：一段程序能够处理多种类型对象的能力。多态包含：强制多态、重载多态、类型参数话多态、包含多态。<code>没理解</code></p></blockquote><h4 id="1｜类的定义"><a href="#1｜类的定义" class="headerlink" title="1｜类的定义"></a>1｜类的定义</h4><blockquote><p>对具有相同性质的对象进行抽象，找出共同的属性，构成同一类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> 类的名称：</span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">public</span>:<br>  外部接口<br>  <span class="hljs-keyword">protected</span>:<br>  保护性成员<br>  <span class="hljs-keyword">private</span>：<br>    私有成员<br>&#125;；<br></code></pre></td></tr></table></figure></blockquote><h4 id="2｜类的成员访问控制"><a href="#2｜类的成员访问控制" class="headerlink" title="2｜类的成员访问控制"></a>2｜类的成员访问控制</h4><ul><li><input disabled="" type="checkbox"> 没有掌握</li></ul><h5 id="1｜public"><a href="#1｜public" class="headerlink" title="1｜public"></a>1｜public</h5><h5 id="2｜protected"><a href="#2｜protected" class="headerlink" title="2｜protected"></a>2｜protected</h5><h5 id="3｜private"><a href="#3｜private" class="headerlink" title="3｜private"></a>3｜private</h5><h4 id="3｜对象的声明"><a href="#3｜对象的声明" class="headerlink" title="3｜对象的声明"></a>3｜对象的声明</h4><h4 id="4｜类的成员函数"><a href="#4｜类的成员函数" class="headerlink" title="4｜类的成员函数"></a>4｜类的成员函数</h4><h4 id="5｜struct基本结构体"><a href="#5｜struct基本结构体" class="headerlink" title="5｜struct基本结构体"></a>5｜struct基本结构体</h4><h5 id="1｜结构体声明"><a href="#1｜结构体声明" class="headerlink" title="1｜结构体声明"></a>1｜结构体声明</h5><h4 id="6｜类练习"><a href="#6｜类练习" class="headerlink" title="6｜类练习"></a>6｜类练习</h4><blockquote><p>声明枚举类型CPU_Rank，例如enum CPU_Rank{P1=1，P2，P3，P4，P5，P6，P7}，再声明成员函数run，stop，用来输出提示信息，在构造函数和析构函数中也可以输出提示信息。在主程序中声明一个CPU的对象，调用其成员函数，观察类对象的构造与析构顺序，以及成员函数的调用。</p></blockquote><h3 id="4｜C-基本数据类型与表达式"><a href="#4｜C-基本数据类型与表达式" class="headerlink" title="4｜C++|基本数据类型与表达式"></a>4｜C++|基本数据类型与表达式</h3><h4 id="1｜string类"><a href="#1｜string类" class="headerlink" title="1｜string类"></a>1｜string类</h4><blockquote><p>使用string头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br></code></pre></td></tr></table></figure></blockquote><h4 id="2-｜字符串操作"><a href="#2-｜字符串操作" class="headerlink" title="2 ｜字符串操作"></a>2 ｜字符串操作</h4><h4 id="1｜读与写"><a href="#1｜读与写" class="headerlink" title="1｜读与写"></a>1｜读与写</h4><p><code>fgets|scanf|fscanf|sscanf|gets|fputs｜cin</code></p><p><code>输入的方法比较多，实践后慢慢补全</code></p><h5 id="1｜fgets-读入字符串"><a href="#1｜fgets-读入字符串" class="headerlink" title="1｜fgets 读入字符串"></a>1｜fgets 读入字符串</h5><ul><li><p>Reads at most <code>count - 1</code> characters from the given file stream and stores them in the character array pointed to by <code>str</code>. Parsing stops if a newline character is found, in which case <code>str</code> will contain that newline character, or if end-of-file occurs. If bytes are read and no errors occur, writes a null character at the position immediately after the last character written to <code>str</code>.</p></li><li><p>fgets() 函数用来从指定的文件中读取一个字符串，并保存到字符数组中</p></li><li><p>fgets是将<code>std::FILE* stream</code>读取到<code>char* str</code>中，如果是没有超过<code>count</code>的话</p></li><li><p>fgets会读取回车<code>\n</code>，所以在计算字符串长度的时候需要增加边界条件<code>str[i] != &#39;\n&#39;</code>,但是fgets遇到</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">fgets</span><span class="hljs-params">( <span class="hljs-keyword">char</span>* str, <span class="hljs-keyword">int</span> count, <span class="hljs-built_in">std</span>::FILE* stream ）</span></span><br></code></pre></td></tr></table></figure><table><thead><tr><th>str</th><th>-</th><th>pointer to an element of a char array（指向数组的指针｜数组名字）</th></tr></thead><tbody><tr><td><strong>count</strong></td><td><strong>-</strong></td><td><strong>maximum number of characters to write (typically the length of <code>str</code>)（字符串允许输入的最大长度）</strong></td></tr><tr><td><strong>stream</strong></td><td><strong>-</strong></td><td><strong>file stream to read the data from（数据的输入形式）</strong></td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">std</span>::FILE* tmpf = <span class="hljs-built_in">std</span>::tmpfile();<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;Alan Turing\n&quot;</span>, tmpf);<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;John von Neumann\n&quot;</span>, tmpf);<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;Alonzo Church\n&quot;</span>, tmpf);<br> <br>    <span class="hljs-built_in">std</span>::rewind(tmpf);<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">8</span>];<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">std</span>::fgets(buf, <span class="hljs-keyword">sizeof</span> buf, tmpf) != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&#x27;&quot;&#x27;</span> &lt;&lt; buf &lt;&lt; <span class="hljs-string">&#x27;&quot;&#x27;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>fgets通常配合fopen、puts进行文件内容的输出</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* fgets example */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   FILE * pFile;<br>   <span class="hljs-keyword">char</span> mystring [<span class="hljs-number">100</span>];<br><br>   pFile = fopen (<span class="hljs-string">&quot;myfile.txt&quot;</span> , <span class="hljs-string">&quot;r&quot;</span>);<br>   <span class="hljs-keyword">if</span> (pFile == <span class="hljs-literal">NULL</span>) perror (<span class="hljs-string">&quot;Error opening file&quot;</span>);<br>   <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-keyword">if</span> ( fgets (mystring , <span class="hljs-number">100</span> , pFile) != <span class="hljs-literal">NULL</span> )<br>       <span class="hljs-built_in">puts</span> (mystring);<br>     fclose (pFile);<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> fgets输入到字符串中长度是否包含<code>&#39;\0&#39;</code></li><li><input disabled="" type="checkbox"> 一个文件的结束标记是什么？fgets如何读取出整个文件的内容，包括<code>&#39;\n&#39;</code>等内容</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* fgets example</span><br><span class="hljs-comment"> 可以输出myfile.txt中的全部内容</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   FILE * pFile;<br>   <span class="hljs-keyword">char</span> mystring [<span class="hljs-number">100</span>];<br><br>   pFile = fopen (<span class="hljs-string">&quot;myfile.txt&quot;</span> , <span class="hljs-string">&quot;r&quot;</span>);<br>   <span class="hljs-keyword">if</span> (pFile == <span class="hljs-literal">NULL</span>) perror (<span class="hljs-string">&quot;Error opening file&quot;</span>);<br>   <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-keyword">while</span> ( fgets (mystring , <span class="hljs-number">100</span> , pFile) != <span class="hljs-literal">NULL</span> )<br>       <span class="hljs-built_in">puts</span> (mystring);<br>     fclose (pFile);<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2｜fputs-写入字符串"><a href="#2｜fputs-写入字符串" class="headerlink" title="2｜fputs()写入字符串"></a>2｜fputs()写入字符串</h5><ul><li>Writes every character from the null-terminated string <code>str</code> to the output stream <code>stream</code>, as if by repeatedly executing [std::fputc](dfile:///Users/uoruichi/Library/Application Support/Dash/DocSets/C++/C++.docset/Contents/Resources/Documents/en.cppreference.com/w/cpp/io/c/fputc.html).</li><li>fputs() 函数用来向指定的文件写入一个字符串；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fputs</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str, [<span class="hljs-built_in">std</span>::FILE]</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> rc = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;Hello World&quot;</span>, <span class="hljs-built_in">stdout</span>);<span class="hljs-comment">//向stdout写入字符串</span><br> <br>    <span class="hljs-keyword">if</span> (rc == EOF)<br>       <span class="hljs-built_in">std</span>::perror(<span class="hljs-string">&quot;fputs()&quot;</span>); <span class="hljs-comment">// POSIX requires that errno is set</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 实现将vs code的输出保存为txt文件，相当于输出日志</li></ul><h5 id="3｜字符串操作函数-基于char"><a href="#3｜字符串操作函数-基于char" class="headerlink" title="3｜字符串操作函数            基于char[]"></a>3｜字符串操作函数            <code>基于char[]</code></h5><blockquote><p>在头文件<code>#include &lt;cstring&gt;</code>中有很多对字符串操作的函数；</p><p>但是只能用于<code>char str[n]</code>类型的声明，不能用于<code>string str</code>的声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> str1[<span class="hljs-number">10</span>] = <span class="hljs-string">&quot;hello&quot;</span>;<br>  <span class="hljs-keyword">char</span> str2[<span class="hljs-number">18</span>] = <span class="hljs-string">&quot;python&quot;</span>;<br>  <br>  <span class="hljs-built_in">strcat</span>(str1,str2);<br>  <span class="hljs-built_in">cout</span> &lt;&lt; str1 &lt;&lt; <span class="hljs-built_in">endl</span>;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>name</th><th>func</th></tr></thead><tbody><tr><td>函数</td><td>作用</td></tr><tr><td>strcpy(s1,s2)</td><td>复制字符串s2到s1中</td></tr><tr><td>strcat(s1,s2)</td><td>将字符串s2连接到s1的末尾</td></tr><tr><td>strlen(s)</td><td>计算字符串s的长度</td></tr><tr><td>strcmp(s1,s2)</td><td>比较字符串的长度，相同返回0；s2大的话返回-1;s1大的话返回1</td></tr><tr><td>strchr(s1,ch)</td><td>返回一个指针，指针指向ch在s1中的首个位置</td></tr><tr><td>strstr(s1,s2)</td><td>返回一个指针，指针指向s2在s1中的首位置</td></tr></tbody></table></blockquote><h5 id="4｜string类"><a href="#4｜string类" class="headerlink" title="4｜string类"></a>4｜string类</h5><blockquote><p>使用<code>string str;</code>声明的变量不是基于数组的，而是基于string类的；</p><p>对于字符串类中的str，使用‘+’号为连接</p><p><img src="http://uoruichi.oss-cn-beijing.aliyuncs.com/2021-03-09-001200.png" alt="image-20210309081159704"></p></blockquote><h3 id="5｜C-循环与条件判断"><a href="#5｜C-循环与条件判断" class="headerlink" title="5｜C++循环与条件判断"></a>5｜C++循环与条件判断</h3><h4 id="使用三元运算符"><a href="#使用三元运算符" class="headerlink" title="使用三元运算符"></a>使用三元运算符</h4><h5 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h5><blockquote><p>使用环境：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">c = (a&gt;b) ? a:b;<br><span class="hljs-comment">//a &gt; b 为条件判断===&gt;if else结构，如果a&gt;b成立则返回a；否则返回b</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="6｜STL"><a href="#6｜STL" class="headerlink" title="6｜STL"></a>6｜STL</h3><p><code>模版编程｜泛型编程｜STL常用组件｜lambda表达式｜异常处理｜内存处理</code></p><p><code>算法｜容器｜迭代器｜适配器｜仿函数（函数对象）｜空间适配器</code></p><p><code>泛型｜模版｜oop</code></p><blockquote><p>本部分所有代码至少需要开启 -std=c++11 选项来支持 C++11 相关特性，在介绍 C++14 特性时的相关代码需要开启 -std=c++14 的编译选项；可以在使用命令行g++的时候使用<code>g++ main.cpp -std = c++ 11(14)</code>来进行操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ main.cpp -std = c++ 11(14)<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>STL的算法是基于容器进行的，是通用的算法；并不依赖一某种数据结构和对象。</p></blockquote><blockquote><p>使用迭代器完成对容器的访问，迭代器底层是由指针实现的，这也是c++和c的区别，c实现算法和数据结构都是由指针实现的；c++实现算法和数据结构是通过容器+迭代器实现的；所以是不是可以理解为c比c++更加接近底层。</p></blockquote><blockquote><p>STL的基本容器是vector、list、queue；基本容器的适配器是queue、stack</p></blockquote><blockquote><p>空间适配器就是STL自己的内存池</p></blockquote><h4 id="1｜容器"><a href="#1｜容器" class="headerlink" title="1｜容器"></a>1｜容器</h4><h5 id="1｜vector（向量—-变长数组）"><a href="#1｜vector（向量—-变长数组）" class="headerlink" title="1｜vector（向量—-变长数组）"></a>1｜vector（向量—-变长数组）</h5><p><code>邻接表的方式存储图｜解决普通数组超内存|用于处理输入数据数量不确定的情况</code></p><blockquote><p>定义vector</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">typename</span>&gt; name;<span class="hljs-comment">//定义一个typename类型的vector变量,变量名字为name</span><br><span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">array</span>;<span class="hljs-comment">//相当于定义一个int类型的array[SIZE]数组</span><br></code></pre></td></tr></table></figure><p>进阶定义</p><ul><li>定义一个vector的结构体</li><li>定义一个二维数组</li></ul></blockquote><blockquote><p>vector内元素循环访问</p><ul><li>通过下标访问</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dc++">vector &lt;int&gt; vi;<br>printf(&quot;%&quot;,vi[index]);&#x2F;&#x2F;通过index进行访问，index的范围为[0,vi.size()]，可以直接调用vi.size()输出vi数组的长度<br></code></pre></td></tr></table></figure><ul><li>通过迭代器访问，迭代器可以理解为指针，迭代器也是需要定义的，可以理解为一个变量。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; ::iterator it;<span class="hljs-comment">//得到迭代器it，it是迭代器的名字，所以可以定义为别的名字</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; vi;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)  vi.push_back(i);<br>    <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; ::iterator it = vi.begin();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<span class="hljs-comment">//迭代器使用的第一种用法</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,*(it+i));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">for</span>(it=vi.begin();it != vi.end();it++)<span class="hljs-comment">//迭代器循环的第二种用法</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,*it);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>push_back函数与pop_back函数的使用</p><p>push_back()是在vector的末尾添加x</p><p>pop_back()是删除vector的末尾元素但是不会输出删除了哪些。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; vi;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">6</span>;i++)   vi.push_back(i);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t%d\n&quot;</span>,vi[<span class="hljs-number">0</span>],vi[<span class="hljs-number">6</span>]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)    vi.pop_back();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;vi.size();i++)    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,vi[i]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>size函数，返回值为int类型，返回vector的大小</p></blockquote><blockquote><p>clear()函数，晴空vector容器</p></blockquote><blockquote><p>insert()，基于迭代器进行操作，需要添加两个参数，<code>vi.insert(it+2,-1)</code>，将-1添加到<code>vi[2]</code>的位置</p></blockquote><blockquote><p>erase()，删除区间内的元素，<code>vi.erase(it.begin(),it.end())</code>，删除元素的范围左开右闭<code>[it.begin(),it.end())</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; vi;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)  vi.push_back(i);<br>    <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; ::iterator it = vi.begin();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,*(it+i));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-comment">//  for(vector &lt;int&gt; ::iterator it = vi.begin();it != vi.end();it++)</span><br><span class="hljs-comment">//      printf(&quot;%d &quot;,*it);</span><br>    vi.erase(vi.begin(),vi.begin()+<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;vi.size();i++)    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,vi[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    vi.erase(vi.begin(),vi.end());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;vi.size();i++)    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,vi[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// output</span><br><span class="hljs-comment">// 0 1 2 3 4 </span><br><span class="hljs-comment">// 2 3 4  //经过第一次erase()，begin(),begin+2,删除的区间是[begin()+0,begin()+2)的区间</span><br><span class="hljs-comment">// //经过第二次erase(),可以看出来begin(),end()的范围的话，是全部删除</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 使用vector定义邻接表</li></ul></blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 使用完vector后，是不是不用释放空间？</li></ul></blockquote><h5 id="2｜list（列表）"><a href="#2｜list（列表）" class="headerlink" title="2｜list（列表）"></a>2｜list（列表）</h5><h5 id="3｜queue（队列）"><a href="#3｜queue（队列）" class="headerlink" title="3｜queue（队列）"></a>3｜queue（队列）</h5><h5 id="4｜deque（双端队列）"><a href="#4｜deque（双端队列）" class="headerlink" title="4｜deque（双端队列）"></a>4｜deque（双端队列）</h5><h5 id="5｜set（集合）"><a href="#5｜set（集合）" class="headerlink" title="5｜set（集合）"></a>5｜set（集合）</h5><h5 id="6｜multiset（多种集合）"><a href="#6｜multiset（多种集合）" class="headerlink" title="6｜multiset（多种集合）"></a>6｜multiset（多种集合）</h5><h5 id="7｜map（映射）"><a href="#7｜map（映射）" class="headerlink" title="7｜map（映射）"></a>7｜map（映射）</h5><h5 id="8｜multimap（多重映射）"><a href="#8｜multimap（多重映射）" class="headerlink" title="8｜multimap（多重映射）"></a>8｜multimap（多重映射）</h5><h4 id="2｜模版编程"><a href="#2｜模版编程" class="headerlink" title="2｜模版编程"></a>2｜模版编程</h4><p><code>基本语法｜模版函数｜类模版｜成员模版｜模版中的静态成员｜typename与class｜迭代器</code></p><h5 id="1｜函数模版化"><a href="#1｜函数模版化" class="headerlink" title="1｜函数模版化"></a>1｜函数模版化</h5><blockquote><p>为什么要使用模版编程的思想？</p><p>因为C++中对于数据类型区分比较明确，所以使用模版编程的话会简化工作，也就是使用模版来定义数据类型。</p><p>向 <code>add</code> 函数提供参数时，编译器会自动分析参数的类型，然后将所有用到 T 定义的换成相对性的类型。其实主要的作用在于自动分析参数的类型。这样定义的函数可以多次重复调用，而不用多次编辑。</p><p>其实也就是使用<code>template &lt;typename T&gt;</code>替换类型，再由编译器自动分析参数类型</p><p>定义：<code>template</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T lva,<span class="hljs-keyword">const</span> T rva)</span></span><br><span class="hljs-function"></span>&#123;<br>  T a;<br>  a = lva + rva;<br>  <span class="hljs-keyword">return</span> a;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">cout</span> &lt;&lt; add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br> <span class="hljs-built_in">cout</span> &lt;&lt; add(<span class="hljs-number">1.0</span>,<span class="hljs-number">2.2</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="2｜类模版化"><a href="#2｜类模版化" class="headerlink" title="2｜类模版化"></a>2｜类模版化</h5><blockquote><p>使用类模版化的前提是对类的操作要熟悉</p><p>在定义类模板的时候，常常使用 class 作为关键字，增加代码可读性。其它则用 typename，上面的代码大都遵循这样的标准，但是并无强制规定。</p></blockquote><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Myclass</span></span><br><span class="hljs-class">&#123;</span><br>  T a;<br>  <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">T <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T lva,<span class="hljs-keyword">const</span> T rva)</span></span>;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br>T Myclass &lt;T&gt;::add(<span class="hljs-keyword">const</span> T lva,<span class="hljs-keyword">const</span> T rva)<br>&#123;<br>  a = lva + rva;<br>  <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="3-迭代器"><a href="#3-迭代器" class="headerlink" title="3|迭代器"></a>3|迭代器</h5><blockquote><p>迭代器（iterator）是一种对象，它能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址。迭代器修改了常规指针的接口，所谓迭代器是一种概念上的抽象：那些行为上像迭代器的东西都可以叫做迭代器。然而迭代器有很多不同的能力，它可以把抽象容器和通用算法有机的统一起来。迭代器基本分为五种，输入输出迭代器，前向逆向迭代器，双向迭代器和随机迭代器。</p><p>迭代是重复反馈过程的活动，其目的通常是为了接近并到达所需的目标或结果。 每一次对过程的重复被称为一次“迭代”，而每一次迭代得到的结果会被用来作为下一次迭代的初始值。</p></blockquote><blockquote><p>理解：</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Base</category>
      
      <category>Grammar</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
